const _astro_dataLayerContent = [["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.4.3","content-config-digest","ea829a50c4bf63d3","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://patterns.leetekwoo.com\",\"compressHTML\":true,\"base\":\"/dist/dev/build-algo\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"class\",\"build\":{\"format\":\"file\",\"client\":{},\"server\":{},\"assets\":\"asset\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","algorithms",["Map",11,12,25,26,37,38,47,48,59,60,70,71,81,82],"leetcode/4-median-of-two-sorted-array",{id:11,data:13,body:21,filePath:22,digest:23,deferredRender:24},{title:14,description:15,createdAt:16,path:17,tags:20},"LeetCode 4. Median of Two Sorted Arrays","LeetCode problem 4","2025-03-17",[9,18,19],"leetcode","binary-search",{pattern:19,category:18},"# LeetCode 4. Median of Two Sorted Array\n\n[문제 링크](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n# Topics\n\n- Array\n- Binary Search\n- Divide and Conquer\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n사실 이진 탐색으로 풀어야하는 문제인데,\n\n## 정답\n\n```js\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  let merged = [...nums1, ...nums2].sort((a, b) => a - b);\n  let size = merged.length,\n    isEven = size % 2 === 0;\n  let pointer = isEven ? Math.floor(size / 2) - 1 : Math.floor(size / 2);\n\n  if (isEven) {\n    return (merged[pointer] + merged[pointer + 1]) / 2;\n  } else {\n    return merged[pointer];\n  }\n};\n```\n\n## 사고 과정\n\n처음에 set으로 시도하려 했으나, 테스트 케이스 44번에 중복 숫자 허용이 껴있어서 수정함.\n\n1. Median 정의\n   - 숫자 총합의 중간 값인지, 말 그대로 배열의 가장 중앙을 뜻하는 지 확인. 후자.\n   - 병합된 두 배열의 길이가 홀수 일 때는 Math.floor(length / 2)의 인덱스 값\n   - 짝수일 때는 Math.floor(length / 2)와 +1의 요소를 더한 뒤 / 2\n2. 두 배열을 합한 뒤 sort = merged - 중간 값의 탐색 대상\n3. 1번에서 중간 값이 배열 길이에 따라 달라짐을 확인함. 그대로 반환값 계산함\n\n- 중복 요소 허용, 비허용에 대한 힌트가 없어 테스트 케이스에서 찾아냄.","site/content/algorithms/leetcode/4-median-of-two-sorted-array.mdx","d50c7841de80ae1f",true,"leetcode/2-add-two-numbers",{id:25,data:27,body:34,filePath:35,digest:36,deferredRender:24},{title:28,description:29,createdAt:16,path:30,tags:33},"Linked List - LeetCode 2. Add Two Numbers","LeetCode problem",[9,18,31,32],"linked-list","two-pointer",{pattern:32,category:18},"[문제 링크](https://leetcode.com/problems/add-two-numbers/)\n\n# Topics\n\n- Linked List\n- Math\n- Recursion\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n  let carry = 0;\n\n  while (l1 !== null || l2 !== null || carry > 0) {\n    let sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10); // 10을 넘으면 올림값 저장\n\n    current.next = new ListNode(sum % 10); // 현재 노드 추가\n    current = current.next; // 포인터 이동\n\n    l1 = l1?.next || null;\n    l2 = l2?.next || null;\n  }\n\n  return dummyHead.next; // 실제 리스트 시작점 반환\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 새로운 연결 리스트 생성 오류\n\nreturnList를 리스트로 변환하려 했으나 next 추가 방식이 틀림.\n올바른 방식은 새로운 ListNode를 생성하고 current.next로 연결해야 함.\n반복문에서 next 추가 방법 문제\n\nreturnList(start, next)는 올바르지 않음.\ndummyHead 노드를 두고 current 포인터를 활용하여 next로 연결해야 함.\n\n2. 리스트 숫자 변환 오류 (getAllNum 함수)\n\n```\nwhile (li?.val) → while (li !== null)\nnums.unshift(li.val) 대신 nums.push(li.val)\njoin(\"\") * 1 대신 Number(join(\"\")) 또는 BigInt(join(\"\")) 사용해야 큰 숫자 처리 가능.\n\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  // 두 리스트에서 합을 구함\n  function getAllNum(list) {\n    let nums = [];\n    let li = list;\n    while (li?.val) {\n      nums.unshift(li.val);\n      li = li.next;\n    }\n    return nums.join(\"\") * 1;\n  }\n\n  let sum = getAllNum(l1) + getAllNum(l2);\n  let result = String(sum)\n    .split(\"\")\n    .map((char) => char * 1);\n\n  console.log(result);\n  const returnList = new ListNode();\n\n  // 반복문에서 지금 링크 리스트에 추가, next를 어떻게 추가해야 할 지 모르겠음\n  while (result.length > 0) {\n    const start = result.pop();\n    returnList(start, next);\n  }\n};\n```","site/content/algorithms/leetcode/2-add-two-numbers.mdx","0692aaeb8def1589","leetcode/3-longest-substring",{id:37,data:39,body:44,filePath:45,digest:46,deferredRender:24},{title:40,description:29,createdAt:16,path:41,tags:43},"LeetCode 3. Longest Substring Without Repeating Characters",[9,18,42],"sliding-window",{pattern:42,category:18},"# LeetCode 3. Longest Substring - Sliding Windows\n\n[문제 링크](https://leetcode.com/problems/surrounded-regions)\n\n# Topics\n\n- Hash Table\n- String\n- Sliding Window\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end < s.length; end++) {\n    let char = s[end];\n\n    // 중복 문자가 존재하면 앞에서 제거하면서 윈도우 이동\n    /**@note 이 부분에서 s[start]로 start를 움직이고, set에서 제거함\n     * @note Sliding Window의 가변 크기가 구현됨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // 새로운 문자 추가\n    /** @note 업데이트 시점은 set의 변경 이후에 실행함 **/\n    longest = Math.max(longest, end - start + 1); // 길이 갱신\n  }\n\n  return longest;\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 새로운 연결 리스트 생성 오류\n\nreturnList를 리스트로 변환하려 했으나 next 추가 방식이 틀림.\n올바른 방식은 새로운 ListNode를 생성하고 current.next로 연결해야 함.\n반복문에서 next 추가 방법 문제\n\nreturnList(start, next)는 올바르지 않음.\ndummyHead 노드를 두고 current 포인터를 활용하여 next로 연결해야 함.\n\n2. 리스트 숫자 변환 오류 (getAllNum 함수)\n\n```\nwhile (li?.val) → while (li !== null)\nnums.unshift(li.val) 대신 nums.push(li.val)\njoin(\"\") * 1 대신 Number(join(\"\")) 또는 BigInt(join(\"\")) 사용해야 큰 숫자 처리 가능.\n\n```\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = -1;\n  for (let end = 0; end < s.length; end++) {\n    let char = s[end];\n    if (!set.has(char)) {\n      set.add(char);\n    } else {\n      longest = Math.max(longest, end - start + 1);\n      start++;\n      // set 초기화? 업데이트? 어떻게 해야하지.\n    }\n  }\n\n  return longest;\n};\n```","site/content/algorithms/leetcode/3-longest-substring.mdx","28918f717900ab4d","leetcode/130-surrounded-regions",{id:47,data:49,body:56,filePath:57,digest:58,deferredRender:24},{title:50,description:51,createdAt:16,path:52,tags:54},"LeetCode 130. Surrounded Regions","LeetCode problem 130",[9,18,53],"leetcode-130-surrounded-regions",{pattern:55,category:18},"DFS","# LeetCode 130. Surrounded Regions\n\n[문제 링크](https://leetcode.com/problems/surrounded-regions)\n\n# Topics\n\n- Array\n- Depth-First Search\n- Breadth-First Search\n- Union Find\n- Matrix\n\n# 문제 포인트\n\n## 정답\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  if (!board.length || !board[0].length) return;\n\n  let rSize = board.length,\n    cSize = board[0].length;\n  let directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // 가장자리에 연결된 'O'를 찾고 'S'로 변경 (보존 처리)\n  function dfs(r, c) {\n    if (r < 0 || c < 0 || r >= rSize || c >= cSize || board[r][c] !== \"O\") {\n      return;\n    }\n    board[r][c] = \"S\"; // 가장자리에 연결된 'O'는 보존\n    for (let [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  }\n\n  // 1. 가장자리에서 DFS 탐색하여 'O' → 'S' 변경 (보존)\n  for (let r = 0; r < rSize; r++) {\n    dfs(r, 0);\n    dfs(r, cSize - 1);\n  }\n\n  for (let c = 0; c < cSize; c++) {\n    dfs(0, c);\n    dfs(rSize - 1, c);\n  }\n\n  // 2. 보드를 업데이트\n  for (let r = 0; r < rSize; r++) {\n    for (let c = 0; c < cSize; c++) {\n      if (board[r][c] === \"O\") {\n        board[r][c] = \"X\"; // 감싸진 'O' → 'X'\n      } else if (board[r][c] === \"S\") {\n        board[r][c] = \"O\"; // 보존된 'S' → 원래대로 'O'\n      }\n    }\n  }\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. DFS 방문 로직 오류 (dfs 내부 조건 오류)\n\n- if (visited[r][c]) return false → 이미 방문한 곳을 다시 방문하지 않도록 하는 것은 맞지만, dfs가 참/거짓을 반환해야 하는 이유가 불분명함.\n- isChange = dfs([nr, nc]) 부분에서 true를 반환하면 board[r][c] = \"X\"로 변경하는데, 모든 경로를 탐색한 후 변환 여부를 결정해야 함.\n- 즉, 인접한 모든 'O'를 방문한 후 변경 여부를 판단해야 함.\n\n2. 경계 조건 처리 오류 (isCurrentEdge 활용 문제)\n\n- isCurrentEdge가 true면 즉시 false를 반환하는 것은 틀림.\n- 가장자리에 있는 'O'를 발견하면 해당 영역 전체를 보존해야 함.\n- false를 반환해도 인접 노드가 영향을 받지 않음 → 가장자리에 연결된 모든 'O'를 변경하지 않도록 표기하는 것이 핵심.\n\n3. 보드 업데이트 타이밍 문제 (board[r][c] = \"X\")\n\n- DFS 도중 바로 \"X\"로 변환하면 안 됨.\n- 탐색 중인 'O'가 실제로 감싸져 있는지 확정되지 않은 상태에서 변경되면 오답 가능성 증가.\n- 모든 DFS가 완료된 후, 감싸진 'O'를 'X'로 변환해야 함.\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  let rSize = board.length,\n    cSize = board[0].length;\n  let visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  let offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // dfs t/f 반환. t면 X로 바꾼다, f면 바꾸지 않는다.\n  function dfs([r, c]) {\n    if (visited[r][c]) return false;\n    visited[r][c] = true;\n\n    const isCurrentEdge =\n      r === 0 || c === 0 || r === rSize - 1 || c === cSize - 1;\n\n    // 인접이 X인 경우, 연결된 모든 O가 X라면 바꿔야함\n    if (board[r][c] === \"X\") return true;\n    // 또는 O가 가장 자리에 있다면 X로 바꿀 수 없음\n    if (board[r][c] === \"O\" && isCurrentEdge) return false;\n\n    // 현재 노드 = \"O\" 인접 노드에 따라 자기 자신이 바뀜\n    // 1. 인접 노드를 모두 방문하고,\n    // 2. 자기 자신의 바꾸는 여지를 정함.\n\n    // 인접 노드 방문 전에 현재 O를 X로 바꾸는 로직이 필요하다\n    // O\n\n    /**\n        목적: dfs가 tf를 반환하여 인접 노드 방문한 결과값이 t/f를 반환하게 한다.\n        조건:\n        - 모든 인접이 X이면? 현재 노드를 X로 바꾼다\n        - 모든 인접이 X가 아니면? O인 노드로 이동한다\n        - 현재 노드의 r, c가 0이나 r,cSize-1이면? 변환하지 않는다 - 위에서 false 변환\n         **/\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [r + or, c + oc];\n      let isChange = false;\n      if (nr >= 0 && nc >= 0 && nr < rSize && c < cSize && !visited[nr][nc]) {\n        isChange = dfs([nr, nc]);\n        if (isChange) {\n          board[r][c] = \"X\";\n        }\n      }\n    }\n    return isCurrentEdge;\n  }\n  // board 자체를 dfs 내부에서 변환한 뒤 리턴.\n  return board;\n};\n```","site/content/algorithms/leetcode/130-surrounded-regions.mdx","af16ceecded84e5e","leetcode/5-longest-palindromic-substring",{id:59,data:61,body:67,filePath:68,digest:69,deferredRender:24},{title:62,description:63,createdAt:16,path:64,tags:66},"LeetCode 5. Longest Palindromic Substring","LeetCode problem 5",[9,18,65],"dynamic-programming",{pattern:65,category:18},"# LeetCode 5. Longest Substring - Sliding Windows\n\n[문제 링크](https://leetcode.com/problems/longest-palindromic-substring/)\n\n# Topics\n\n- String\n- Two Pointers\n- Dynamic Programming\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end < s.length; end++) {\n    let char = s[end];\n\n    // 중복 문자가 존재하면 앞에서 제거하면서 윈도우 이동\n    /**@note 이 부분에서 s[start]로 start를 움직이고, set에서 제거함\n     * @note Sliding Window의 가변 크기가 구현됨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // 새로운 문자 추가\n    /** @note 업데이트 시점은 set의 변경 이후에 실행함 **/\n    longest = Math.max(longest, end - start + 1); // 길이 갱신\n  }\n\n  return longest;\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 성능 최적화. reverse로 비교하는 비용이 너무 크다\n2. 예외처리: 한글자, 같은 두글자일때 등. 좀 더 추상적인 로직으로 개별 예외처리 안할 수도 있을텐데.\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length === 1) return s;\n  let longest = 0,\n    start = 0,\n    n = s.length,\n    result = \"\";\n  while (start < n - 1) {\n    for (let end = start + 1; end < n; end++) {\n      let slice = s.slice(start, end + 1); // + 1 ?\n      let reverse = slice.split(\"\").reverse().join(\"\");\n      if (slice === reverse && slice.length >= longest) {\n        result = slice;\n        longest = slice.length;\n      }\n    }\n    start++;\n  }\n\n  return result || s[0];\n};\n```","site/content/algorithms/leetcode/5-longest-palindromic-substring.mdx","f41fc55c9a450c77","leetcode/79-word-search",{id:70,data:72,body:78,filePath:79,digest:80,deferredRender:24},{title:73,description:74,createdAt:16,path:75,tags:77},"LeetCode 79. Word Search","LeetCode problem 79",[9,18,76],"backtracking",{pattern:76,category:18},"# DFS - LeetCode 79. Word Search\n\n# 문제 포인트\n\n1. 탐색 결과가 **방문 순서에 영향을 받음**\n2. **백트래킹**이 필요함\n   - `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n[이전 글](https://blog.leetekwoo.com/blog/63#3-3-backtracking)에서 살핀 백트레킹을 활용하는 문제이다. visited를 인접 행렬로 관리한다.\n\n## 정답\n\n```js\n/**\n * @description 문제 : 인접 행렬에서 word를 만들 수 있는 여부 true/false\n *   방향은 상관없다. (왼<->오, 위 <->아래)\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function (board, word) {\n  const rSize = board.length;\n  const cSize = board[0].length;\n  const visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs(r, c, count = 0) {\n    if (word.length === count) return true; // 기저 조건. 재귀 함수 전체 중단 조건\n    /** @note 여기서 방문 처리 X **/\n    // visited[r][c] = true; //\n    if (\n      // 조건 해당 시\n      r >= 0 &&\n      c >= 0 &&\n      r < rSize &&\n      c < cSize &&\n      !visited[r][c] &&\n      board[r][c] === word[count]\n    ) {\n      /** @note 방문 처리를 여기서 해야함. **/\n      visited[r][c] = true; // 방문 처리를 여기서 해야함\n      for (let [or, oc] of offset) {\n        if (dfs(r + or, c + oc, count + 1)) return true;\n      }\n      /** @note 백트레킹 : 경로마다 다른 결과가 나올 수 있어 해주어야함. **/\n      visited[r][c] = false;\n    }\n\n    return false;\n  }\n\n  for (let r = 0; r < rSize; r++) {\n    for (let c = 0; c < cSize; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n\n  return false;\n};\n```\n\n## 오답 사고 과정\n\n```js\nvar exist = function (board, word) {\n  const n = board.length;\n  const visited = Array.from({ length: n }, () => Array(n).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs([r, c], word, visited, count = 0) {\n    if (visited[r][c]) return count;\n    visited[r][c] = true;\n    if (word[count] === board[r][c]) {\n      // count를 어떻게 처리해야 될 지 몰랐다.\n      // 인접노드 방문 현재 글자가 word[count]랑 같을 때만 재귀 호출\n\n      for (let [or, oc] of offset) {\n        const [nr, nc] = [r + or, c + oc];\n        if (\n          nr < n &&\n          nc < n &&\n          nr >= 0 &&\n          nc >= 0 &&\n          !visited[nr][nc] &&\n          board[nr][nc] === word[count + 1]\n        ) {\n          count += dfs([nr, nc], word, visited, count + 1);\n        }\n      }\n    } else {\n      return count;\n    }\n  }\n  // 문제 조건이 O(n^2)으로 2중 포문으로 푸는 것이 더 적절했음\n  // count가 조건에 맞으면 바로 리턴만 하면됨. 누적할 필요는 없었음.\n  const result = dfs([0, 0], word, visited, 0);\n  return result === word.length;\n};\n```","site/content/algorithms/leetcode/79-word-search.mdx","401aa0255d2279f3","leetcode/94-binary-tree-inorder-traverse",{id:81,data:83,body:91,filePath:92,digest:93,deferredRender:24},{title:84,description:85,createdAt:16,path:86,tags:89},"LeetCode 94. Binary Tree Inorder Traversal","LeetCode problem 94",[9,18,87,88],"tree","traversal",{pattern:90,category:18},"tree-traversal","# LeetCode 94. Binary Tree Inorder Traverse\n\n[문제 링크](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n# Topics\n\n- Stack\n- Tree\n- Depth-First Search\n- Binary Tree\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length < 2) return s; // 한 글자면 그대로 반환\n\n  let start = 0,\n    maxLength = 1;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return [left + 1, right - 1]; // 팰린드롬의 시작과 끝 인덱스 반환\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    // 홀수 길이 팰린드롬\n    let [l1, r1] = expandAroundCenter(i, i);\n    // 짝수 길이 팰린드롬\n    let [l2, r2] = expandAroundCenter(i, i + 1);\n\n    if (r1 - l1 + 1 > maxLength) {\n      start = l1;\n      maxLength = r1 - l1 + 1;\n    }\n    if (r2 - l2 + 1 > maxLength) {\n      start = l2;\n      maxLength = r2 - l2 + 1;\n    }\n  }\n\n  return s.slice(start, start + maxLength);\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. visited가 불필요한데 사용했음\n2. param으로 들어오는 root의 값처리를 제대로 못함\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  let output = [];\n  let visited = new Set();\n  function dfs(root, cur) {\n    if (visited.has(cur) || !root?.val) return;\n    visited.add(cur);\n    output.push(root.val);\n\n    // 인접 노드 방문 중위 순회는 왼 -> 루트 -> 오\n    dfs(root, root?.left);\n    dfs(root, root?.right);\n  }\n  dfs(root, root?.val);\n  return output;\n};\n```","site/content/algorithms/leetcode/94-binary-tree-inorder-traverse.mdx","0b8808a274c0051d"];

export { _astro_dataLayerContent as default };
