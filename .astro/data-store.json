[["Map",1,2,9,10,26,27],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.4.3","content-config-digest","56efaea828b2378c","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://patterns.leetekwoo.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"class\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","uiux",["Map",11,12],"button/react-button",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"deferredRender":25},{"title":14,"description":15,"createdAt":16,"path":17,"tags":20},"React Button (basic)","UIUX Patterns","2025-03-17",[9,18,19],"button","react",{"category":21,"component":18,"framework":19},"UI","import CodeDisplay from \"site/components/code-display.astro\";\nimport TabPanel from \"site/components/tab-panel.astro\";\nimport Tabs from \"site/components/tabs.astro\";\nimport Button from \"./button\";\n\n## React Buttons\n\n\u003CTabs tabs={[\"Button Component\", \"button.tsx\"]}>\n  \u003CTabPanel isDefault={true} tabIndex={0} tabName={\"Button Component\"}>\n    \u003CButton client:load text={\"Click me\"} />\n  \u003C/TabPanel>\n  \u003CTabPanel tabName=\"button.tsx\" tabIndex={1}>\n    \u003CCodeDisplay file=\"uiux/button/button.tsx\" highlightLines=\"{5-7}\" />\n  \u003C/TabPanel>\n\u003C/Tabs>","site/content/uiux/button/react-button.mdx","4079ab745d0342db",true,"algorithms",["Map",28,29,40,41,53,54,63,64,75,76,85,86,95,96,108,109,119,120,131,132,141,142,152,153,163,164,172,173,183,184,194,195,206,207,216,217,226,227,236,237,246,247,256,257,267,268,277,278,287,288,297,298,307,308,317,318,328,329,337,338,347,348,356,357,366,367,376,377,386,387,396,397],"backtracking/leetcode-79-word-search",{"id":28,"data":30,"body":37,"filePath":38,"digest":39,"deferredRender":25},{"title":31,"description":32,"createdAt":16,"path":33,"tags":36},"LeetCode 79. Word Search","LeetCode problem 79",[26,34,35],"leetcode","backtracking",{"pattern":35,"category":34},"# 문제 포인트\n\n[문제 링크](https://leetcode.com/problems/word-search/)\n\n1. 탐색 결과가 **방문 순서에 영향을 받음**\n2. **백트래킹**이 필요함\n   - `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n[이전 글](https://blog.leetekwoo.com/blog/63#3-3-backtracking)에서 살핀 백트레킹을 활용하는 문제이다. visited를 인접 행렬로 관리한다.\n\n## 정답\n\n```js\n/**\n * @description 문제 : 인접 행렬에서 word를 만들 수 있는 여부 true/false\n *   방향은 상관없다. (왼\u003C->오, 위 \u003C->아래)\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function (board, word) {\n  const rSize = board.length;\n  const cSize = board[0].length;\n  const visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs(r, c, count = 0) {\n    if (word.length === count) return true; // 기저 조건. 재귀 함수 전체 중단 조건\n    /** @note 여기서 방문 처리 X **/\n    // visited[r][c] = true; //\n    if (\n      // 조건 해당 시\n      r >= 0 &&\n      c >= 0 &&\n      r \u003C rSize &&\n      c \u003C cSize &&\n      !visited[r][c] &&\n      board[r][c] === word[count]\n    ) {\n      /** @note 방문 처리를 여기서 해야함. **/\n      visited[r][c] = true; // 방문 처리를 여기서 해야함\n      for (let [or, oc] of offset) {\n        if (dfs(r + or, c + oc, count + 1)) return true;\n      }\n      /** @note 백트레킹 : 경로마다 다른 결과가 나올 수 있어 해주어야함. **/\n      visited[r][c] = false;\n    }\n\n    return false;\n  }\n\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n\n  return false;\n};\n```\n\n## 오답 사고 과정\n\n```js\nvar exist = function (board, word) {\n  const n = board.length;\n  const visited = Array.from({ length: n }, () => Array(n).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs([r, c], word, visited, count = 0) {\n    if (visited[r][c]) return count;\n    visited[r][c] = true;\n    if (word[count] === board[r][c]) {\n      // count를 어떻게 처리해야 될 지 몰랐다.\n      // 인접노드 방문 현재 글자가 word[count]랑 같을 때만 재귀 호출\n\n      for (let [or, oc] of offset) {\n        const [nr, nc] = [r + or, c + oc];\n        if (\n          nr \u003C n &&\n          nc \u003C n &&\n          nr >= 0 &&\n          nc >= 0 &&\n          !visited[nr][nc] &&\n          board[nr][nc] === word[count + 1]\n        ) {\n          count += dfs([nr, nc], word, visited, count + 1);\n        }\n      }\n    } else {\n      return count;\n    }\n  }\n  // 문제 조건이 O(n^2)으로 2중 포문으로 푸는 것이 더 적절했음\n  // count가 조건에 맞으면 바로 리턴만 하면됨. 누적할 필요는 없었음.\n  const result = dfs([0, 0], word, visited, 0);\n  return result === word.length;\n};\n```","site/content/algorithms/backtracking/leetcode-79-word-search.mdx","a808bde14e0d4aae","bfs/core",{"id":40,"data":42,"body":50,"filePath":51,"digest":52,"deferredRender":25},{"title":43,"description":44,"createdAt":45,"path":46,"tags":48},"Bfs","1,2차원 배열에 따라 다름","2025-03-19",[26,47],"core",{"pattern":49,"category":47},"","> 📌 **Source Code:** [bfs/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/bfs/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  enqueue(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  dequeue() {\n    return this.items[this.front++];\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(start, graph, visited, answer) {\n  let Q = new Queue();\n  visited[start] = true; // 1,2차원 배열에 따라 다름\n  /* 최소, 최단 거리 등을 계산해야한다면 param으로 받고,\n   반복문 안에서 조건에 맞을 시 업데이트 한 뒤 return한다.\n   혹은 해당하는 좌표의 묶음 등을 필요로 할 시\n    let result = [start];를 반복문 외부에 만들고,\n    result.push(newNode)를 하면 방문하는 순서대로 쌓이게 된다.\n    */\n\n  // 큐 시작점 추가\n  Q.push(start); // 1,2차원 배열에 따라 start 형태 다름\n  while (!Q.isEmpty()) {\n    let start = Q.dequeue();\n    // 조건문 추가\n\n    for (let neighbor of graph[start]) {\n      // 방문 여부 + graph[neighbor]가 문제 조건에 맞거나 틀릴 시 추가 조건\n      if (!visited[neighbor]) {\n        //  answer++;, 혹은 문제 조건에 따라 bfs 내부에서 result를 모아 push할 수 도 있음.\n        visited[neighbor] = true; // 이 조건 언제 추가해야하지?\n        Q.enqueue(neighbor);\n      }\n    }\n  }\n  return answer;\n}\n\n// offset 사용하는 bfs. 주로 2차원 배열 그리드 문제에서 사용\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction bfsOffset(visited, graph, [startR, startC], answer) {\n  let Q = new Queue();\n  visited[startR][startC] = true;\n  Q.enqueue([startR, startC]);\n  while (!Q.isEmpty()) {\n    let [curR, curC] = Q.dequeue();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   문제 조건에 맞는 조건 추가. graph[nr][nc] === 1, 기타 등등..\n      ) {\n        visited[nr][nc] = true;\n        // answer에 값을 업데이트 해야한다면 answer++, ==, += 기타 등등 활용\n        Q.enqueue([nr, nc]);\n      }\n    }\n  }\n  return answer;\n}\n```","site/content/algorithms/bfs/core.mdx","53b5925ee1b65598","backtracking/pr1-1n",{"id":53,"data":55,"body":60,"filePath":61,"digest":62,"deferredRender":25},{"title":56,"description":57,"createdAt":45,"path":58,"tags":59},"Pr1 1+N","중단점: 총합이 10이면 결과에 추가",[26,35],{"pattern":35,"category":35},"> 📌 **Source Code:** [backtracking/pr1-1+N.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/backtracking/pr1-1+N.js)\n\n```js\nfunction backtrack(총합, 선택된수, 시작수, 전체수, 결과) {\n  // 중단점: 총합이 10이면 결과에 추가\n  if (총합 === 10) {\n    결과.push(선택된수);\n    return;\n  }\n\n  for (let i = 시작수; i \u003C= 전체수; i++) {\n    if (총합 + i \u003C= 10) {\n      // 총합이 10을 넘지 않는 경우에만 다음 단계로 이동\n      backtrack(총합 + i, 선택된수.concat(i), i + 1, 전체수, 결과);\n    }\n  }\n}\n\nfunction solution(n) {\n  let result = [];\n  backtrack(0, [], 1, n, result);\n  return result;\n}\n\n// 테스트 실행\nconsole.log(\"result : \", solution(5));\n```","site/content/algorithms/backtracking/pr1-1+N.mdx","376fbd0b67456ce8","bfs/prg1-gamemap",{"id":63,"data":65,"body":72,"filePath":73,"digest":74,"deferredRender":25},{"title":66,"description":67,"createdAt":45,"path":68,"tags":70},"Gamemap","Prg1 Gamemap",[26,69],"graph",{"pattern":69,"category":69,"platform":71},"programmers","> 📌 **Source Code:** [graph/prg1-gamemap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/bfs/prg1-gamemap.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(map, start, target) {\n  let rows = map.length;\n  let cols = map[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [tR, tC] = target;\n  const Q = new Queue();\n  const direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  Q.push([start, 0]);\n\n  while (!Q.isEmpty()) {\n    const [[prevR, prevC], dist] = Q.pop();\n\n    if (prevR == tR && prevC == tC) {\n      return dist;\n    }\n\n    for (let [r, c] of direction) {\n      let nextR = prevR + r;\n      let nextC = prevC + c;\n      if (\n        nextR \u003C rows &&\n        nextC \u003C cols &&\n        nextR >= 0 &&\n        nextC >= 0 &&\n        map[nextR][nextC] != 0 &&\n        !visited[nextR][nextC]\n      ) {\n        visited[nextR][nextC] = true;\n        Q.push([[nextR, nextC], dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let start = [0, 0];\n  let target = [maps.length - 1, maps[0].length - 1];\n\n  let dist = bfs(maps, start, target);\n\n  return dist;\n}\n\nconsole.log(\n  \"result : \",\n  solution([\n    [1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 1],\n  ]),\n);\n```","site/content/algorithms/bfs/prg1-gamemap.mdx","811cf39c217ace53","dfs/core",{"id":75,"data":77,"body":82,"filePath":83,"digest":84,"deferredRender":25},{"title":78,"description":79,"createdAt":45,"path":80,"tags":81},"Dfs","재귀 함수 사용하는 dfs",[26,47],{"pattern":49,"category":47},"> 📌 **Source Code:** [core/dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/dfs/core.js)\n\n```js\n// 재귀 함수 사용하는 dfs\nfunction recursiveDfs(start, graph, visited, answer) {\n  // 재귀 호출 시 방문 여부 업데이트 위치 주의\n  visited[start] = true; // 1,2차원 배열에 따라 다름\n  // 문제가 요구하는 반환값이 무엇인지에 따라 반환값, 함수 인자, 업데이트 조건 등이 달라진다.\n  // answer이 숫자라면 특정 숫자 이하일 때 dfs 재귀 호출을 백트래킹할 수 있다.\n\n  // 재귀 함수 스택에 들어가기 전에 조건문을 추가하여 return 할 수도 있다.\n  // 이 때 중단되는 것은 더이상 아래 노드들이 조건에 부합하지 않는 경우 이다.\n  while (!visited[start] && !!graph[start] && graph[start].length > 0) {\n    // 이 조건에서 !graph[start]와 graph[start].length \u003C 0 은 최하위 노드가 된다\n    // 그래프가 start는 객체 키(부모 노드 이름)나 배열(부모 노드의 인덱스)가 될 수 있다.\n    for (let neighbor of graph[start]) {\n      dfs(neighbor, graph, visited, answer);\n    }\n  }\n  // 반복문 외부에서 answer.push(neighbor)하여 노드를 저장할 수 있다.\n  // 만약 배열을 반환한다면, stack에서 역순으로 쌓이기 때문에 .reverse()하여 반환해야\n  // 루트 노드부터 차례대로 반환할 수 있다.\n  return;\n}\n\n// 함수 내부에 stack을 만들어 사용하는 dfs\nfunction stackDfs(start, graph, visited, answer) {\n  let stack = [start];\n  // 초기 시작점 start를 스택에 미리 추가하고, 방문 여부에 체크한다\n  visited[start] = true; // 1,2차원 배열에 따라 다름\n  //\n  let result = [];\n  while (stack.length > 0) {\n    let current = stack.pop();\n\n    for (let neighbor of graph[current]) {\n      // 방문 여부 + graph[neighbor]가 문제 조건에 맞거나 틀릴 시 추가 조건\n      if (\n        !visited[neighbor]\n        // && 문제에 맞는 조건 추가 가능 graph[neighbor] ===, >, \u003C {X} 등.\n      ) {\n        //  answer++;\n        visited[neighbor] = true; // 조건 추가 타이밍을 정리하고 싶다\n        stack.push(neighbor);\n      }\n    }\n    // result.push(current) -\n    // 이 위치에서 push하면 최하위 노드부터 쌓임\n    // = 역순으로 쌓이게 되서 마지막에 reverse()해주어야 한다.\n    // 하지만 가장 깔끔한 방식일 수 있다.\n    // for문 위에서 하면 자식노드보다 부모 노드의 정보가 먼저 쌓이는데,\n    // 결과가 정확해지지 않는다. 왜인지는 잘 기억 안남. -> 이제 알음\n  }\n  return; // answer;\n}\n\n// offset 사용하는 dfs. 주로 2차원 배열 그리드 문제에서 사용\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction dfsOffset(visited, graph, [startR, startC], answer) {\n  let stack = [[startR, startC]];\n  visited[startR][startC] = true;\n  let result = [];\n\n  while (stack.length > 0) {\n    let [curR, curC] = stack.pop();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   문제 조건에 맞는 조건 추가. graph[nr][nc] === 1, 기타 등등..\n      ) {\n        visited[nr][nc] = true;\n        // answer에 값을 업데이트 해야한다면 answer++, ==, += 기타 등등 활용\n        stack.push([nr, nc]);\n      }\n    }\n    // curR, curC를 모아야 한다면, result에 push 해준다.\n    result.push([curR, curC]);\n    // 제일 첫 startR,C가 result에 푸시되고\n    // 그 다음 stack의 가장 위에 있는 최하위 노드가 실행됨\n  }\n\n  return answer;\n}\n```","site/content/algorithms/dfs/core.mdx","0e7e49a355a1e2d5","dfs/prg2-network-dfs",{"id":85,"data":87,"body":92,"filePath":93,"digest":94,"deferredRender":25},{"title":88,"description":89,"createdAt":45,"path":90,"tags":91},"Network Dfs","Prg2 Network Dfs",[26,69],{"pattern":69,"category":69,"platform":71},"> 📌 **Source Code:** [graph/prg2-network-dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/dfs/prg2-network-dfs.js)\n\n```js\nfunction dfs(computers, visited, node) {\n  visited[node] = true;\n\n  for (let idx = 0; idx \u003C computers.length; idx++) {\n    if (computers[node][idx] && !visited[idx]) {\n      dfs(computers, visited, idx);\n    }\n  }\n}\n\nfunction solution(n, computers) {\n  let visited = Array(n).fill(false);\n  let answer = 0;\n\n  for (let i = 0; i \u003C n; i++) {\n    if (!visited[i]) {\n      dfs(computers, visited, i);\n      answer++;\n    }\n  }\n\n  return answer;\n}\n\nconsole.log(\"result : \", solution());\n```","site/content/algorithms/dfs/prg2-network-dfs.mdx","aefd8787725e34d2","dfs/leetcode-94-binary-tree-inorder-traverse",{"id":95,"data":97,"body":105,"filePath":106,"digest":107,"deferredRender":25},{"title":98,"description":99,"createdAt":16,"path":100,"tags":103},"LeetCode 94. Binary Tree Inorder Traversal","LeetCode problem 94",[26,34,101,102],"tree","traversal",{"pattern":104,"category":34},"tree-traversal","# Topics\n\n- Stack\n- Tree\n- Depth-First Search\n- Binary Tree\n\n# 문제 포인트\n\n[문제 링크](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length \u003C 2) return s; // 한 글자면 그대로 반환\n\n  let start = 0,\n    maxLength = 1;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right \u003C s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return [left + 1, right - 1]; // 팰린드롬의 시작과 끝 인덱스 반환\n  }\n\n  for (let i = 0; i \u003C s.length; i++) {\n    // 홀수 길이 팰린드롬\n    let [l1, r1] = expandAroundCenter(i, i);\n    // 짝수 길이 팰린드롬\n    let [l2, r2] = expandAroundCenter(i, i + 1);\n\n    if (r1 - l1 + 1 > maxLength) {\n      start = l1;\n      maxLength = r1 - l1 + 1;\n    }\n    if (r2 - l2 + 1 > maxLength) {\n      start = l2;\n      maxLength = r2 - l2 + 1;\n    }\n  }\n\n  return s.slice(start, start + maxLength);\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. visited가 불필요한데 사용했음\n2. param으로 들어오는 root의 값처리를 제대로 못함\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  let output = [];\n  let visited = new Set();\n  function dfs(root, cur) {\n    if (visited.has(cur) || !root?.val) return;\n    visited.add(cur);\n    output.push(root.val);\n\n    // 인접 노드 방문 중위 순회는 왼 -> 루트 -> 오\n    dfs(root, root?.left);\n    dfs(root, root?.right);\n  }\n  dfs(root, root?.val);\n  return output;\n};\n```","site/content/algorithms/dfs/leetcode-94-binary-tree-inorder-traverse.mdx","b8d5e6280687add2","dynamic-programming/leetcode-5-longest-palindromic-substring",{"id":108,"data":110,"body":116,"filePath":117,"digest":118,"deferredRender":25},{"title":111,"description":112,"createdAt":16,"path":113,"tags":115},"LeetCode 5. Longest Palindromic Substring","LeetCode problem 5",[26,34,114],"dynamic-programming",{"pattern":114,"category":34},"# Topics\n\n- String\n- Two Pointers\n- Dynamic Programming\n\n# 문제 포인트\n\n[문제 링크](https://leetcode.com/problems/longest-palindromic-substring/)\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // 중복 문자가 존재하면 앞에서 제거하면서 윈도우 이동\n    /**@note 이 부분에서 s[start]로 start를 움직이고, set에서 제거함\n     * @note Sliding Window의 가변 크기가 구현됨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // 새로운 문자 추가\n    /** @note 업데이트 시점은 set의 변경 이후에 실행함 **/\n    longest = Math.max(longest, end - start + 1); // 길이 갱신\n  }\n\n  return longest;\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 성능 최적화. reverse로 비교하는 비용이 너무 크다\n2. 예외처리: 한글자, 같은 두글자일때 등. 좀 더 추상적인 로직으로 개별 예외처리 안할 수도 있을텐데.\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length === 1) return s;\n  let longest = 0,\n    start = 0,\n    n = s.length,\n    result = \"\";\n  while (start \u003C n - 1) {\n    for (let end = start + 1; end \u003C n; end++) {\n      let slice = s.slice(start, end + 1); // + 1 ?\n      let reverse = slice.split(\"\").reverse().join(\"\");\n      if (slice === reverse && slice.length >= longest) {\n        result = slice;\n        longest = slice.length;\n      }\n    }\n    start++;\n  }\n\n  return result || s[0];\n};\n```","site/content/algorithms/dynamic-programming/leetcode-5-longest-palindromic-substring.mdx","f39ade1f2a0da135","dfs/leetcode-130-surrounded-regions",{"id":119,"data":121,"body":128,"filePath":129,"digest":130,"deferredRender":25},{"title":122,"description":123,"createdAt":16,"path":124,"tags":126},"LeetCode 130. Surrounded Regions","LeetCode problem 130",[26,34,125],"leetcode-130-surrounded-regions",{"pattern":127,"category":34},"DFS","# Topics\n\n- Array\n- Depth-First Search\n- Breadth-First Search\n- Union Find\n- Matrix\n\n# 문제\n\n[링크](https://leetcode.com/problems/surrounded-regions)\n\n## 정답\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  if (!board.length || !board[0].length) return;\n\n  let rSize = board.length,\n    cSize = board[0].length;\n  let directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // 가장자리에 연결된 'O'를 찾고 'S'로 변경 (보존 처리)\n  function dfs(r, c) {\n    if (r \u003C 0 || c \u003C 0 || r >= rSize || c >= cSize || board[r][c] !== \"O\") {\n      return;\n    }\n    board[r][c] = \"S\"; // 가장자리에 연결된 'O'는 보존\n    for (let [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  }\n\n  // 1. 가장자리에서 DFS 탐색하여 'O' → 'S' 변경 (보존)\n  for (let r = 0; r \u003C rSize; r++) {\n    dfs(r, 0);\n    dfs(r, cSize - 1);\n  }\n\n  for (let c = 0; c \u003C cSize; c++) {\n    dfs(0, c);\n    dfs(rSize - 1, c);\n  }\n\n  // 2. 보드를 업데이트\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (board[r][c] === \"O\") {\n        board[r][c] = \"X\"; // 감싸진 'O' → 'X'\n      } else if (board[r][c] === \"S\") {\n        board[r][c] = \"O\"; // 보존된 'S' → 원래대로 'O'\n      }\n    }\n  }\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. DFS 방문 로직 오류 (dfs 내부 조건 오류)\n\n- if (visited[r][c]) return false → 이미 방문한 곳을 다시 방문하지 않도록 하는 것은 맞지만, dfs가 참/거짓을 반환해야 하는 이유가 불분명함.\n- isChange = dfs([nr, nc]) 부분에서 true를 반환하면 board[r][c] = \"X\"로 변경하는데, 모든 경로를 탐색한 후 변환 여부를 결정해야 함.\n- 즉, 인접한 모든 'O'를 방문한 후 변경 여부를 판단해야 함.\n\n2. 경계 조건 처리 오류 (isCurrentEdge 활용 문제)\n\n- isCurrentEdge가 true면 즉시 false를 반환하는 것은 틀림.\n- 가장자리에 있는 'O'를 발견하면 해당 영역 전체를 보존해야 함.\n- false를 반환해도 인접 노드가 영향을 받지 않음 → 가장자리에 연결된 모든 'O'를 변경하지 않도록 표기하는 것이 핵심.\n\n3. 보드 업데이트 타이밍 문제 (board[r][c] = \"X\")\n\n- DFS 도중 바로 \"X\"로 변환하면 안 됨.\n- 탐색 중인 'O'가 실제로 감싸져 있는지 확정되지 않은 상태에서 변경되면 오답 가능성 증가.\n- 모든 DFS가 완료된 후, 감싸진 'O'를 'X'로 변환해야 함.\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  let rSize = board.length,\n    cSize = board[0].length;\n  let visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  let offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // dfs t/f 반환. t면 X로 바꾼다, f면 바꾸지 않는다.\n  function dfs([r, c]) {\n    if (visited[r][c]) return false;\n    visited[r][c] = true;\n\n    const isCurrentEdge =\n      r === 0 || c === 0 || r === rSize - 1 || c === cSize - 1;\n\n    // 인접이 X인 경우, 연결된 모든 O가 X라면 바꿔야함\n    if (board[r][c] === \"X\") return true;\n    // 또는 O가 가장 자리에 있다면 X로 바꿀 수 없음\n    if (board[r][c] === \"O\" && isCurrentEdge) return false;\n\n    // 현재 노드 = \"O\" 인접 노드에 따라 자기 자신이 바뀜\n    // 1. 인접 노드를 모두 방문하고,\n    // 2. 자기 자신의 바꾸는 여지를 정함.\n\n    // 인접 노드 방문 전에 현재 O를 X로 바꾸는 로직이 필요하다\n    // O\n\n    /**\n        목적: dfs가 tf를 반환하여 인접 노드 방문한 결과값이 t/f를 반환하게 한다.\n        조건:\n        - 모든 인접이 X이면? 현재 노드를 X로 바꾼다\n        - 모든 인접이 X가 아니면? O인 노드로 이동한다\n        - 현재 노드의 r, c가 0이나 r,cSize-1이면? 변환하지 않는다 - 위에서 false 변환\n         **/\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [r + or, c + oc];\n      let isChange = false;\n      if (nr >= 0 && nc >= 0 && nr \u003C rSize && c \u003C cSize && !visited[nr][nc]) {\n        isChange = dfs([nr, nc]);\n        if (isChange) {\n          board[r][c] = \"X\";\n        }\n      }\n    }\n    return isCurrentEdge;\n  }\n  // board 자체를 dfs 내부에서 변환한 뒤 리턴.\n  return board;\n};\n```","site/content/algorithms/dfs/leetcode-130-surrounded-regions.mdx","ee88843912b36720","backtracking/prg3-arrow",{"id":131,"data":133,"body":138,"filePath":139,"digest":140,"deferredRender":25},{"title":134,"description":135,"createdAt":45,"path":136,"tags":137},"Arrow","비교를 위해 알아야 하는 거",[26,35],{"pattern":35,"category":35,"platform":71},"> 📌 **Source Code:** [backtracking/prg3-arrow.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/backtracking/prg3-arrow.js)\n\n```js\n// 비교를 위해 알아야 하는 거\n// 1. info의 총합\n// 2. info에서 각 점수 10~0점 몇개 맞췄는지\n// n발 이내에서 1을 넘을 수 있는지 알아야함\n// backtrack을 통해 내가 얻을 수 있는 점수를 계산함\n// 1초과 하기 위해 n을 어떻게 배분해야하는지 알아야함\n// n발 이내에 1을 넘을 수 있나\n// n발 이내에 1dml\n\n// info에서 최고 점수 구하는 함수\nfunction getTotal(info) {\n  let result = 0;\n  for (let i = 0; i \u003C= info.length - 1; i++) {\n    result += (10 - i) * info[i];\n  }\n  return result;\n}\n\nfunction backtrack(n, info, total) {\n  let remain = n;\n  let myTotal = 0;\n  let result = [];\n  // remain이 1일때까지 반복\n\n  for (let i = 0; i \u003C 10; i++) {\n    let myShot = info[i] + 1;\n    let myScore = 10 - i;\n    // 언제 추가하지?\n    // 적당히 배분되어야함.\n    if (remain \u003C= 0 || total \u003C myTotal) {\n      return result;\n    }\n    console.log(\n      \"inner for remain : \",\n      remain,\n      \"\\n\",\n      \"myShot : \",\n      myShot,\n      \"\\n\",\n      \"myScore : \",\n      myScore,\n      \"\\n\",\n      \"myTotal : \",\n      myTotal,\n    );\n    if (myTotal + myScore \u003C total) {\n      result.push(myShot);\n      myTotal += myScore;\n      remain = remain - myShot;\n    }\n  }\n\n  return [-1];\n}\n\nfunction solution(n, info) {\n  let infoTotal = getTotal(info);\n  let result = backtrack(n, info, infoTotal);\n\n  return result;\n}\n\n// 테스트 실행\nconsole.log(\"result : \", solution(5, [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]));\n```","site/content/algorithms/backtracking/prg3-arrow.mdx","7353993a0c3b9e28","search/leetcode-3-longest-substring",{"id":141,"data":143,"body":149,"filePath":150,"digest":151,"deferredRender":25},{"title":144,"description":145,"createdAt":16,"path":146,"tags":148},"LeetCode 3. Longest Substring Without Repeating Characters","LeetCode problem",[26,34,147],"sliding-window",{"pattern":147,"category":34},"# Topics\n\n- Hash Table\n- String\n- Sliding Window\n\n## 문제 포인트\n\n[문제 링크](https://leetcode.com/problems/surrounded-regions)\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // 중복 문자가 존재하면 앞에서 제거하면서 윈도우 이동\n    /**@note 이 부분에서 s[start]로 start를 움직이고, set에서 제거함\n     * @note Sliding Window의 가변 크기가 구현됨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // 새로운 문자 추가\n    /** @note 업데이트 시점은 set의 변경 이후에 실행함 **/\n    longest = Math.max(longest, end - start + 1); // 길이 갱신\n  }\n\n  return longest;\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 새로운 연결 리스트 생성 오류\n\nreturnList를 리스트로 변환하려 했으나 next 추가 방식이 틀림.\n올바른 방식은 새로운 ListNode를 생성하고 current.next로 연결해야 함.\n반복문에서 next 추가 방법 문제\n\nreturnList(start, next)는 올바르지 않음.\ndummyHead 노드를 두고 current 포인터를 활용하여 next로 연결해야 함.\n\n2. 리스트 숫자 변환 오류 (getAllNum 함수)\n\n```\nwhile (li?.val) → while (li !== null)\nnums.unshift(li.val) 대신 nums.push(li.val)\njoin(\"\") * 1 대신 Number(join(\"\")) 또는 BigInt(join(\"\")) 사용해야 큰 숫자 처리 가능.\n\n```\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = -1;\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n    if (!set.has(char)) {\n      set.add(char);\n    } else {\n      longest = Math.max(longest, end - start + 1);\n      start++;\n      // set 초기화? 업데이트? 어떻게 해야하지.\n    }\n  }\n\n  return longest;\n};\n```","site/content/algorithms/search/leetcode-3-longest-substring.mdx","3698cc47d28aa050","search/leetcode-4-median-of-two-sorted-array",{"id":152,"data":154,"body":160,"filePath":161,"digest":162,"deferredRender":25},{"title":155,"description":156,"createdAt":16,"path":157,"tags":159},"LeetCode 4. Median of Two Sorted Arrays","LeetCode problem 4",[26,34,158],"binary-search",{"pattern":158,"category":34},"# Topics\n\n- Array\n- Binary Search\n- Divide and Conquer\n\n# 문제 포인트\n\n[문제 링크](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n사실 이진 탐색으로 풀어야하는 문제인데,\n\n## 정답\n\n```js\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  let merged = [...nums1, ...nums2].sort((a, b) => a - b);\n  let size = merged.length,\n    isEven = size % 2 === 0;\n  let pointer = isEven ? Math.floor(size / 2) - 1 : Math.floor(size / 2);\n\n  if (isEven) {\n    return (merged[pointer] + merged[pointer + 1]) / 2;\n  } else {\n    return merged[pointer];\n  }\n};\n```\n\n## 사고 과정\n\n처음에 set으로 시도하려 했으나, 테스트 케이스 44번에 중복 숫자 허용이 껴있어서 수정함.\n\n1. Median 정의\n   - 숫자 총합의 중간 값인지, 말 그대로 배열의 가장 중앙을 뜻하는 지 확인. 후자.\n   - 병합된 두 배열의 길이가 홀수 일 때는 Math.floor(length / 2)의 인덱스 값\n   - 짝수일 때는 Math.floor(length / 2)와 +1의 요소를 더한 뒤 / 2\n2. 두 배열을 합한 뒤 sort = merged - 중간 값의 탐색 대상\n3. 1번에서 중간 값이 배열 길이에 따라 달라짐을 확인함. 그대로 반환값 계산함\n\n- 중복 요소 허용, 비허용에 대한 힌트가 없어 테스트 케이스에서 찾아냄.","site/content/algorithms/search/leetcode-4-median-of-two-sorted-array.mdx","11bb72a9a98eb9b3","queue/core",{"id":163,"data":165,"body":169,"filePath":170,"digest":171,"deferredRender":25},{"title":166,"description":166,"createdAt":45,"path":167,"tags":168},"Queue",[26,47],{"pattern":49,"category":47},"> 📌 **Source Code:** [queue/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/queue/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const head = this.items[this.front];\n    delete this.items[this.front];\n    this.front++;\n    return head;\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n```","site/content/algorithms/queue/core.mdx","44f75e26afbc71bf","search/leetcode-add-two-numbers",{"id":172,"data":174,"body":180,"filePath":181,"digest":182,"deferredRender":25},{"title":175,"description":145,"createdAt":16,"path":176,"tags":179},"Linked List - LeetCode 2. Add Two Numbers",[26,34,177,178],"linked-list","two-pointer",{"pattern":178,"category":34},"[문제 링크](https://leetcode.com/problems/add-two-numbers/)\n\n# Topics\n\n- Linked List\n- Math\n- Recursion\n\n# 문제 포인트\n\n1. 연결 리스트의 현재, 다음 포인터 연결\n2. **반복문**에서 다음 포인터 연결 로직\n\n- `count[i]`랑 현재 탐색 노드(`board[r][c]`)가 일치하지 않을 때 탐색 중단\n\n3. 방문 업데이트 시점의 중요성 (경로 탐색의 경우, 인접 노드 모두 방문한 이후)\n\n## 정답\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n  let carry = 0;\n\n  while (l1 !== null || l2 !== null || carry > 0) {\n    let sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10); // 10을 넘으면 올림값 저장\n\n    current.next = new ListNode(sum % 10); // 현재 노드 추가\n    current = current.next; // 포인터 이동\n\n    l1 = l1?.next || null;\n    l2 = l2?.next || null;\n  }\n\n  return dummyHead.next; // 실제 리스트 시작점 반환\n};\n```\n\n## 오답 사고 과정\n\n### 접근 문제점\n\n1. 새로운 연결 리스트 생성 오류\n\nreturnList를 리스트로 변환하려 했으나 next 추가 방식이 틀림.\n올바른 방식은 새로운 ListNode를 생성하고 current.next로 연결해야 함.\n반복문에서 next 추가 방법 문제\n\nreturnList(start, next)는 올바르지 않음.\ndummyHead 노드를 두고 current 포인터를 활용하여 next로 연결해야 함.\n\n2. 리스트 숫자 변환 오류 (getAllNum 함수)\n\n```\nwhile (li?.val) → while (li !== null)\nnums.unshift(li.val) 대신 nums.push(li.val)\njoin(\"\") * 1 대신 Number(join(\"\")) 또는 BigInt(join(\"\")) 사용해야 큰 숫자 처리 가능.\n\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  // 두 리스트에서 합을 구함\n  function getAllNum(list) {\n    let nums = [];\n    let li = list;\n    while (li?.val) {\n      nums.unshift(li.val);\n      li = li.next;\n    }\n    return nums.join(\"\") * 1;\n  }\n\n  let sum = getAllNum(l1) + getAllNum(l2);\n  let result = String(sum)\n    .split(\"\")\n    .map((char) => char * 1);\n\n  console.log(result);\n  const returnList = new ListNode();\n\n  // 반복문에서 지금 링크 리스트에 추가, next를 어떻게 추가해야 할 지 모르겠음\n  while (result.length > 0) {\n    const start = result.pop();\n    returnList(start, next);\n  }\n};\n```","site/content/algorithms/search/leetcode-add-two-numbers.mdx","0692aaeb8def1589","heap/min-heap",{"id":183,"data":185,"body":191,"filePath":192,"digest":193,"deferredRender":25},{"title":186,"description":187,"createdAt":45,"path":188,"tags":190},"Min Heap","size 0 시 null 반환",[26,189],"heap",{"pattern":189,"category":189},"> 📌 **Source Code:** [heap/min-heap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/heap/min-heap.js)\n\n```js\nclass MinHeap {\n  constructor() {\n    this.items = [];\n  }\n\n  size() {\n    return this.items.length;\n  }\n  swap(a, b) {\n    [this.items[a], this.items[b]] = [this.items[b], this.items[a]];\n  }\n  pop() {\n    // size 0 시 null 반환\n    if (this.size() \u003C= 0) {\n      return null;\n    }\n\n    // min이었던 head의 값만 저장함\n    const min = this.items[0];\n    // 새로운 헤드로 꼬리에 있던 값을 넣음\n    this.items[0] = this.items[this.size() - 1];\n    // 그다음 0 인덱스 위에서부터 내려가면서 정렬함.\n    this.bubbleDown();\n\n    // 저장해둔 큐 헤드를 반환\n    return min;\n  }\n  bubbleDown() {\n    // 위에서부터 내려감\n    let index = 0;\n\n    // index * 2 + 1 현재 인덱스 * 2에 왜 + 1일까?\n    // 부모 노드에서 오른쪽 노드가 가장 큰 숫자를 더해짐 \u003C 마지막 노드 인덱스랑 비교해서 더 작을 때까지\n    while (index * 2 + 1 \u003C this.size() - 1) {\n      let leftIndex = index * 2 + 1;\n      let rightIndex = index * 2 + 2;\n      let smallerIndex =\n        // right index가 left보다 항상 크니까 (+2), 마지막 인덱스보다 작아야함\n        rightIndex \u003C this.size() - 1 &&\n        // 여기서 더 작은 쪽의 비교 대상 적용됨\n        // 양 옆 자식 중에 더 작은 쪽이랑 부모를 비교해야함.\n        // 언제나 같거나 작아도 되나?\n        this.items[rightIndex] \u003C= this.items[leftIndex]\n          ? rightIndex\n          : leftIndex;\n      // 아래가 중단점\n      if (this.items[index] \u003C= this.tems[smallerIndex]) {\n        break;\n      }\n\n      // 현재 인덱스의 값이 자식의 더 작은쪽보다 더 큰 경우\n      // 스왑 + 로컬 index를 자식으로 변경\n      this.swap(index, smallerIndex);\n      index = smallerIndex;\n    }\n  }\n  push(data) {\n    this.items.push(data);\n    // 배열(스택)에 데이터 넣고\n    this.bubbleUp();\n    // 바닥부터 정렬 시작\n  }\n  bubbleUp() {\n    let index = this.size() - 1;\n    // 로컬 인덱스. 작업의 시작점. 이게 바뀌어야 반복문이 멈춤\n    // 바닥부터 시작해서 index 0 이상일 때까지\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n\n      // Min의 bubbleUp 조건 중단점.\n      // 부모 노드가 같거나 더 작을 때 멈춤\n      if (this.items[parentIndex] \u003C= this.items[index]) {\n        break;\n      }\n      // 부모 노드가 더 큰 경우 바꿔야함, items의 인덱스, 부모 인덱스의 값을 바꿈\n      this.swap(index, parentIndex);\n      // 로컬 인덱스를 부모로 바꿈 (tail - 1 / 2)\n      index = parentIndex;\n    }\n  }\n}\n```","site/content/algorithms/heap/min-heap.mdx","0e88322b57052951","hash/prg1-race",{"id":194,"data":196,"body":203,"filePath":204,"digest":205,"deferredRender":25},{"title":197,"description":198,"createdAt":199,"path":200,"tags":202},"Race","programmers 달리기 문제","2025-01",[26,201],"hash",{"pattern":201,"category":201,"platform":71},"- 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\n- 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때,\n- 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n\n- 제한사항\n- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\n- completion의 길이는 participant의 길이보다 1 작습니다.\n- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\n- 참가자 중에는 동명이인이 있을 수 있습니다.\n\n- 입출력 예\n\n|participant | completion | return |\n| [\"leo\", \"kiki\", \"eden\"] | [\"eden\", \"kiki\"]| \"leo\" |\n| [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"] | [\"josipa\", \"filipa\", \"marina\", \"nikola\"] | \"vinko\" |\n| [\"mislav\", \"stanko\", \"mislav\", \"ana\"] | [\"stanko\", \"ana\", \"mislav\"] | \"mislav\" |\n\n- 입출력 예 설명\n  예제 #1\n  \"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n예제 #2\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n예제 #3\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\n\n> 📌 **Source Code:** [hash/prg1-race.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg1-race.js)\n\n```js\n/*\n*\n* 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\n* 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때,\n* 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n\n* 제한사항\n* 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\n* completion의 길이는 participant의 길이보다 1 작습니다.\n* 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\n* 참가자 중에는 동명이인이 있을 수 있습니다.\n\n* 입출력 예\nparticipant\tcompletion\treturn\n[\"leo\", \"kiki\", \"eden\"]\t[\"eden\", \"kiki\"]\t\"leo\"\n[\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"]\t[\"josipa\", \"filipa\", \"marina\", \"nikola\"]\t\"vinko\"\n[\"mislav\", \"stanko\", \"mislav\", \"ana\"]\t[\"stanko\", \"ana\", \"mislav\"]\t\"mislav\"\n\n* 입출력 예 설명\n예제 #1\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n예제 #2\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n예제 #3\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\n*\n* */\n\nfunction solution(participant, completion) {\n  let obj = {};\n  for (let p of participant) {\n    obj[p] = !!obj[p] ? obj[p] + 1 : 1;\n  }\n\n  for (let i = 0; i \u003C completion.length; i++) {\n    if (obj[completion[i]] === undefined) {\n      continue;\n    }\n    obj[completion[i]] = obj[completion[i]] - 1;\n  }\n  console.log(\"obj\", obj);\n\n  const entries = Object.entries(obj);\n  console.log(\"entries\", entries);\n  for ([name, complete] of entries) {\n    if (complete > 0) {\n      return name;\n    }\n  }\n}\n\nlet test1P = [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"];\nlet test1C = [\"josipa\", \"filipa\", \"marina\", \"nikola\"];\nlet test2P = [\"mislav\", \"stanko\", \"mislav\", \"ana\"];\nlet test2C = [\"stanko\", \"ana\", \"mislav\"];\n\nconsole.log(\"result : \", solution(test1P, test1C));\nconsole.log(\"result : \", solution(test2P, test2C));\n```","site/content/algorithms/hash/prg1-race.mdx","699490a2e57bd862","link-list/양방향-공문제",{"id":206,"data":208,"body":213,"filePath":214,"digest":215,"deferredRender":25},{"title":209,"description":209,"createdAt":45,"path":210,"tags":212},"양방향 공문제",[26,211],"link-list",{"pattern":211,"category":211},"> 📌 **Source Code:** [link-list/양방향-공문제.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/link-list/양방향-공문제.js)\n\n```js\nconst solution = (balls, orders) => {\n  let head = 0;\n  let tail = balls.length - 1;\n  let result = [];\n  let wait = new Set();\n  const next = 1;\n  const prev = -1;\n\n  for (let i = 0; i \u003C orders.length; i++) {\n    if (orders[i] === balls[head]) {\n      console.log(`head : ${balls[head]}`);\n      result.push(orders[i]);\n      head++;\n      while (wait.has(orders[i] + next)) {\n        result.push(orders[i] + next);\n        wait.delete(orders[i] + next);\n        head++;\n      }\n    } else if (orders[i] === balls[tail]) {\n      result.push(orders[i]);\n      if (wait.has(orders[i] + prev)) {\n        while (wait.has(orders[i] + prev)) {\n          result.push(orders[i] + prev);\n          wait.delete(orders[i] + prev);\n          tail--;\n        }\n      }\n      tail--;\n    } else {\n      wait.add(orders[i]);\n    }\n  }\n  return result;\n};\n\nconsole.log(\n  \"result : \",\n  solution([1, 2, 3, 4, 5, 6, 7], [7, 5, 6, 4, 2, 1, 3]),\n);\n```","site/content/algorithms/link-list/양방향-공문제.mdx","84c4fd90385db26a","hash/prg3-discount",{"id":216,"data":218,"body":223,"filePath":224,"digest":225,"deferredRender":25},{"title":219,"description":220,"createdAt":45,"path":221,"tags":222},"Discount","Prg3 Discount",[26,201],{"pattern":201,"category":201,"platform":71},"> 📌 **Source Code:** [hash/prg3-discount.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg3-discount.js)\n\n```js\nfunction solution(want, number, discount) {\n  const max = 10;\n  let result = 0;\n  let obj = {};\n\n  for (let i = 0; i \u003C want.length; i++) {\n    obj[want[i]] = !!obj[want[i]] ? obj[want[i]] + number[i] : number[i];\n  }\n\n  for (let i = 0; i \u003C discount.length; i++) {\n    let cart = { ...obj };\n    console.log(\"outer i\", i);\n    console.log(\"discount i\", discount[i]);\n    for (j = i; j \u003C max + i; j++) {\n      console.log(`\n      inner j : ${j}\n      ${discount[j]} :  ${cart[discount[j]]} left\n      `);\n\n      if (!cart[discount[j]]) {\n        continue;\n      }\n      cart[discount[j]] = cart[discount[j]] - 1;\n      console.log(`\n      inner j after\n      ${discount[j]} :  ${cart[discount[j]]}\n      cart: ${Object.entries(cart)}\n      `);\n    }\n    let cartResult = Object.values(cart);\n    let cartAllZero = cartResult.every((item) => item \u003C= 0);\n    console.log(`\n    ${i} index\n    ====================\n    cartResult : ${JSON.stringify(cartResult)} \n    cartAllZero : ${cartAllZero}\n    `);\n    if (cartAllZero) {\n      result++;\n    }\n  }\n\n  return result;\n}\n\nlet test1W = [\"banana\", \"apple\", \"rice\", \"pork\", \"pot\"];\nlet test1N = [3, 2, 2, 2, 1];\nlet test1D = [\n  \"chicken\",\n  \"apple\",\n  \"apple\",\n  \"banana\",\n  \"rice\",\n  \"apple\",\n  \"pork\",\n  \"banana\",\n  \"pork\",\n  \"rice\",\n  \"pot\",\n  \"banana\",\n  \"apple\",\n  \"banana\",\n];\n\nconsole.log(\"result : \", solution(test1W, test1N, test1D));\n```","site/content/algorithms/hash/prg3-discount.mdx","fec40944e54eb9ed","hash/prg6-bestmusic",{"id":226,"data":228,"body":233,"filePath":234,"digest":235,"deferredRender":25},{"title":229,"description":230,"createdAt":45,"path":231,"tags":232},"Best Music","베스트 앨범 문제",[26,201],{"pattern":201,"category":201,"platform":71},"## 문제\n\n스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다.\n노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.\n\n속한 노래가 많이 재생된 장르를 먼저 수록합니다.\n장르 내에서 많이 재생된 노래를 먼저 수록합니다.\n장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.\n노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때,\n베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.\n\n### 제한사항\n\ngenres[i]는 고유번호가 i인 노래의 장르입니다.\nplays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.\ngenres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.\n장르 종류는 100개 미만입니다.\n장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.\n모든 장르는 재생된 횟수가 다릅니다.\n\n> 📌 **Source Code:** [hash/prg6-bestmusic.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg6-bestmusic.js)\n\n```js\n/*\n문제 설명\n스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다.\n노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.\n\n속한 노래가 많이 재생된 장르를 먼저 수록합니다.\n장르 내에서 많이 재생된 노래를 먼저 수록합니다.\n장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.\n노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때,\n베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.\n\n제한사항\ngenres[i]는 고유번호가 i인 노래의 장르입니다.\nplays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.\ngenres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.\n장르 종류는 100개 미만입니다.\n장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.\n모든 장르는 재생된 횟수가 다릅니다.\n입출력 예\ngenres\tplays\treturn\n[\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"]\t[500, 600, 150, 800, 2500]\t[4, 1, 3, 0]\n입출력 예 설명\nclassic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다.\n\n고유 번호 3: 800회 재생\n고유 번호 0: 500회 재생\n고유 번호 2: 150회 재생\npop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다.\n\n고유 번호 4: 2,500회 재생\n고유 번호 1: 600회 재생\n따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.\n\n장르 별로 가장 많이 재생된 노래를 최대 두 개까지 모아 베스트 앨범을 출시하므로 2번 노래는 수록되지 않습니다.\n\n* */\n\nfunction solution(genres, plays) {\n  let totalObj = {};\n  let pObj = {};\n  let result = [];\n\n  for (let i = 0; i \u003C genres.length; i++) {\n    totalObj[genres[i]] = !!totalObj[genres[i]]\n      ? totalObj[genres[i]] + plays[i]\n      : plays[i];\n    pObj[genres[i]] = [...(pObj[genres[i]] ?? []), [i, plays[i]]];\n  }\n\n  let playEntries = Object.entries(pObj);\n  let totalEntries = Object.entries(totalObj).sort((a, b) => b[1] - a[1]);\n  let totalRank = totalEntries.map(([g]) => g);\n\n  for (let genre in pObj) {\n    pObj[genre] = pObj[genre]\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 2)\n      .map(([name]) => name);\n  }\n\n  console.log(`pObj: ${Object.entries(pObj)}`);\n\n  console.log(\"totalEntries\", totalEntries);\n  console.log(\"playEntries\", playEntries);\n\n  for (let i = 0; i \u003C totalRank.length; i++) {\n    let songsIndex = pObj[totalRank[i]];\n    console.log(\"songsIndex\", songsIndex);\n    result.push(songsIndex);\n  }\n  return result.flat();\n}\n\nlet test1G = [\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"];\nlet test1P = [500, 600, 150, 800, 2500];\n\nconsole.log(\"result : \", solution(test1G, test1P));\n```","site/content/algorithms/hash/prg6-bestmusic.mdx","76f1f1541aa06c0f","hash/prg7-report",{"id":236,"data":238,"body":243,"filePath":244,"digest":245,"deferredRender":25},{"title":239,"description":240,"createdAt":45,"path":241,"tags":242},"Report","Prg7 Report",[26,201],{"pattern":201,"category":201,"platform":71},"> 📌 **Source Code:** [hash/prg7-report.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg7-report.js)\n\n```js\nfunction solution(id_list, report, k) {\n  let reported = {};\n  let reporter = {};\n  let count = {};\n\n  for (let id of id_list) {\n    reported[id] = 0;\n    reporter[id] = [];\n    count[id] = 0;\n  }\n\n  const reportArr = [...new Set(report)].map((item) => item.split(\" \"));\n  for (const [rp, user] of reportArr) {\n    reported[user] += 1;\n    reporter[rp] = [...reporter[rp], user];\n    console.log(`\n    신고자 : ${rp} \n    위반자 : ${user} \n    신고당한 횟수 : ${reported[user]}`);\n  }\n\n  const bannedArr = Object.entries(reported).filter(([, count]) => count >= k);\n\n  for (const [bannedUser] of bannedArr) {\n    for (const rUser in reporter) {\n      console.log(\"bannedUser in 2 for\", bannedUser);\n      console.log(\"reporter in 2 for\", rUser);\n\n      if (reporter[rUser].includes(bannedUser)) {\n        count[rUser] += 1;\n      }\n    }\n  }\n  console.log(\"reported\", reported);\n  console.log(\"reporter\", reporter);\n  console.log(\"bannedArr\", bannedArr);\n  console.log(\"count\", count);\n\n  let result = Object.values(count);\n  return result;\n}\n\nlet id_list1 = [\"muzi\", \"frodo\", \"apeach\", \"neo\"];\nlet report1 = [\n  \"muzi frodo\",\n  \"apeach frodo\",\n  \"frodo neo\",\n  \"muzi neo\",\n  \"apeach muzi\",\n];\nlet k1 = 2;\n\nconsole.log(\"result : \", solution(id_list1, report1, k1));\n```","site/content/algorithms/hash/prg7-report.mdx","c2fa03e49a1440ac","hash/연습1-두수더하기",{"id":246,"data":248,"body":253,"filePath":254,"digest":255,"deferredRender":25},{"title":249,"description":250,"createdAt":45,"path":251,"tags":252},"연습1 두수더하기","* 문제: arr의 두 수를 더하여 target을 만들 수 있다면 true를 반환, 아니면 false를 반환 * arr은 최대 10^4 O(n) * *",[26,201],{"pattern":201,"category":201},"> 📌 **Source Code:** [hash/연습1-두수더하기.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/연습1-두수더하기.js)\n\n```js\n/*\n * 문제: arr의 두 수를 더하여 target을 만들 수 있다면 true를 반환, 아니면 false를 반환\n * arr은 최대 10^4 O(n)\n *\n * */\n\nfunction solution(arr, target) {\n  let k = new Set();\n  for (let i = 0; i \u003C arr.length; i++) {\n    k.add(target - arr[i]);\n  }\n\n  for (let i = 0; i \u003C arr.length; i++) {\n    let comple = target - arr[i];\n    if (k.has(arr[i]) && comple > 0 && comple !== arr[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconsole.log(\"result\", solution([1, 2, 3, 4, 8], 6));\nconsole.log(\"result\", solution([2, 3, 5, 9], 10));\n```","site/content/algorithms/hash/연습1-두수더하기.mdx","b17236be9485cfec","set/prg3-phone_book",{"id":256,"data":258,"body":264,"filePath":265,"digest":266,"deferredRender":25},{"title":259,"description":260,"createdAt":45,"path":261,"tags":263},"Phone Book","Prg3 Phone Book",[26,262],"set",{"pattern":262,"category":262,"platform":71},"> 📌 **Source Code:** [set/prg3-phone_book.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg3-phone_book.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg3-phone_book.mdx","6bdd069a76da8a34","hash/연습2-문자열비교",{"id":267,"data":269,"body":274,"filePath":275,"digest":276,"deferredRender":25},{"title":270,"description":271,"createdAt":45,"path":272,"tags":273},"연습2 문자열비교","* 문제: queryList가 strList에 있다면 true를 반환, 아니면 false를 담아 배열로 반환 * arr은 최대 10^4 O(n) * *",[26,201],{"pattern":201,"category":201},"# 문제: queryList가 strList에 있다면 true를 반환, 아니면 false를 담아 배열로 반환\n\n- arr은 최대 10^4 O(n)\n\n> 📌 **Source Code:** [hash/연습2-문자열비교.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/연습2-문자열비교.js)\n\n```js\n/*\n * 문제: queryList가 strList에 있다면 true를 반환, 아니면 false를 담아 배열로 반환\n * arr은 최대 10^4 O(n)\n *\n * */\n\nfunction solution(strList, queryList) {\n  let result = [];\n  let strObj = new Set();\n\n  for (let i = 0; i \u003C strList.length; i++) {\n    strObj.add(strList[i]);\n  }\n\n  for (let i = 0; i \u003C queryList.length; i++) {\n    if (strObj.has(queryList[i])) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result;\n}\n\nlet test1SL = [\"apple\", \"banana\", \"cherry\"];\nlet test1QL = [\"banana\", \"kiwi\", \"melon\", \"apple\"];\nlet test2SL = [\"a\", \"b\", \"Q\"];\nlet test2QL = [\"c\", \"d\", \"e\", \"A\", \"a\", \"b\", \"Z\", \"Q\"];\n\nconsole.log(\"result\", solution(test1SL, test1QL));\nconsole.log(\"result\", solution(test2SL, test2QL));\n```","site/content/algorithms/hash/연습2-문자열비교.mdx","b851ea55417dcd6b","set/prg1-pokemon",{"id":277,"data":279,"body":284,"filePath":285,"digest":286,"deferredRender":25},{"title":280,"description":281,"createdAt":45,"path":282,"tags":283},"Pokemon","Prg1 Pokemon",[26,262],{"pattern":262,"category":262,"platform":71},"> 📌 **Source Code:** [set/prg1-pokemon.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg1-pokemon.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg1-pokemon.mdx","e759c6306529263e","set/prg4-students",{"id":287,"data":289,"body":294,"filePath":295,"digest":296,"deferredRender":25},{"title":290,"description":291,"createdAt":45,"path":292,"tags":293},"Students","여벌 나눔 계산",[26,262],{"pattern":262,"category":262,"platform":71},"> 📌 **Source Code:** [set/prg4-students.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg4-students.js)\n\n```js\nfunction solution(n, lost, reserve) {\n  let students = {};\n  for (let i = 1; i \u003C= n; i++) {\n    students[i] = 1;\n  }\n\n  for (let r = 0; r \u003C reserve.length; r++) {\n    let num = reserve[r];\n    students[num] += 1;\n  }\n\n  for (let l = 0; l \u003C lost.length; l++) {\n    let num = lost[l];\n    students[num] -= 1;\n  }\n\n  // 여벌 나눔 계산\n  // lost 빼고 나서 나머지 학생들 중 0인 학생만 찾아서\n  // 앞 뒤로 1 이상일 시 공유함\n  for (let sKey in students) {\n    if (students[sKey] === 0) {\n      let next = Number(sKey) + 1;\n      let prev = Number(sKey) - 1;\n\n      if (prev > 0 && students[prev] > 1) {\n        students[prev] = students[prev] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n\n      if (next \u003C= n && students[next] > 1) {\n        students[next] = students[next] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n    }\n  }\n\n  const result = Object.values(students).filter((item) => item > 0);\n  return result.length;\n}\n\nconsole.log(\"result : \", solution(5, [2, 4], [1, 3, 5]));\nconsole.log(\"result : \", solution(5, [2, 4], [3]));\nconsole.log(\"result : \", solution(3, [3], [1]));\n```","site/content/algorithms/set/prg4-students.mdx","efa675834d961c8a","set/prg2-words",{"id":297,"data":299,"body":304,"filePath":305,"digest":306,"deferredRender":25},{"title":300,"description":301,"createdAt":45,"path":302,"tags":303},"Words","Prg2 Words",[26,262],{"pattern":262,"category":262,"platform":71},"> 📌 **Source Code:** [set/prg2-words.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg2-words.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg2-words.mdx","5b61aad4b9b63403","set/prg5-islands",{"id":307,"data":309,"body":314,"filePath":315,"digest":316,"deferredRender":25},{"title":310,"description":311,"createdAt":45,"path":312,"tags":313},"Islands","parent 배열에서 루트 노드를 찾는 함수",[26,262],{"pattern":262,"category":262,"platform":71},"> 📌 **Source Code:** [set/prg5-islands.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg5-islands.js)\n\n```js\n// parent 배열에서 루트 노드를 찾는 함수\n// 루트 노드란 집합의 대표자 (즉, 최상위 부모 노드)\n// 경로 압축을 통해 탐색 경로를 최적화\nfunction find(parents, x) {\n  // x가 자신의 부모 노드라면 (즉, 루트 노드라면)\n  if (parents[x] == x) {\n    return x; // 루트 노드 반환\n  }\n  // x가 루트가 아니면, 재귀 호출을 통해 루트를 찾음\n  // 찾으면서 부모를 루트로 갱신 (경로 압축)\n  parents[x] = find(parents, parents[x]);\n  return parents[x]; // 최종 루트 반환\n}\n\n// 두 노드의 집합을 합치는 함수 (Union by Rank)\n// Rank는 트리의 깊이를 의미하며, 더 낮은 트리를 높은 트리에 붙임\nfunction union(parent, rank, x, y) {\n  const xroot = find(parent, x); // x의 루트 노드 찾기\n  const yroot = find(parent, y); // y의 루트 노드 찾기\n\n  // Rank를 비교하여 트리의 균형 유지\n  if (rank[xroot] \u003C rank[yroot]) {\n    parent[xroot] = yroot; // xroot 트리를 yroot에 연결\n  } else if (rank[xroot] > rank[yroot]) {\n    parent[yroot] = xroot; // yroot 트리를 xroot에 연결\n  } else {\n    // 랭크가 같다면 xroot를 부모로 설정하고, 랭크를 1 증가\n    parent[yroot] = xroot;\n    rank[xroot] += 1;\n  }\n}\n\n// 최소 신장 트리 (MST) 비용 계산 함수\nfunction solution(n, costs) {\n  // 1. 간선 리스트를 비용 기준으로 오름차순 정렬\n  costs.sort((a, b) => a[2] - b[2]); // MST를 위해 가장 낮은 비용의 간선을 먼저 처리\n\n  // 2. parent 배열과 rank 배열 초기화\n  // 각 노드는 처음엔 자기 자신이 루트인 독립 집합\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0); // 모든 노드의 초기 Rank는 0\n\n  let minCost = 0; // MST의 총 비용\n  let edges = 0; // 현재까지 MST에 포함된 간선의 수\n\n  // 3. 간선 리스트를 하나씩 확인하며 MST를 구성\n  for (const edge of costs) {\n    if (edges == n - 1) {\n      // MST의 간선 수가 n-1이면 중단\n      break;\n    }\n    // edge = [노드1, 노드2, 비용]\n    const x = find(parent, edge[0]); // 노드1의 루트 노드 찾기\n    const y = find(parent, edge[1]); // 노드2의 루트 노드 찾기\n\n    if (x !== y) {\n      // 두 노드가 같은 집합에 속하지 않으면 연결\n      union(parent, rank, x, y); // 두 노드를 같은 집합으로 묶음\n      minCost += edge[2]; // 간선의 비용을 총 비용에 추가\n      edges += 1; // 간선 수 증가\n    }\n    // 두 노드가 이미 같은 집합이면 연결하지 않음 (사이클 방지)\n  }\n\n  return minCost; // MST의 최소 비용 반환\n}\n\n// 예제 테스트 케이스\nconsole.log(\n  \"result : \",\n  solution(4, [\n    [0, 1, 1],\n    [0, 2, 2],\n    [1, 2, 5],\n    [1, 3, 1],\n    [2, 3, 8],\n  ]),\n);\n// 결과: 4 (MST의 최소 비용)\n```","site/content/algorithms/set/prg5-islands.mdx","4bad9e97131d03a5","simulation/pr1-rotateclock",{"id":317,"data":319,"body":325,"filePath":326,"digest":327,"deferredRender":25},{"title":320,"description":321,"createdAt":45,"path":322,"tags":324},"Pr1 Rotateclock","배열 arr이 주어질 시 시계방향으로 n번 회전하는 함수",[26,323],"simulation",{"pattern":323,"category":323},"배열 arr이 주어질 시 시계방향으로 n번 회전하는 함수\n\n> 📌 **Source Code:** [simulation/pr1-rotateclock.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr1-rotateclock.js)\n\n```js\n// 배열 arr이 주어질 시 시계방향으로 n번 회전하는 함수\n\nfunction rotate(arr) {\n  let result = Array.from({ length: arr.length }, () =>\n    Array(arr.length).fill(0),\n  );\n  for (let i = 0; i \u003C arr.length; i++) {\n    for (let j = 0; j \u003C arr.length; j++) {\n      result[j][result.length - 1 - i] = arr[i][j];\n    }\n  }\n  return result;\n}\n\nfunction rotateClock(arr, n) {\n  let result;\n  for (let i = 0; i \u003C= n; i++) {\n    result = rotate(arr);\n  }\n  return result;\n}\n\nconsole.log(\n  `result : ${rotateClock(\n    [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n      [13, 14, 15, 16],\n    ],\n    1,\n  )}`,\n);\n```","site/content/algorithms/simulation/pr1-rotateclock.mdx","d88e85ea0b67814b","simulation/pr2-matrix-multiply",{"id":328,"data":330,"body":334,"filePath":335,"digest":336,"deferredRender":25},{"title":331,"description":331,"createdAt":45,"path":332,"tags":333},"Pr2 Matrix Multiply",[26,323],{"pattern":323,"category":323},"> 📌 **Source Code:** [simulation/pr2-matrix-multiply.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr2-matrix-multiply.js)\n\n```js\nfunction multiplyMatrix(arr1, arr2) {\n  const size = arr1.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      for (let k = 0; k \u003C size; k++) {\n        result[i][j] += arr1[i][k] * arr2[k][j];\n      }\n    }\n  }\n  return result;\n}\n\nfunction transposeMatrix(arr) {\n  const size = arr.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      result[i][j] += arr[j][i];\n    }\n  }\n  return result;\n}\n\nfunction solution(arr1, arr2) {\n  const multiplied = multiplyMatrix(arr1, arr2);\n  const result = transposeMatrix(multiplied);\n\n  return result;\n}\n\nconsole.log(\n  `result : ${JSON.stringify(\n    solution(\n      [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n      ],\n      [\n        [9, 8, 7],\n        [6, 5, 4],\n        [3, 2, 1],\n      ],\n    ),\n  )}`,\n);\n```","site/content/algorithms/simulation/pr2-matrix-multiply.mdx","be7259c014938d19","simulation/pr3-snail",{"id":337,"data":339,"body":344,"filePath":345,"digest":346,"deferredRender":25},{"title":340,"description":341,"createdAt":45,"path":342,"tags":343},"Pr3 Snail","n을 입력받아 달팽이처럼 1~n까지 숫자가 채워진",[26,323],{"pattern":323,"category":323},"> 📌 **Source Code:** [simulation/pr3-snail.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr3-snail.js)\n\n```js\n// n을 입력받아 달팽이처럼 1~n까지 숫자가 채워진\n// 2차원 배열을 return\n// TODO 다시 해보기\n/*\nreturn :\n[\n[1,2,3],\n[8,9,4],\n[7,6,5]\n]\n */\n\nfunction solution(n) {\n  let arr = Array.from({ length: n }, () => Array(n).fill(0));\n}\n```","site/content/algorithms/simulation/pr3-snail.mdx","fcf6f3cd4a626a11","stack/core",{"id":347,"data":349,"body":353,"filePath":354,"digest":355,"deferredRender":25},{"title":350,"description":350,"createdAt":45,"path":351,"tags":352},"Stack",[26,47],{"pattern":49,"category":47},"> 📌 **Source Code:** [core/stack.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/stack/core.js)\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n    this.size = 0;\n  }\n  push(item) {\n    this.items.push(item);\n    this.size++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    this.size--;\n    return this.items.pop();\n  }\n  isEmpty() {\n    return this.size === 0;\n  }\n}\n```","site/content/algorithms/stack/core.mdx","66d02b168fec60d3","tree/prg2-pyramid-scheme",{"id":356,"data":358,"body":363,"filePath":364,"digest":365,"deferredRender":25},{"title":359,"description":360,"createdAt":45,"path":361,"tags":362},"Pyramid Scheme","프로그래머스 다단계 판매",[26,101],{"pattern":101,"category":101,"platform":71},"> 📌 **Source Code:** [tree/prg2-pyramidscheme.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/prg2-pyramidscheme.js)\n\n```js\nfunction solution(enroll, referral, seller, amount) {\n  const sellerMap = new Map();\n  const price = 100;\n  let result = [];\n  for (let member of enroll) {\n    sellerMap.set(`${member}`, { income: 0, shared: \"\" });\n  }\n\n  for (let i = 0; i \u003C referral.length; i++) {\n    // 자신을 등록한 사람만 기억하면 됨\n    if (referral[i] !== \"-\") {\n      const enrolledBy = sellerMap.get(`${enroll[i]}`);\n\n      sellerMap.set(enroll[i], { ...enrolledBy, shared: referral[i] });\n      // 자신을 등록한 사람에게 이익금 계산에서 자신의 이익금을 빼서 더해줌.\n      console.log(\n        `${enroll[i]} \\n enrolledBy : ${referral[i]} / ${enroll[i]} data: ${JSON.stringify(sellerMap.get(`${enroll[i]}`))}`,\n      );\n    }\n    // 추가로 추천을 받은 사람 enroll[i]는\n  }\n\n  // 여기서 이익 계산함\n  for (let i = 0; i \u003C seller.length; i++) {\n    const salesman = sellerMap.get(seller[i]);\n    if (!salesman) {\n      continue;\n    }\n    console.log(`${i} - salesman : ${seller[i]}`, salesman);\n    const refer = salesman.shared;\n    const salesCount = amount[i];\n    console.log(`${i} - salesCount`, salesCount);\n    let fee = 0;\n\n    const income = salesCount * price;\n    if (refer) {\n      fee = income / 10;\n    }\n    const netIncome = income - fee;\n    console.log(\n      `${i} income: ${income}\\n fee: ${fee} \\nnetIncome >> \\n`,\n      netIncome,\n    );\n    sellerMap.set(seller[i], {\n      ...salesman,\n      income: salesman.income + netIncome,\n    });\n\n    if (refer) {\n      const referrer = sellerMap.get(refer);\n      // fee 더함\n      sellerMap.set(refer, { ...referrer, income: referrer.income + fee });\n      console.log(`${i} refer ${refer} >> \\n`, sellerMap.get(refer));\n    }\n  }\n\n  // 추가로 첫번째, 두번째 사람들 수수료 뺴줘야됨\n  // 자기 이익 전체에서 -10% 해줘야됨\n  // 그냥 obj가 쉬울지도.\n\n  // 수수료 빼고, fee 계속 더해서 income 남게 됨.\n  console.log(\"before entries :\", sellerMap);\n  let sellerArr = [...sellerMap].map(([, obj]) => obj.income);\n\n  return sellerArr;\n}\n\nlet test1A = [\n  \"john\",\n  \"mary\",\n  \"edward\",\n  \"sam\",\n  \"emily\",\n  \"jaimie\",\n  \"tod\",\n  \"young\",\n];\nlet test1B = [\"-\", \"-\", \"mary\", \"edward\", \"mary\", \"mary\", \"jaimie\", \"edward\"];\nlet test1C = [\"young\", \"john\", \"tod\", \"emily\", \"mary\"];\nlet test1D = [12, 4, 2, 5, 10];\n\nconsole.log(`result : /n`, solution(test1A, test1B, test1C, test1D));\n```","site/content/algorithms/tree/prg2-pyramid-scheme.mdx","87a81166e86d56e2","simulation/prg1-binary",{"id":366,"data":368,"body":373,"filePath":374,"digest":375,"deferredRender":25},{"title":369,"description":370,"createdAt":45,"path":371,"tags":372},"Binary","Prg1 Binary",[26,323],{"pattern":323,"category":323,"platform":71},"> 📌 **Source Code:** [simulation/prg1-binary.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/prg1-binary.js)\n\n```js\nfunction remove(n) {\n  let c = 0;\n  let r = \"\";\n  for (const dig of n) {\n    if (dig == 0) {\n      c++;\n    } else {\n      r += dig;\n    }\n  }\n  return [r, c];\n}\n\nfunction toBinary(n) {\n  let s = n;\n  let a = [];\n  let r = \"\";\n  while (s > 0) {\n    a.push(s % 2);\n    s = Math.floor(s / 2);\n  }\n  while (a.length > 0) {\n    r += a.pop();\n  }\n  return r;\n}\n\nfunction solution(s) {\n  let count = 0;\n  let removeCount = 0;\n\n  while (s.length > 1) {\n    let [removed, rc] = remove(s);\n    let bin = toBinary(removed.length);\n    console.log(\"inner while : \", bin, removed, rc);\n    removeCount += rc;\n    s = bin;\n    count++;\n  }\n\n  return [count, removeCount];\n}\n\nconsole.log(`result : ${JSON.stringify(solution(\"110010101001\"))}`);\n```","site/content/algorithms/simulation/prg1-binary.mdx","9cbe7f85aa5a6d0d","tree/core",{"id":376,"data":378,"body":383,"filePath":384,"digest":385,"deferredRender":25},{"title":379,"description":380,"createdAt":45,"path":381,"tags":382},"Tree","이진 트리 기본 구현체",[26,47],{"pattern":49,"category":47},"> 📌 **Source Code:** [tree/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/core.js)\n\n```js\n// 이진 트리 기본 구현체\n\n// 모든 노드에서 가장 오른쪽인 노드만 선택하는 함수\nconst rightSideView = (tree) => {\n  if (tree.length \u003C= 1) return []; // 빈 트리거나 루트 노드만 없는 경우\n\n  const result = [];\n  const queue = [1]; // 루트 노드의 인덱스 (1부터 시작)\n\n  while (queue.length > 0) {\n    const levelSize = queue.length; // 현재 레벨의 노드 수\n    let lastNodeValue = null;\n\n    for (let i = 0; i \u003C levelSize; i++) {\n      const currentIndex = queue.shift();\n      if (tree[currentIndex] === null || tree[currentIndex] === undefined)\n        continue;\n\n      lastNodeValue = tree[currentIndex]; // 현재 레벨의 마지막 값을 저장\n\n      // 왼쪽 자식 추가\n      const leftChildIndex = 2 * currentIndex;\n      if (leftChildIndex \u003C tree.length) queue.push(leftChildIndex);\n\n      // 오른쪽 자식 추가\n      const rightChildIndex = 2 * currentIndex + 1;\n      if (rightChildIndex \u003C tree.length) queue.push(rightChildIndex);\n    }\n\n    if (lastNodeValue !== null) result.push(lastNodeValue);\n  }\n\n  return result;\n};\n\n// 예제 실행\nconsole.log(rightSideView([null, 1, 2, 3, null, 5, null, 4])); // 출력: [1, 3, 4]\nconsole.log(rightSideView([null, 1, 2, 3, 4, null, null, null, 5])); // 출력: [1, 3, 4, 5]\nconsole.log(rightSideView([null, 1, null, 3])); // 출력: [1, 3]\nconsole.log(rightSideView([null])); // 출력: []\n\n/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\n```","site/content/algorithms/tree/core.mdx","cf597794e1ab2dbc","tree/practice1-making-tree",{"id":386,"data":388,"body":393,"filePath":394,"digest":395,"deferredRender":25},{"title":389,"description":390,"createdAt":45,"path":391,"tags":392},"Practice1 Making Tree","이진 트리를 전/중/후위 순회하기",[26,101],{"pattern":101,"category":101},"> 📌 **Source Code:** [tree/practice1-making-tree.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/practice1-making-tree.js)\n\n```js\n/*\n *이진 트리를 표현한 배열 nodes를 인자로 받습니다. 예를 들어 nodes가 `[1,2,3,4,5,6,7]`이라면 다음과 같은 트리를 표현합니다.\n * 해당 이진트리에 대하여 전위 순회, 중위순회, 후위 순회 결과를 반환하는 solution()함수를 구현하세요.\n * 조건: 노드는 1 이상 1000개 이하. 노드는 정수값이며 중복되지 않는다.\n * */\n\nfunction getPreOrder(nodes) {\n  let result = [empty, ...nodes];\n  for (let i = 1; i \u003C nodes.length; i++) {\n    if (i === 1) {\n      result.push(i);\n      continue;\n    }\n    // 현재 노드가 부모보다 작으면?\n    if (nodes[i] \u003C result[i / 2]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n    if (nodes[i] > result[i / 2 + 1]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n  }\n  return result;\n}\n\nfunction solution(nodes) {\n  let result = [];\n  let preOrder = getPreOrder(nodes);\n\n  return result;\n}\n```","site/content/algorithms/tree/practice1-making-tree.mdx","8aad98b20cefbebc","tree/prg3-maze",{"id":396,"data":398,"body":403,"filePath":404,"digest":405,"deferredRender":25},{"title":399,"description":400,"createdAt":45,"path":401,"tags":402},"Maze","console.log(`result : /n`, solution(test1A));",[26,101],{"pattern":101,"category":101,"platform":71},"> 📌 **Source Code:** [tree/prg3-maze.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/prg3-maze.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction getCord(maps, target) {\n  let tRow = maps.findIndex((col) => col.includes(target));\n  let tCol = maps[tRow].split(\"\").findIndex((col) => col === target);\n  return [tRow, tCol];\n}\n\nfunction bfs(maps, start, target) {\n  let direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  let rows = maps.length;\n  let cols = maps[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [sRow, sCol] = getCord(maps, start);\n\n  let Q = new Queue();\n  console.log(`\n  sRow : ${sRow}\n  sCol : ${sCol}\n  `);\n\n  Q.push([sRow, sCol, 0]);\n\n  while (!Q.isEmpty()) {\n    const [r, c, dist] = Q.pop();\n\n    console.log(`\n    r : ${r}\n    c : ${c}\n    maps[r][c] : ${maps[r][c]}\n    `);\n\n    if (maps[r][c] === target) {\n      return dist;\n    }\n\n    for (const [dr, dc] of direction) {\n      let nr = r + dr;\n      let nc = c + dc;\n      let updateCondition =\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C rows &&\n        nc \u003C cols &&\n        maps[nr][nc] !== \"X\" &&\n        !visited[nr][nc];\n      if (updateCondition) {\n        visited[nr][nc] = true;\n        Q.push([nr, nc, dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let toLeverDist = bfs(maps, \"S\", \"L\");\n  let toEndDist = bfs(maps, \"L\", \"E\");\n  console.log(`----\n  toLeverDist ${toLeverDist}\n  toEndDist : ${toEndDist}\n  --------\n  `);\n  let answer = toLeverDist > 0 && toEndDist > 0 ? toLeverDist + toEndDist : -1;\n  return answer;\n}\nlet test1A = [\"SOOOL\", \"XXXXO\", \"OOOOO\", \"OXXXX\", \"OOOOE\"];\nlet test1B = [\"LOOXS\", \"OOOOX\", \"OOOOO\", \"OOOOO\", \"EOOOO\"];\n\n// console.log(`result : /n`, solution(test1A));\nconsole.log(`result : /n`, solution(test1B));\n```","site/content/algorithms/tree/prg3-maze.mdx","15d9bbc739712248"]