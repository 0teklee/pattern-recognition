[["Map",1,2,9,10,26,27],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.4.3","content-config-digest","56efaea828b2378c","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://patterns.leetekwoo.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"class\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","uiux",["Map",11,12],"button/react-button",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"deferredRender":25},{"title":14,"description":15,"createdAt":16,"path":17,"tags":20},"React Button (basic)","UIUX Patterns","2025-03-17",[9,18,19],"button","react",{"category":21,"component":18,"framework":19},"UI","import CodeDisplay from \"site/components/code-display.astro\";\nimport TabPanel from \"site/components/tab-panel.astro\";\nimport Tabs from \"site/components/tabs.astro\";\nimport Button from \"./button\";\n\n## React Buttons\n\n\u003CTabs tabs={[\"Button Component\", \"button.tsx\"]}>\n  \u003CTabPanel isDefault={true} tabIndex={0} tabName={\"Button Component\"}>\n    \u003CButton client:load text={\"Click me\"} />\n  \u003C/TabPanel>\n  \u003CTabPanel tabName=\"button.tsx\" tabIndex={1}>\n    \u003CCodeDisplay file=\"uiux/button/button.tsx\" highlightLines=\"{5-7}\" />\n  \u003C/TabPanel>\n\u003C/Tabs>","site/content/uiux/button/react-button.mdx","4079ab745d0342db",true,"algorithms",["Map",28,29,40,41,53,54,63,64,75,76,85,86,95,96,108,109,119,120,131,132,141,142,152,153,163,164,172,173,183,184,194,195,206,207,216,217,226,227,236,237,246,247,256,257,267,268,277,278,287,288,297,298,307,308,317,318,328,329,337,338,347,348,356,357,366,367,376,377,386,387,396,397],"backtracking/leetcode-79-word-search",{"id":28,"data":30,"body":37,"filePath":38,"digest":39,"deferredRender":25},{"title":31,"description":32,"createdAt":16,"path":33,"tags":36},"LeetCode 79. Word Search","LeetCode problem 79",[26,34,35],"leetcode","backtracking",{"pattern":35,"category":34},"# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/word-search/)\n\n1. íƒìƒ‰ ê²°ê³¼ê°€ **ë°©ë¬¸ ìˆœì„œì— ì˜í–¥ì„ ë°›ìŒ**\n2. **ë°±íŠ¸ëž˜í‚¹**ì´ í•„ìš”í•¨\n   - `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n[ì´ì „ ê¸€](https://blog.leetekwoo.com/blog/63#3-3-backtracking)ì—ì„œ ì‚´í•€ ë°±íŠ¸ë ˆí‚¹ì„ í™œìš©í•˜ëŠ” ë¬¸ì œì´ë‹¤. visitedë¥¼ ì¸ì ‘ í–‰ë ¬ë¡œ ê´€ë¦¬í•œë‹¤.\n\n## ì •ë‹µ\n\n```js\n/**\n * @description ë¬¸ì œ : ì¸ì ‘ í–‰ë ¬ì—ì„œ wordë¥¼ ë§Œë“¤ ìˆ˜ ìžˆëŠ” ì—¬ë¶€ true/false\n *   ë°©í–¥ì€ ìƒê´€ì—†ë‹¤. (ì™¼\u003C->ì˜¤, ìœ„ \u003C->ì•„ëž˜)\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function (board, word) {\n  const rSize = board.length;\n  const cSize = board[0].length;\n  const visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs(r, c, count = 0) {\n    if (word.length === count) return true; // ê¸°ì € ì¡°ê±´. ìž¬ê·€ í•¨ìˆ˜ ì „ì²´ ì¤‘ë‹¨ ì¡°ê±´\n    /** @note ì—¬ê¸°ì„œ ë°©ë¬¸ ì²˜ë¦¬ X **/\n    // visited[r][c] = true; //\n    if (\n      // ì¡°ê±´ í•´ë‹¹ ì‹œ\n      r >= 0 &&\n      c >= 0 &&\n      r \u003C rSize &&\n      c \u003C cSize &&\n      !visited[r][c] &&\n      board[r][c] === word[count]\n    ) {\n      /** @note ë°©ë¬¸ ì²˜ë¦¬ë¥¼ ì—¬ê¸°ì„œ í•´ì•¼í•¨. **/\n      visited[r][c] = true; // ë°©ë¬¸ ì²˜ë¦¬ë¥¼ ì—¬ê¸°ì„œ í•´ì•¼í•¨\n      for (let [or, oc] of offset) {\n        if (dfs(r + or, c + oc, count + 1)) return true;\n      }\n      /** @note ë°±íŠ¸ë ˆí‚¹ : ê²½ë¡œë§ˆë‹¤ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìžˆì–´ í•´ì£¼ì–´ì•¼í•¨. **/\n      visited[r][c] = false;\n    }\n\n    return false;\n  }\n\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n\n  return false;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n```js\nvar exist = function (board, word) {\n  const n = board.length;\n  const visited = Array.from({ length: n }, () => Array(n).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs([r, c], word, visited, count = 0) {\n    if (visited[r][c]) return count;\n    visited[r][c] = true;\n    if (word[count] === board[r][c]) {\n      // countë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•´ì•¼ ë  ì§€ ëª°ëžë‹¤.\n      // ì¸ì ‘ë…¸ë“œ ë°©ë¬¸ í˜„ìž¬ ê¸€ìžê°€ word[count]ëž‘ ê°™ì„ ë•Œë§Œ ìž¬ê·€ í˜¸ì¶œ\n\n      for (let [or, oc] of offset) {\n        const [nr, nc] = [r + or, c + oc];\n        if (\n          nr \u003C n &&\n          nc \u003C n &&\n          nr >= 0 &&\n          nc >= 0 &&\n          !visited[nr][nc] &&\n          board[nr][nc] === word[count + 1]\n        ) {\n          count += dfs([nr, nc], word, visited, count + 1);\n        }\n      }\n    } else {\n      return count;\n    }\n  }\n  // ë¬¸ì œ ì¡°ê±´ì´ O(n^2)ìœ¼ë¡œ 2ì¤‘ í¬ë¬¸ìœ¼ë¡œ í‘¸ëŠ” ê²ƒì´ ë” ì ì ˆí–ˆìŒ\n  // countê°€ ì¡°ê±´ì— ë§žìœ¼ë©´ ë°”ë¡œ ë¦¬í„´ë§Œ í•˜ë©´ë¨. ëˆ„ì í•  í•„ìš”ëŠ” ì—†ì—ˆìŒ.\n  const result = dfs([0, 0], word, visited, 0);\n  return result === word.length;\n};\n```","site/content/algorithms/backtracking/leetcode-79-word-search.mdx","a808bde14e0d4aae","bfs/core",{"id":40,"data":42,"body":50,"filePath":51,"digest":52,"deferredRender":25},{"title":43,"description":44,"createdAt":45,"path":46,"tags":48},"Bfs","1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„","2025-03-19",[26,47],"core",{"pattern":49,"category":47},"","> ðŸ“Œ **Source Code:** [bfs/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/bfs/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  enqueue(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  dequeue() {\n    return this.items[this.front++];\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(start, graph, visited, answer) {\n  let Q = new Queue();\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  /* ìµœì†Œ, ìµœë‹¨ ê±°ë¦¬ ë“±ì„ ê³„ì‚°í•´ì•¼í•œë‹¤ë©´ paramìœ¼ë¡œ ë°›ê³ ,\n   ë°˜ë³µë¬¸ ì•ˆì—ì„œ ì¡°ê±´ì— ë§žì„ ì‹œ ì—…ë°ì´íŠ¸ í•œ ë’¤ returní•œë‹¤.\n   í˜¹ì€ í•´ë‹¹í•˜ëŠ” ì¢Œí‘œì˜ ë¬¶ìŒ ë“±ì„ í•„ìš”ë¡œ í•  ì‹œ\n    let result = [start];ë¥¼ ë°˜ë³µë¬¸ ì™¸ë¶€ì— ë§Œë“¤ê³ ,\n    result.push(newNode)ë¥¼ í•˜ë©´ ë°©ë¬¸í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ìŒ“ì´ê²Œ ëœë‹¤.\n    */\n\n  // í ì‹œìž‘ì  ì¶”ê°€\n  Q.push(start); // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ start í˜•íƒœ ë‹¤ë¦„\n  while (!Q.isEmpty()) {\n    let start = Q.dequeue();\n    // ì¡°ê±´ë¬¸ ì¶”ê°€\n\n    for (let neighbor of graph[start]) {\n      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§žê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´\n      if (!visited[neighbor]) {\n        //  answer++;, í˜¹ì€ ë¬¸ì œ ì¡°ê±´ì— ë”°ë¼ bfs ë‚´ë¶€ì—ì„œ resultë¥¼ ëª¨ì•„ pushí•  ìˆ˜ ë„ ìžˆìŒ.\n        visited[neighbor] = true; // ì´ ì¡°ê±´ ì–¸ì œ ì¶”ê°€í•´ì•¼í•˜ì§€?\n        Q.enqueue(neighbor);\n      }\n    }\n  }\n  return answer;\n}\n\n// offset ì‚¬ìš©í•˜ëŠ” bfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction bfsOffset(visited, graph, [startR, startC], answer) {\n  let Q = new Queue();\n  visited[startR][startC] = true;\n  Q.enqueue([startR, startC]);\n  while (!Q.isEmpty()) {\n    let [curR, curC] = Q.dequeue();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§žëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..\n      ) {\n        visited[nr][nc] = true;\n        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©\n        Q.enqueue([nr, nc]);\n      }\n    }\n  }\n  return answer;\n}\n```","site/content/algorithms/bfs/core.mdx","53b5925ee1b65598","backtracking/pr1-1n",{"id":53,"data":55,"body":60,"filePath":61,"digest":62,"deferredRender":25},{"title":56,"description":57,"createdAt":45,"path":58,"tags":59},"Pr1 1+N","ì¤‘ë‹¨ì : ì´í•©ì´ 10ì´ë©´ ê²°ê³¼ì— ì¶”ê°€",[26,35],{"pattern":35,"category":35},"> ðŸ“Œ **Source Code:** [backtracking/pr1-1+N.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/backtracking/pr1-1+N.js)\n\n```js\nfunction backtrack(ì´í•©, ì„ íƒëœìˆ˜, ì‹œìž‘ìˆ˜, ì „ì²´ìˆ˜, ê²°ê³¼) {\n  // ì¤‘ë‹¨ì : ì´í•©ì´ 10ì´ë©´ ê²°ê³¼ì— ì¶”ê°€\n  if (ì´í•© === 10) {\n    ê²°ê³¼.push(ì„ íƒëœìˆ˜);\n    return;\n  }\n\n  for (let i = ì‹œìž‘ìˆ˜; i \u003C= ì „ì²´ìˆ˜; i++) {\n    if (ì´í•© + i \u003C= 10) {\n      // ì´í•©ì´ 10ì„ ë„˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™\n      backtrack(ì´í•© + i, ì„ íƒëœìˆ˜.concat(i), i + 1, ì „ì²´ìˆ˜, ê²°ê³¼);\n    }\n  }\n}\n\nfunction solution(n) {\n  let result = [];\n  backtrack(0, [], 1, n, result);\n  return result;\n}\n\n// í…ŒìŠ¤íŠ¸ ì‹¤í–‰\nconsole.log(\"result : \", solution(5));\n```","site/content/algorithms/backtracking/pr1-1+N.mdx","376fbd0b67456ce8","bfs/prg1-gamemap",{"id":63,"data":65,"body":72,"filePath":73,"digest":74,"deferredRender":25},{"title":66,"description":67,"createdAt":45,"path":68,"tags":70},"Gamemap","Prg1 Gamemap",[26,69],"graph",{"pattern":69,"category":69,"platform":71},"programmers","> ðŸ“Œ **Source Code:** [graph/prg1-gamemap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/bfs/prg1-gamemap.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(map, start, target) {\n  let rows = map.length;\n  let cols = map[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [tR, tC] = target;\n  const Q = new Queue();\n  const direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  Q.push([start, 0]);\n\n  while (!Q.isEmpty()) {\n    const [[prevR, prevC], dist] = Q.pop();\n\n    if (prevR == tR && prevC == tC) {\n      return dist;\n    }\n\n    for (let [r, c] of direction) {\n      let nextR = prevR + r;\n      let nextC = prevC + c;\n      if (\n        nextR \u003C rows &&\n        nextC \u003C cols &&\n        nextR >= 0 &&\n        nextC >= 0 &&\n        map[nextR][nextC] != 0 &&\n        !visited[nextR][nextC]\n      ) {\n        visited[nextR][nextC] = true;\n        Q.push([[nextR, nextC], dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let start = [0, 0];\n  let target = [maps.length - 1, maps[0].length - 1];\n\n  let dist = bfs(maps, start, target);\n\n  return dist;\n}\n\nconsole.log(\n  \"result : \",\n  solution([\n    [1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 1],\n  ]),\n);\n```","site/content/algorithms/bfs/prg1-gamemap.mdx","811cf39c217ace53","dfs/core",{"id":75,"data":77,"body":82,"filePath":83,"digest":84,"deferredRender":25},{"title":78,"description":79,"createdAt":45,"path":80,"tags":81},"Dfs","ìž¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs",[26,47],{"pattern":49,"category":47},"> ðŸ“Œ **Source Code:** [core/dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/dfs/core.js)\n\n```js\n// ìž¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs\nfunction recursiveDfs(start, graph, visited, answer) {\n  // ìž¬ê·€ í˜¸ì¶œ ì‹œ ë°©ë¬¸ ì—¬ë¶€ ì—…ë°ì´íŠ¸ ìœ„ì¹˜ ì£¼ì˜\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  // ë¬¸ì œê°€ ìš”êµ¬í•˜ëŠ” ë°˜í™˜ê°’ì´ ë¬´ì—‡ì¸ì§€ì— ë”°ë¼ ë°˜í™˜ê°’, í•¨ìˆ˜ ì¸ìž, ì—…ë°ì´íŠ¸ ì¡°ê±´ ë“±ì´ ë‹¬ë¼ì§„ë‹¤.\n  // answerì´ ìˆ«ìžë¼ë©´ íŠ¹ì • ìˆ«ìž ì´í•˜ì¼ ë•Œ dfs ìž¬ê·€ í˜¸ì¶œì„ ë°±íŠ¸ëž˜í‚¹í•  ìˆ˜ ìžˆë‹¤.\n\n  // ìž¬ê·€ í•¨ìˆ˜ ìŠ¤íƒì— ë“¤ì–´ê°€ê¸° ì „ì— ì¡°ê±´ë¬¸ì„ ì¶”ê°€í•˜ì—¬ return í•  ìˆ˜ë„ ìžˆë‹¤.\n  // ì´ ë•Œ ì¤‘ë‹¨ë˜ëŠ” ê²ƒì€ ë”ì´ìƒ ì•„ëž˜ ë…¸ë“œë“¤ì´ ì¡°ê±´ì— ë¶€í•©í•˜ì§€ ì•ŠëŠ” ê²½ìš° ì´ë‹¤.\n  while (!visited[start] && !!graph[start] && graph[start].length > 0) {\n    // ì´ ì¡°ê±´ì—ì„œ !graph[start]ì™€ graph[start].length \u003C 0 ì€ ìµœí•˜ìœ„ ë…¸ë“œê°€ ëœë‹¤\n    // ê·¸ëž˜í”„ê°€ startëŠ” ê°ì²´ í‚¤(ë¶€ëª¨ ë…¸ë“œ ì´ë¦„)ë‚˜ ë°°ì—´(ë¶€ëª¨ ë…¸ë“œì˜ ì¸ë±ìŠ¤)ê°€ ë  ìˆ˜ ìžˆë‹¤.\n    for (let neighbor of graph[start]) {\n      dfs(neighbor, graph, visited, answer);\n    }\n  }\n  // ë°˜ë³µë¬¸ ì™¸ë¶€ì—ì„œ answer.push(neighbor)í•˜ì—¬ ë…¸ë“œë¥¼ ì €ìž¥í•  ìˆ˜ ìžˆë‹¤.\n  // ë§Œì•½ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤ë©´, stackì—ì„œ ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê¸° ë•Œë¬¸ì— .reverse()í•˜ì—¬ ë°˜í™˜í•´ì•¼\n  // ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ë°˜í™˜í•  ìˆ˜ ìžˆë‹¤.\n  return;\n}\n\n// í•¨ìˆ˜ ë‚´ë¶€ì— stackì„ ë§Œë“¤ì–´ ì‚¬ìš©í•˜ëŠ” dfs\nfunction stackDfs(start, graph, visited, answer) {\n  let stack = [start];\n  // ì´ˆê¸° ì‹œìž‘ì  startë¥¼ ìŠ¤íƒì— ë¯¸ë¦¬ ì¶”ê°€í•˜ê³ , ë°©ë¬¸ ì—¬ë¶€ì— ì²´í¬í•œë‹¤\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  //\n  let result = [];\n  while (stack.length > 0) {\n    let current = stack.pop();\n\n    for (let neighbor of graph[current]) {\n      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§žê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´\n      if (\n        !visited[neighbor]\n        // && ë¬¸ì œì— ë§žëŠ” ì¡°ê±´ ì¶”ê°€ ê°€ëŠ¥ graph[neighbor] ===, >, \u003C {X} ë“±.\n      ) {\n        //  answer++;\n        visited[neighbor] = true; // ì¡°ê±´ ì¶”ê°€ íƒ€ì´ë°ì„ ì •ë¦¬í•˜ê³  ì‹¶ë‹¤\n        stack.push(neighbor);\n      }\n    }\n    // result.push(current) -\n    // ì´ ìœ„ì¹˜ì—ì„œ pushí•˜ë©´ ìµœí•˜ìœ„ ë…¸ë“œë¶€í„° ìŒ“ìž„\n    // = ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê²Œ ë˜ì„œ ë§ˆì§€ë§‰ì— reverse()í•´ì£¼ì–´ì•¼ í•œë‹¤.\n    // í•˜ì§€ë§Œ ê°€ìž¥ ê¹”ë”í•œ ë°©ì‹ì¼ ìˆ˜ ìžˆë‹¤.\n    // forë¬¸ ìœ„ì—ì„œ í•˜ë©´ ìžì‹ë…¸ë“œë³´ë‹¤ ë¶€ëª¨ ë…¸ë“œì˜ ì •ë³´ê°€ ë¨¼ì € ìŒ“ì´ëŠ”ë°,\n    // ê²°ê³¼ê°€ ì •í™•í•´ì§€ì§€ ì•ŠëŠ”ë‹¤. ì™œì¸ì§€ëŠ” ìž˜ ê¸°ì–µ ì•ˆë‚¨. -> ì´ì œ ì•ŒìŒ\n  }\n  return; // answer;\n}\n\n// offset ì‚¬ìš©í•˜ëŠ” dfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction dfsOffset(visited, graph, [startR, startC], answer) {\n  let stack = [[startR, startC]];\n  visited[startR][startC] = true;\n  let result = [];\n\n  while (stack.length > 0) {\n    let [curR, curC] = stack.pop();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§žëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..\n      ) {\n        visited[nr][nc] = true;\n        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©\n        stack.push([nr, nc]);\n      }\n    }\n    // curR, curCë¥¼ ëª¨ì•„ì•¼ í•œë‹¤ë©´, resultì— push í•´ì¤€ë‹¤.\n    result.push([curR, curC]);\n    // ì œì¼ ì²« startR,Cê°€ resultì— í‘¸ì‹œë˜ê³ \n    // ê·¸ ë‹¤ìŒ stackì˜ ê°€ìž¥ ìœ„ì— ìžˆëŠ” ìµœí•˜ìœ„ ë…¸ë“œê°€ ì‹¤í–‰ë¨\n  }\n\n  return answer;\n}\n```","site/content/algorithms/dfs/core.mdx","0e7e49a355a1e2d5","dfs/prg2-network-dfs",{"id":85,"data":87,"body":92,"filePath":93,"digest":94,"deferredRender":25},{"title":88,"description":89,"createdAt":45,"path":90,"tags":91},"Network Dfs","Prg2 Network Dfs",[26,69],{"pattern":69,"category":69,"platform":71},"> ðŸ“Œ **Source Code:** [graph/prg2-network-dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/dfs/prg2-network-dfs.js)\n\n```js\nfunction dfs(computers, visited, node) {\n  visited[node] = true;\n\n  for (let idx = 0; idx \u003C computers.length; idx++) {\n    if (computers[node][idx] && !visited[idx]) {\n      dfs(computers, visited, idx);\n    }\n  }\n}\n\nfunction solution(n, computers) {\n  let visited = Array(n).fill(false);\n  let answer = 0;\n\n  for (let i = 0; i \u003C n; i++) {\n    if (!visited[i]) {\n      dfs(computers, visited, i);\n      answer++;\n    }\n  }\n\n  return answer;\n}\n\nconsole.log(\"result : \", solution());\n```","site/content/algorithms/dfs/prg2-network-dfs.mdx","aefd8787725e34d2","dfs/leetcode-94-binary-tree-inorder-traverse",{"id":95,"data":97,"body":105,"filePath":106,"digest":107,"deferredRender":25},{"title":98,"description":99,"createdAt":16,"path":100,"tags":103},"LeetCode 94. Binary Tree Inorder Traversal","LeetCode problem 94",[26,34,101,102],"tree","traversal",{"pattern":104,"category":34},"tree-traversal","# Topics\n\n- Stack\n- Tree\n- Depth-First Search\n- Binary Tree\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ìž¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length \u003C 2) return s; // í•œ ê¸€ìžë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜\n\n  let start = 0,\n    maxLength = 1;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right \u003C s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return [left + 1, right - 1]; // íŒ°ë¦°ë“œë¡¬ì˜ ì‹œìž‘ê³¼ ë ì¸ë±ìŠ¤ ë°˜í™˜\n  }\n\n  for (let i = 0; i \u003C s.length; i++) {\n    // í™€ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬\n    let [l1, r1] = expandAroundCenter(i, i);\n    // ì§ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬\n    let [l2, r2] = expandAroundCenter(i, i + 1);\n\n    if (r1 - l1 + 1 > maxLength) {\n      start = l1;\n      maxLength = r1 - l1 + 1;\n    }\n    if (r2 - l2 + 1 > maxLength) {\n      start = l2;\n      maxLength = r2 - l2 + 1;\n    }\n  }\n\n  return s.slice(start, start + maxLength);\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. visitedê°€ ë¶ˆí•„ìš”í•œë° ì‚¬ìš©í–ˆìŒ\n2. paramìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” rootì˜ ê°’ì²˜ë¦¬ë¥¼ ì œëŒ€ë¡œ ëª»í•¨\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  let output = [];\n  let visited = new Set();\n  function dfs(root, cur) {\n    if (visited.has(cur) || !root?.val) return;\n    visited.add(cur);\n    output.push(root.val);\n\n    // ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ ì¤‘ìœ„ ìˆœíšŒëŠ” ì™¼ -> ë£¨íŠ¸ -> ì˜¤\n    dfs(root, root?.left);\n    dfs(root, root?.right);\n  }\n  dfs(root, root?.val);\n  return output;\n};\n```","site/content/algorithms/dfs/leetcode-94-binary-tree-inorder-traverse.mdx","b8d5e6280687add2","dynamic-programming/leetcode-5-longest-palindromic-substring",{"id":108,"data":110,"body":116,"filePath":117,"digest":118,"deferredRender":25},{"title":111,"description":112,"createdAt":16,"path":113,"tags":115},"LeetCode 5. Longest Palindromic Substring","LeetCode problem 5",[26,34,114],"dynamic-programming",{"pattern":114,"category":34},"# Topics\n\n- String\n- Two Pointers\n- Dynamic Programming\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/longest-palindromic-substring/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ìž¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // ì¤‘ë³µ ë¬¸ìžê°€ ì¡´ìž¬í•˜ë©´ ì•žì—ì„œ ì œê±°í•˜ë©´ì„œ ìœˆë„ìš° ì´ë™\n    /**@note ì´ ë¶€ë¶„ì—ì„œ s[start]ë¡œ startë¥¼ ì›€ì§ì´ê³ , setì—ì„œ ì œê±°í•¨\n     * @note Sliding Windowì˜ ê°€ë³€ í¬ê¸°ê°€ êµ¬í˜„ë¨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // ìƒˆë¡œìš´ ë¬¸ìž ì¶”ê°€\n    /** @note ì—…ë°ì´íŠ¸ ì‹œì ì€ setì˜ ë³€ê²½ ì´í›„ì— ì‹¤í–‰í•¨ **/\n    longest = Math.max(longest, end - start + 1); // ê¸¸ì´ ê°±ì‹ \n  }\n\n  return longest;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ì„±ëŠ¥ ìµœì í™”. reverseë¡œ ë¹„êµí•˜ëŠ” ë¹„ìš©ì´ ë„ˆë¬´ í¬ë‹¤\n2. ì˜ˆì™¸ì²˜ë¦¬: í•œê¸€ìž, ê°™ì€ ë‘ê¸€ìžì¼ë•Œ ë“±. ì¢€ ë” ì¶”ìƒì ì¸ ë¡œì§ìœ¼ë¡œ ê°œë³„ ì˜ˆì™¸ì²˜ë¦¬ ì•ˆí•  ìˆ˜ë„ ìžˆì„í…ë°.\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length === 1) return s;\n  let longest = 0,\n    start = 0,\n    n = s.length,\n    result = \"\";\n  while (start \u003C n - 1) {\n    for (let end = start + 1; end \u003C n; end++) {\n      let slice = s.slice(start, end + 1); // + 1 ?\n      let reverse = slice.split(\"\").reverse().join(\"\");\n      if (slice === reverse && slice.length >= longest) {\n        result = slice;\n        longest = slice.length;\n      }\n    }\n    start++;\n  }\n\n  return result || s[0];\n};\n```","site/content/algorithms/dynamic-programming/leetcode-5-longest-palindromic-substring.mdx","f39ade1f2a0da135","dfs/leetcode-130-surrounded-regions",{"id":119,"data":121,"body":128,"filePath":129,"digest":130,"deferredRender":25},{"title":122,"description":123,"createdAt":16,"path":124,"tags":126},"LeetCode 130. Surrounded Regions","LeetCode problem 130",[26,34,125],"leetcode-130-surrounded-regions",{"pattern":127,"category":34},"DFS","# Topics\n\n- Array\n- Depth-First Search\n- Breadth-First Search\n- Union Find\n- Matrix\n\n# ë¬¸ì œ\n\n[ë§í¬](https://leetcode.com/problems/surrounded-regions)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  if (!board.length || !board[0].length) return;\n\n  let rSize = board.length,\n    cSize = board[0].length;\n  let directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // ê°€ìž¥ìžë¦¬ì— ì—°ê²°ëœ 'O'ë¥¼ ì°¾ê³  'S'ë¡œ ë³€ê²½ (ë³´ì¡´ ì²˜ë¦¬)\n  function dfs(r, c) {\n    if (r \u003C 0 || c \u003C 0 || r >= rSize || c >= cSize || board[r][c] !== \"O\") {\n      return;\n    }\n    board[r][c] = \"S\"; // ê°€ìž¥ìžë¦¬ì— ì—°ê²°ëœ 'O'ëŠ” ë³´ì¡´\n    for (let [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  }\n\n  // 1. ê°€ìž¥ìžë¦¬ì—ì„œ DFS íƒìƒ‰í•˜ì—¬ 'O' â†’ 'S' ë³€ê²½ (ë³´ì¡´)\n  for (let r = 0; r \u003C rSize; r++) {\n    dfs(r, 0);\n    dfs(r, cSize - 1);\n  }\n\n  for (let c = 0; c \u003C cSize; c++) {\n    dfs(0, c);\n    dfs(rSize - 1, c);\n  }\n\n  // 2. ë³´ë“œë¥¼ ì—…ë°ì´íŠ¸\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (board[r][c] === \"O\") {\n        board[r][c] = \"X\"; // ê°ì‹¸ì§„ 'O' â†’ 'X'\n      } else if (board[r][c] === \"S\") {\n        board[r][c] = \"O\"; // ë³´ì¡´ëœ 'S' â†’ ì›ëž˜ëŒ€ë¡œ 'O'\n      }\n    }\n  }\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. DFS ë°©ë¬¸ ë¡œì§ ì˜¤ë¥˜ (dfs ë‚´ë¶€ ì¡°ê±´ ì˜¤ë¥˜)\n\n- if (visited[r][c]) return false â†’ ì´ë¯¸ ë°©ë¬¸í•œ ê³³ì„ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì€ ë§žì§€ë§Œ, dfsê°€ ì°¸/ê±°ì§“ì„ ë°˜í™˜í•´ì•¼ í•˜ëŠ” ì´ìœ ê°€ ë¶ˆë¶„ëª…í•¨.\n- isChange = dfs([nr, nc]) ë¶€ë¶„ì—ì„œ trueë¥¼ ë°˜í™˜í•˜ë©´ board[r][c] = \"X\"ë¡œ ë³€ê²½í•˜ëŠ”ë°, ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•œ í›„ ë³€í™˜ ì—¬ë¶€ë¥¼ ê²°ì •í•´ì•¼ í•¨.\n- ì¦‰, ì¸ì ‘í•œ ëª¨ë“  'O'ë¥¼ ë°©ë¬¸í•œ í›„ ë³€ê²½ ì—¬ë¶€ë¥¼ íŒë‹¨í•´ì•¼ í•¨.\n\n2. ê²½ê³„ ì¡°ê±´ ì²˜ë¦¬ ì˜¤ë¥˜ (isCurrentEdge í™œìš© ë¬¸ì œ)\n\n- isCurrentEdgeê°€ trueë©´ ì¦‰ì‹œ falseë¥¼ ë°˜í™˜í•˜ëŠ” ê²ƒì€ í‹€ë¦¼.\n- ê°€ìž¥ìžë¦¬ì— ìžˆëŠ” 'O'ë¥¼ ë°œê²¬í•˜ë©´ í•´ë‹¹ ì˜ì—­ ì „ì²´ë¥¼ ë³´ì¡´í•´ì•¼ í•¨.\n- falseë¥¼ ë°˜í™˜í•´ë„ ì¸ì ‘ ë…¸ë“œê°€ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ â†’ ê°€ìž¥ìžë¦¬ì— ì—°ê²°ëœ ëª¨ë“  'O'ë¥¼ ë³€ê²½í•˜ì§€ ì•Šë„ë¡ í‘œê¸°í•˜ëŠ” ê²ƒì´ í•µì‹¬.\n\n3. ë³´ë“œ ì—…ë°ì´íŠ¸ íƒ€ì´ë° ë¬¸ì œ (board[r][c] = \"X\")\n\n- DFS ë„ì¤‘ ë°”ë¡œ \"X\"ë¡œ ë³€í™˜í•˜ë©´ ì•ˆ ë¨.\n- íƒìƒ‰ ì¤‘ì¸ 'O'ê°€ ì‹¤ì œë¡œ ê°ì‹¸ì ¸ ìžˆëŠ”ì§€ í™•ì •ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ë³€ê²½ë˜ë©´ ì˜¤ë‹µ ê°€ëŠ¥ì„± ì¦ê°€.\n- ëª¨ë“  DFSê°€ ì™„ë£Œëœ í›„, ê°ì‹¸ì§„ 'O'ë¥¼ 'X'ë¡œ ë³€í™˜í•´ì•¼ í•¨.\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  let rSize = board.length,\n    cSize = board[0].length;\n  let visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  let offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // dfs t/f ë°˜í™˜. të©´ Xë¡œ ë°”ê¾¼ë‹¤, fë©´ ë°”ê¾¸ì§€ ì•ŠëŠ”ë‹¤.\n  function dfs([r, c]) {\n    if (visited[r][c]) return false;\n    visited[r][c] = true;\n\n    const isCurrentEdge =\n      r === 0 || c === 0 || r === rSize - 1 || c === cSize - 1;\n\n    // ì¸ì ‘ì´ Xì¸ ê²½ìš°, ì—°ê²°ëœ ëª¨ë“  Oê°€ Xë¼ë©´ ë°”ê¿”ì•¼í•¨\n    if (board[r][c] === \"X\") return true;\n    // ë˜ëŠ” Oê°€ ê°€ìž¥ ìžë¦¬ì— ìžˆë‹¤ë©´ Xë¡œ ë°”ê¿€ ìˆ˜ ì—†ìŒ\n    if (board[r][c] === \"O\" && isCurrentEdge) return false;\n\n    // í˜„ìž¬ ë…¸ë“œ = \"O\" ì¸ì ‘ ë…¸ë“œì— ë”°ë¼ ìžê¸° ìžì‹ ì´ ë°”ë€œ\n    // 1. ì¸ì ‘ ë…¸ë“œë¥¼ ëª¨ë‘ ë°©ë¬¸í•˜ê³ ,\n    // 2. ìžê¸° ìžì‹ ì˜ ë°”ê¾¸ëŠ” ì—¬ì§€ë¥¼ ì •í•¨.\n\n    // ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ ì „ì— í˜„ìž¬ Oë¥¼ Xë¡œ ë°”ê¾¸ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë‹¤\n    // O\n\n    /**\n        ëª©ì : dfsê°€ tfë¥¼ ë°˜í™˜í•˜ì—¬ ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸í•œ ê²°ê³¼ê°’ì´ t/fë¥¼ ë°˜í™˜í•˜ê²Œ í•œë‹¤.\n        ì¡°ê±´:\n        - ëª¨ë“  ì¸ì ‘ì´ Xì´ë©´? í˜„ìž¬ ë…¸ë“œë¥¼ Xë¡œ ë°”ê¾¼ë‹¤\n        - ëª¨ë“  ì¸ì ‘ì´ Xê°€ ì•„ë‹ˆë©´? Oì¸ ë…¸ë“œë¡œ ì´ë™í•œë‹¤\n        - í˜„ìž¬ ë…¸ë“œì˜ r, cê°€ 0ì´ë‚˜ r,cSize-1ì´ë©´? ë³€í™˜í•˜ì§€ ì•ŠëŠ”ë‹¤ - ìœ„ì—ì„œ false ë³€í™˜\n         **/\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [r + or, c + oc];\n      let isChange = false;\n      if (nr >= 0 && nc >= 0 && nr \u003C rSize && c \u003C cSize && !visited[nr][nc]) {\n        isChange = dfs([nr, nc]);\n        if (isChange) {\n          board[r][c] = \"X\";\n        }\n      }\n    }\n    return isCurrentEdge;\n  }\n  // board ìžì²´ë¥¼ dfs ë‚´ë¶€ì—ì„œ ë³€í™˜í•œ ë’¤ ë¦¬í„´.\n  return board;\n};\n```","site/content/algorithms/dfs/leetcode-130-surrounded-regions.mdx","ee88843912b36720","backtracking/prg3-arrow",{"id":131,"data":133,"body":138,"filePath":139,"digest":140,"deferredRender":25},{"title":134,"description":135,"createdAt":45,"path":136,"tags":137},"Arrow","ë¹„êµë¥¼ ìœ„í•´ ì•Œì•„ì•¼ í•˜ëŠ” ê±°",[26,35],{"pattern":35,"category":35,"platform":71},"> ðŸ“Œ **Source Code:** [backtracking/prg3-arrow.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/backtracking/prg3-arrow.js)\n\n```js\n// ë¹„êµë¥¼ ìœ„í•´ ì•Œì•„ì•¼ í•˜ëŠ” ê±°\n// 1. infoì˜ ì´í•©\n// 2. infoì—ì„œ ê° ì ìˆ˜ 10~0ì  ëª‡ê°œ ë§žì·„ëŠ”ì§€\n// në°œ ì´ë‚´ì—ì„œ 1ì„ ë„˜ì„ ìˆ˜ ìžˆëŠ”ì§€ ì•Œì•„ì•¼í•¨\n// backtrackì„ í†µí•´ ë‚´ê°€ ì–»ì„ ìˆ˜ ìžˆëŠ” ì ìˆ˜ë¥¼ ê³„ì‚°í•¨\n// 1ì´ˆê³¼ í•˜ê¸° ìœ„í•´ nì„ ì–´ë–»ê²Œ ë°°ë¶„í•´ì•¼í•˜ëŠ”ì§€ ì•Œì•„ì•¼í•¨\n// në°œ ì´ë‚´ì— 1ì„ ë„˜ì„ ìˆ˜ ìžˆë‚˜\n// në°œ ì´ë‚´ì— 1dml\n\n// infoì—ì„œ ìµœê³  ì ìˆ˜ êµ¬í•˜ëŠ” í•¨ìˆ˜\nfunction getTotal(info) {\n  let result = 0;\n  for (let i = 0; i \u003C= info.length - 1; i++) {\n    result += (10 - i) * info[i];\n  }\n  return result;\n}\n\nfunction backtrack(n, info, total) {\n  let remain = n;\n  let myTotal = 0;\n  let result = [];\n  // remainì´ 1ì¼ë•Œê¹Œì§€ ë°˜ë³µ\n\n  for (let i = 0; i \u003C 10; i++) {\n    let myShot = info[i] + 1;\n    let myScore = 10 - i;\n    // ì–¸ì œ ì¶”ê°€í•˜ì§€?\n    // ì ë‹¹ížˆ ë°°ë¶„ë˜ì–´ì•¼í•¨.\n    if (remain \u003C= 0 || total \u003C myTotal) {\n      return result;\n    }\n    console.log(\n      \"inner for remain : \",\n      remain,\n      \"\\n\",\n      \"myShot : \",\n      myShot,\n      \"\\n\",\n      \"myScore : \",\n      myScore,\n      \"\\n\",\n      \"myTotal : \",\n      myTotal,\n    );\n    if (myTotal + myScore \u003C total) {\n      result.push(myShot);\n      myTotal += myScore;\n      remain = remain - myShot;\n    }\n  }\n\n  return [-1];\n}\n\nfunction solution(n, info) {\n  let infoTotal = getTotal(info);\n  let result = backtrack(n, info, infoTotal);\n\n  return result;\n}\n\n// í…ŒìŠ¤íŠ¸ ì‹¤í–‰\nconsole.log(\"result : \", solution(5, [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]));\n```","site/content/algorithms/backtracking/prg3-arrow.mdx","7353993a0c3b9e28","search/leetcode-3-longest-substring",{"id":141,"data":143,"body":149,"filePath":150,"digest":151,"deferredRender":25},{"title":144,"description":145,"createdAt":16,"path":146,"tags":148},"LeetCode 3. Longest Substring Without Repeating Characters","LeetCode problem",[26,34,147],"sliding-window",{"pattern":147,"category":34},"# Topics\n\n- Hash Table\n- String\n- Sliding Window\n\n## ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/surrounded-regions)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ìž¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // ì¤‘ë³µ ë¬¸ìžê°€ ì¡´ìž¬í•˜ë©´ ì•žì—ì„œ ì œê±°í•˜ë©´ì„œ ìœˆë„ìš° ì´ë™\n    /**@note ì´ ë¶€ë¶„ì—ì„œ s[start]ë¡œ startë¥¼ ì›€ì§ì´ê³ , setì—ì„œ ì œê±°í•¨\n     * @note Sliding Windowì˜ ê°€ë³€ í¬ê¸°ê°€ êµ¬í˜„ë¨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // ìƒˆë¡œìš´ ë¬¸ìž ì¶”ê°€\n    /** @note ì—…ë°ì´íŠ¸ ì‹œì ì€ setì˜ ë³€ê²½ ì´í›„ì— ì‹¤í–‰í•¨ **/\n    longest = Math.max(longest, end - start + 1); // ê¸¸ì´ ê°±ì‹ \n  }\n\n  return longest;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ìƒˆë¡œìš´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜\n\nreturnListë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ë ¤ í–ˆìœ¼ë‚˜ next ì¶”ê°€ ë°©ì‹ì´ í‹€ë¦¼.\nì˜¬ë°”ë¥¸ ë°©ì‹ì€ ìƒˆë¡œìš´ ListNodeë¥¼ ìƒì„±í•˜ê³  current.nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\në°˜ë³µë¬¸ì—ì„œ next ì¶”ê°€ ë°©ë²• ë¬¸ì œ\n\nreturnList(start, next)ëŠ” ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ.\ndummyHead ë…¸ë“œë¥¼ ë‘ê³  current í¬ì¸í„°ë¥¼ í™œìš©í•˜ì—¬ nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\n\n2. ë¦¬ìŠ¤íŠ¸ ìˆ«ìž ë³€í™˜ ì˜¤ë¥˜ (getAllNum í•¨ìˆ˜)\n\n```\nwhile (li?.val) â†’ while (li !== null)\nnums.unshift(li.val) ëŒ€ì‹  nums.push(li.val)\njoin(\"\") * 1 ëŒ€ì‹  Number(join(\"\")) ë˜ëŠ” BigInt(join(\"\")) ì‚¬ìš©í•´ì•¼ í° ìˆ«ìž ì²˜ë¦¬ ê°€ëŠ¥.\n\n```\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = -1;\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n    if (!set.has(char)) {\n      set.add(char);\n    } else {\n      longest = Math.max(longest, end - start + 1);\n      start++;\n      // set ì´ˆê¸°í™”? ì—…ë°ì´íŠ¸? ì–´ë–»ê²Œ í•´ì•¼í•˜ì§€.\n    }\n  }\n\n  return longest;\n};\n```","site/content/algorithms/search/leetcode-3-longest-substring.mdx","3698cc47d28aa050","search/leetcode-4-median-of-two-sorted-array",{"id":152,"data":154,"body":160,"filePath":161,"digest":162,"deferredRender":25},{"title":155,"description":156,"createdAt":16,"path":157,"tags":159},"LeetCode 4. Median of Two Sorted Arrays","LeetCode problem 4",[26,34,158],"binary-search",{"pattern":158,"category":34},"# Topics\n\n- Array\n- Binary Search\n- Divide and Conquer\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ìž¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\nì‚¬ì‹¤ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ í’€ì–´ì•¼í•˜ëŠ” ë¬¸ì œì¸ë°,\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  let merged = [...nums1, ...nums2].sort((a, b) => a - b);\n  let size = merged.length,\n    isEven = size % 2 === 0;\n  let pointer = isEven ? Math.floor(size / 2) - 1 : Math.floor(size / 2);\n\n  if (isEven) {\n    return (merged[pointer] + merged[pointer + 1]) / 2;\n  } else {\n    return merged[pointer];\n  }\n};\n```\n\n## ì‚¬ê³  ê³¼ì •\n\nì²˜ìŒì— setìœ¼ë¡œ ì‹œë„í•˜ë ¤ í–ˆìœ¼ë‚˜, í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 44ë²ˆì— ì¤‘ë³µ ìˆ«ìž í—ˆìš©ì´ ê»´ìžˆì–´ì„œ ìˆ˜ì •í•¨.\n\n1. Median ì •ì˜\n   - ìˆ«ìž ì´í•©ì˜ ì¤‘ê°„ ê°’ì¸ì§€, ë§ ê·¸ëŒ€ë¡œ ë°°ì—´ì˜ ê°€ìž¥ ì¤‘ì•™ì„ ëœ»í•˜ëŠ” ì§€ í™•ì¸. í›„ìž.\n   - ë³‘í•©ëœ ë‘ ë°°ì—´ì˜ ê¸¸ì´ê°€ í™€ìˆ˜ ì¼ ë•ŒëŠ” Math.floor(length / 2)ì˜ ì¸ë±ìŠ¤ ê°’\n   - ì§ìˆ˜ì¼ ë•ŒëŠ” Math.floor(length / 2)ì™€ +1ì˜ ìš”ì†Œë¥¼ ë”í•œ ë’¤ / 2\n2. ë‘ ë°°ì—´ì„ í•©í•œ ë’¤ sort = merged - ì¤‘ê°„ ê°’ì˜ íƒìƒ‰ ëŒ€ìƒ\n3. 1ë²ˆì—ì„œ ì¤‘ê°„ ê°’ì´ ë°°ì—´ ê¸¸ì´ì— ë”°ë¼ ë‹¬ë¼ì§ì„ í™•ì¸í•¨. ê·¸ëŒ€ë¡œ ë°˜í™˜ê°’ ê³„ì‚°í•¨\n\n- ì¤‘ë³µ ìš”ì†Œ í—ˆìš©, ë¹„í—ˆìš©ì— ëŒ€í•œ ížŒíŠ¸ê°€ ì—†ì–´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì—ì„œ ì°¾ì•„ëƒ„.","site/content/algorithms/search/leetcode-4-median-of-two-sorted-array.mdx","11bb72a9a98eb9b3","queue/core",{"id":163,"data":165,"body":169,"filePath":170,"digest":171,"deferredRender":25},{"title":166,"description":166,"createdAt":45,"path":167,"tags":168},"Queue",[26,47],{"pattern":49,"category":47},"> ðŸ“Œ **Source Code:** [queue/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/queue/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const head = this.items[this.front];\n    delete this.items[this.front];\n    this.front++;\n    return head;\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n```","site/content/algorithms/queue/core.mdx","44f75e26afbc71bf","search/leetcode-add-two-numbers",{"id":172,"data":174,"body":180,"filePath":181,"digest":182,"deferredRender":25},{"title":175,"description":145,"createdAt":16,"path":176,"tags":179},"Linked List - LeetCode 2. Add Two Numbers",[26,34,177,178],"linked-list","two-pointer",{"pattern":178,"category":34},"[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/add-two-numbers/)\n\n# Topics\n\n- Linked List\n- Math\n- Recursion\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ìž¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ëž‘ í˜„ìž¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n  let carry = 0;\n\n  while (l1 !== null || l2 !== null || carry > 0) {\n    let sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10); // 10ì„ ë„˜ìœ¼ë©´ ì˜¬ë¦¼ê°’ ì €ìž¥\n\n    current.next = new ListNode(sum % 10); // í˜„ìž¬ ë…¸ë“œ ì¶”ê°€\n    current = current.next; // í¬ì¸í„° ì´ë™\n\n    l1 = l1?.next || null;\n    l2 = l2?.next || null;\n  }\n\n  return dummyHead.next; // ì‹¤ì œ ë¦¬ìŠ¤íŠ¸ ì‹œìž‘ì  ë°˜í™˜\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ìƒˆë¡œìš´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜\n\nreturnListë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ë ¤ í–ˆìœ¼ë‚˜ next ì¶”ê°€ ë°©ì‹ì´ í‹€ë¦¼.\nì˜¬ë°”ë¥¸ ë°©ì‹ì€ ìƒˆë¡œìš´ ListNodeë¥¼ ìƒì„±í•˜ê³  current.nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\në°˜ë³µë¬¸ì—ì„œ next ì¶”ê°€ ë°©ë²• ë¬¸ì œ\n\nreturnList(start, next)ëŠ” ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ.\ndummyHead ë…¸ë“œë¥¼ ë‘ê³  current í¬ì¸í„°ë¥¼ í™œìš©í•˜ì—¬ nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\n\n2. ë¦¬ìŠ¤íŠ¸ ìˆ«ìž ë³€í™˜ ì˜¤ë¥˜ (getAllNum í•¨ìˆ˜)\n\n```\nwhile (li?.val) â†’ while (li !== null)\nnums.unshift(li.val) ëŒ€ì‹  nums.push(li.val)\njoin(\"\") * 1 ëŒ€ì‹  Number(join(\"\")) ë˜ëŠ” BigInt(join(\"\")) ì‚¬ìš©í•´ì•¼ í° ìˆ«ìž ì²˜ë¦¬ ê°€ëŠ¥.\n\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  // ë‘ ë¦¬ìŠ¤íŠ¸ì—ì„œ í•©ì„ êµ¬í•¨\n  function getAllNum(list) {\n    let nums = [];\n    let li = list;\n    while (li?.val) {\n      nums.unshift(li.val);\n      li = li.next;\n    }\n    return nums.join(\"\") * 1;\n  }\n\n  let sum = getAllNum(l1) + getAllNum(l2);\n  let result = String(sum)\n    .split(\"\")\n    .map((char) => char * 1);\n\n  console.log(result);\n  const returnList = new ListNode();\n\n  // ë°˜ë³µë¬¸ì—ì„œ ì§€ê¸ˆ ë§í¬ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€, nextë¥¼ ì–´ë–»ê²Œ ì¶”ê°€í•´ì•¼ í•  ì§€ ëª¨ë¥´ê² ìŒ\n  while (result.length > 0) {\n    const start = result.pop();\n    returnList(start, next);\n  }\n};\n```","site/content/algorithms/search/leetcode-add-two-numbers.mdx","0692aaeb8def1589","heap/min-heap",{"id":183,"data":185,"body":191,"filePath":192,"digest":193,"deferredRender":25},{"title":186,"description":187,"createdAt":45,"path":188,"tags":190},"Min Heap","size 0 ì‹œ null ë°˜í™˜",[26,189],"heap",{"pattern":189,"category":189},"> ðŸ“Œ **Source Code:** [heap/min-heap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/heap/min-heap.js)\n\n```js\nclass MinHeap {\n  constructor() {\n    this.items = [];\n  }\n\n  size() {\n    return this.items.length;\n  }\n  swap(a, b) {\n    [this.items[a], this.items[b]] = [this.items[b], this.items[a]];\n  }\n  pop() {\n    // size 0 ì‹œ null ë°˜í™˜\n    if (this.size() \u003C= 0) {\n      return null;\n    }\n\n    // minì´ì—ˆë˜ headì˜ ê°’ë§Œ ì €ìž¥í•¨\n    const min = this.items[0];\n    // ìƒˆë¡œìš´ í—¤ë“œë¡œ ê¼¬ë¦¬ì— ìžˆë˜ ê°’ì„ ë„£ìŒ\n    this.items[0] = this.items[this.size() - 1];\n    // ê·¸ë‹¤ìŒ 0 ì¸ë±ìŠ¤ ìœ„ì—ì„œë¶€í„° ë‚´ë ¤ê°€ë©´ì„œ ì •ë ¬í•¨.\n    this.bubbleDown();\n\n    // ì €ìž¥í•´ë‘” í í—¤ë“œë¥¼ ë°˜í™˜\n    return min;\n  }\n  bubbleDown() {\n    // ìœ„ì—ì„œë¶€í„° ë‚´ë ¤ê°\n    let index = 0;\n\n    // index * 2 + 1 í˜„ìž¬ ì¸ë±ìŠ¤ * 2ì— ì™œ + 1ì¼ê¹Œ?\n    // ë¶€ëª¨ ë…¸ë“œì—ì„œ ì˜¤ë¥¸ìª½ ë…¸ë“œê°€ ê°€ìž¥ í° ìˆ«ìžë¥¼ ë”í•´ì§ \u003C ë§ˆì§€ë§‰ ë…¸ë“œ ì¸ë±ìŠ¤ëž‘ ë¹„êµí•´ì„œ ë” ìž‘ì„ ë•Œê¹Œì§€\n    while (index * 2 + 1 \u003C this.size() - 1) {\n      let leftIndex = index * 2 + 1;\n      let rightIndex = index * 2 + 2;\n      let smallerIndex =\n        // right indexê°€ leftë³´ë‹¤ í•­ìƒ í¬ë‹ˆê¹Œ (+2), ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë³´ë‹¤ ìž‘ì•„ì•¼í•¨\n        rightIndex \u003C this.size() - 1 &&\n        // ì—¬ê¸°ì„œ ë” ìž‘ì€ ìª½ì˜ ë¹„êµ ëŒ€ìƒ ì ìš©ë¨\n        // ì–‘ ì˜† ìžì‹ ì¤‘ì— ë” ìž‘ì€ ìª½ì´ëž‘ ë¶€ëª¨ë¥¼ ë¹„êµí•´ì•¼í•¨.\n        // ì–¸ì œë‚˜ ê°™ê±°ë‚˜ ìž‘ì•„ë„ ë˜ë‚˜?\n        this.items[rightIndex] \u003C= this.items[leftIndex]\n          ? rightIndex\n          : leftIndex;\n      // ì•„ëž˜ê°€ ì¤‘ë‹¨ì \n      if (this.items[index] \u003C= this.tems[smallerIndex]) {\n        break;\n      }\n\n      // í˜„ìž¬ ì¸ë±ìŠ¤ì˜ ê°’ì´ ìžì‹ì˜ ë” ìž‘ì€ìª½ë³´ë‹¤ ë” í° ê²½ìš°\n      // ìŠ¤ì™‘ + ë¡œì»¬ indexë¥¼ ìžì‹ìœ¼ë¡œ ë³€ê²½\n      this.swap(index, smallerIndex);\n      index = smallerIndex;\n    }\n  }\n  push(data) {\n    this.items.push(data);\n    // ë°°ì—´(ìŠ¤íƒ)ì— ë°ì´í„° ë„£ê³ \n    this.bubbleUp();\n    // ë°”ë‹¥ë¶€í„° ì •ë ¬ ì‹œìž‘\n  }\n  bubbleUp() {\n    let index = this.size() - 1;\n    // ë¡œì»¬ ì¸ë±ìŠ¤. ìž‘ì—…ì˜ ì‹œìž‘ì . ì´ê²Œ ë°”ë€Œì–´ì•¼ ë°˜ë³µë¬¸ì´ ë©ˆì¶¤\n    // ë°”ë‹¥ë¶€í„° ì‹œìž‘í•´ì„œ index 0 ì´ìƒì¼ ë•Œê¹Œì§€\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n\n      // Minì˜ bubbleUp ì¡°ê±´ ì¤‘ë‹¨ì .\n      // ë¶€ëª¨ ë…¸ë“œê°€ ê°™ê±°ë‚˜ ë” ìž‘ì„ ë•Œ ë©ˆì¶¤\n      if (this.items[parentIndex] \u003C= this.items[index]) {\n        break;\n      }\n      // ë¶€ëª¨ ë…¸ë“œê°€ ë” í° ê²½ìš° ë°”ê¿”ì•¼í•¨, itemsì˜ ì¸ë±ìŠ¤, ë¶€ëª¨ ì¸ë±ìŠ¤ì˜ ê°’ì„ ë°”ê¿ˆ\n      this.swap(index, parentIndex);\n      // ë¡œì»¬ ì¸ë±ìŠ¤ë¥¼ ë¶€ëª¨ë¡œ ë°”ê¿ˆ (tail - 1 / 2)\n      index = parentIndex;\n    }\n  }\n}\n```","site/content/algorithms/heap/min-heap.mdx","0e88322b57052951","hash/prg1-race",{"id":194,"data":196,"body":203,"filePath":204,"digest":205,"deferredRender":25},{"title":197,"description":198,"createdAt":199,"path":200,"tags":202},"Race","programmers ë‹¬ë¦¬ê¸° ë¬¸ì œ","2025-01",[26,201],"hash",{"pattern":201,"category":201,"platform":71},"- ìˆ˜ë§Žì€ ë§ˆë¼í†¤ ì„ ìˆ˜ë“¤ì´ ë§ˆë¼í†¤ì— ì°¸ì—¬í•˜ì˜€ìŠµë‹ˆë‹¤. ë‹¨ í•œ ëª…ì˜ ì„ ìˆ˜ë¥¼ ì œì™¸í•˜ê³ ëŠ” ëª¨ë“  ì„ ìˆ˜ê°€ ë§ˆë¼í†¤ì„ ì™„ì£¼í•˜ì˜€ìŠµë‹ˆë‹¤.\n- ë§ˆë¼í†¤ì— ì°¸ì—¬í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ participantì™€ ì™„ì£¼í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ completionì´ ì£¼ì–´ì§ˆ ë•Œ,\n- ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ì˜ ì´ë¦„ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ìž‘ì„±í•´ì£¼ì„¸ìš”.\n\n- ì œí•œì‚¬í•­\n- ë§ˆë¼í†¤ ê²½ê¸°ì— ì°¸ì—¬í•œ ì„ ìˆ˜ì˜ ìˆ˜ëŠ” 1ëª… ì´ìƒ 100,000ëª… ì´í•˜ìž…ë‹ˆë‹¤.\n- completionì˜ ê¸¸ì´ëŠ” participantì˜ ê¸¸ì´ë³´ë‹¤ 1 ìž‘ìŠµë‹ˆë‹¤.\n- ì°¸ê°€ìžì˜ ì´ë¦„ì€ 1ê°œ ì´ìƒ 20ê°œ ì´í•˜ì˜ ì•ŒíŒŒë²³ ì†Œë¬¸ìžë¡œ ì´ë£¨ì–´ì ¸ ìžˆìŠµë‹ˆë‹¤.\n- ì°¸ê°€ìž ì¤‘ì—ëŠ” ë™ëª…ì´ì¸ì´ ìžˆì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\n- ìž…ì¶œë ¥ ì˜ˆ\n\n|participant | completion | return |\n| [\"leo\", \"kiki\", \"eden\"] | [\"eden\", \"kiki\"]| \"leo\" |\n| [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"] | [\"josipa\", \"filipa\", \"marina\", \"nikola\"] | \"vinko\" |\n| [\"mislav\", \"stanko\", \"mislav\", \"ana\"] | [\"stanko\", \"ana\", \"mislav\"] | \"mislav\" |\n\n- ìž…ì¶œë ¥ ì˜ˆ ì„¤ëª…\n  ì˜ˆì œ #1\n  \"leo\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #2\n\"vinko\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #3\n\"mislav\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ë‘ ëª…ì´ ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” í•œ ëª…ë°–ì— ì—†ê¸° ë•Œë¬¸ì— í•œëª…ì€ ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\n> ðŸ“Œ **Source Code:** [hash/prg1-race.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg1-race.js)\n\n```js\n/*\n*\n* ìˆ˜ë§Žì€ ë§ˆë¼í†¤ ì„ ìˆ˜ë“¤ì´ ë§ˆë¼í†¤ì— ì°¸ì—¬í•˜ì˜€ìŠµë‹ˆë‹¤. ë‹¨ í•œ ëª…ì˜ ì„ ìˆ˜ë¥¼ ì œì™¸í•˜ê³ ëŠ” ëª¨ë“  ì„ ìˆ˜ê°€ ë§ˆë¼í†¤ì„ ì™„ì£¼í•˜ì˜€ìŠµë‹ˆë‹¤.\n* ë§ˆë¼í†¤ì— ì°¸ì—¬í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ participantì™€ ì™„ì£¼í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ completionì´ ì£¼ì–´ì§ˆ ë•Œ,\n* ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ì˜ ì´ë¦„ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ìž‘ì„±í•´ì£¼ì„¸ìš”.\n\n* ì œí•œì‚¬í•­\n* ë§ˆë¼í†¤ ê²½ê¸°ì— ì°¸ì—¬í•œ ì„ ìˆ˜ì˜ ìˆ˜ëŠ” 1ëª… ì´ìƒ 100,000ëª… ì´í•˜ìž…ë‹ˆë‹¤.\n* completionì˜ ê¸¸ì´ëŠ” participantì˜ ê¸¸ì´ë³´ë‹¤ 1 ìž‘ìŠµë‹ˆë‹¤.\n* ì°¸ê°€ìžì˜ ì´ë¦„ì€ 1ê°œ ì´ìƒ 20ê°œ ì´í•˜ì˜ ì•ŒíŒŒë²³ ì†Œë¬¸ìžë¡œ ì´ë£¨ì–´ì ¸ ìžˆìŠµë‹ˆë‹¤.\n* ì°¸ê°€ìž ì¤‘ì—ëŠ” ë™ëª…ì´ì¸ì´ ìžˆì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\n* ìž…ì¶œë ¥ ì˜ˆ\nparticipant\tcompletion\treturn\n[\"leo\", \"kiki\", \"eden\"]\t[\"eden\", \"kiki\"]\t\"leo\"\n[\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"]\t[\"josipa\", \"filipa\", \"marina\", \"nikola\"]\t\"vinko\"\n[\"mislav\", \"stanko\", \"mislav\", \"ana\"]\t[\"stanko\", \"ana\", \"mislav\"]\t\"mislav\"\n\n* ìž…ì¶œë ¥ ì˜ˆ ì„¤ëª…\nì˜ˆì œ #1\n\"leo\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #2\n\"vinko\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #3\n\"mislav\"ëŠ” ì°¸ì—¬ìž ëª…ë‹¨ì—ëŠ” ë‘ ëª…ì´ ìžˆì§€ë§Œ, ì™„ì£¼ìž ëª…ë‹¨ì—ëŠ” í•œ ëª…ë°–ì— ì—†ê¸° ë•Œë¬¸ì— í•œëª…ì€ ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n*\n* */\n\nfunction solution(participant, completion) {\n  let obj = {};\n  for (let p of participant) {\n    obj[p] = !!obj[p] ? obj[p] + 1 : 1;\n  }\n\n  for (let i = 0; i \u003C completion.length; i++) {\n    if (obj[completion[i]] === undefined) {\n      continue;\n    }\n    obj[completion[i]] = obj[completion[i]] - 1;\n  }\n  console.log(\"obj\", obj);\n\n  const entries = Object.entries(obj);\n  console.log(\"entries\", entries);\n  for ([name, complete] of entries) {\n    if (complete > 0) {\n      return name;\n    }\n  }\n}\n\nlet test1P = [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"];\nlet test1C = [\"josipa\", \"filipa\", \"marina\", \"nikola\"];\nlet test2P = [\"mislav\", \"stanko\", \"mislav\", \"ana\"];\nlet test2C = [\"stanko\", \"ana\", \"mislav\"];\n\nconsole.log(\"result : \", solution(test1P, test1C));\nconsole.log(\"result : \", solution(test2P, test2C));\n```","site/content/algorithms/hash/prg1-race.mdx","699490a2e57bd862","link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ",{"id":206,"data":208,"body":213,"filePath":214,"digest":215,"deferredRender":25},{"title":209,"description":209,"createdAt":45,"path":210,"tags":212},"ì–‘ë°©í–¥ ê³µë¬¸ì œ",[26,211],"link-list",{"pattern":211,"category":211},"> ðŸ“Œ **Source Code:** [link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.js)\n\n```js\nconst solution = (balls, orders) => {\n  let head = 0;\n  let tail = balls.length - 1;\n  let result = [];\n  let wait = new Set();\n  const next = 1;\n  const prev = -1;\n\n  for (let i = 0; i \u003C orders.length; i++) {\n    if (orders[i] === balls[head]) {\n      console.log(`head : ${balls[head]}`);\n      result.push(orders[i]);\n      head++;\n      while (wait.has(orders[i] + next)) {\n        result.push(orders[i] + next);\n        wait.delete(orders[i] + next);\n        head++;\n      }\n    } else if (orders[i] === balls[tail]) {\n      result.push(orders[i]);\n      if (wait.has(orders[i] + prev)) {\n        while (wait.has(orders[i] + prev)) {\n          result.push(orders[i] + prev);\n          wait.delete(orders[i] + prev);\n          tail--;\n        }\n      }\n      tail--;\n    } else {\n      wait.add(orders[i]);\n    }\n  }\n  return result;\n};\n\nconsole.log(\n  \"result : \",\n  solution([1, 2, 3, 4, 5, 6, 7], [7, 5, 6, 4, 2, 1, 3]),\n);\n```","site/content/algorithms/link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.mdx","84c4fd90385db26a","hash/prg3-discount",{"id":216,"data":218,"body":223,"filePath":224,"digest":225,"deferredRender":25},{"title":219,"description":220,"createdAt":45,"path":221,"tags":222},"Discount","Prg3 Discount",[26,201],{"pattern":201,"category":201,"platform":71},"> ðŸ“Œ **Source Code:** [hash/prg3-discount.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg3-discount.js)\n\n```js\nfunction solution(want, number, discount) {\n  const max = 10;\n  let result = 0;\n  let obj = {};\n\n  for (let i = 0; i \u003C want.length; i++) {\n    obj[want[i]] = !!obj[want[i]] ? obj[want[i]] + number[i] : number[i];\n  }\n\n  for (let i = 0; i \u003C discount.length; i++) {\n    let cart = { ...obj };\n    console.log(\"outer i\", i);\n    console.log(\"discount i\", discount[i]);\n    for (j = i; j \u003C max + i; j++) {\n      console.log(`\n      inner j : ${j}\n      ${discount[j]} :  ${cart[discount[j]]} left\n      `);\n\n      if (!cart[discount[j]]) {\n        continue;\n      }\n      cart[discount[j]] = cart[discount[j]] - 1;\n      console.log(`\n      inner j after\n      ${discount[j]} :  ${cart[discount[j]]}\n      cart: ${Object.entries(cart)}\n      `);\n    }\n    let cartResult = Object.values(cart);\n    let cartAllZero = cartResult.every((item) => item \u003C= 0);\n    console.log(`\n    ${i} index\n    ====================\n    cartResult : ${JSON.stringify(cartResult)} \n    cartAllZero : ${cartAllZero}\n    `);\n    if (cartAllZero) {\n      result++;\n    }\n  }\n\n  return result;\n}\n\nlet test1W = [\"banana\", \"apple\", \"rice\", \"pork\", \"pot\"];\nlet test1N = [3, 2, 2, 2, 1];\nlet test1D = [\n  \"chicken\",\n  \"apple\",\n  \"apple\",\n  \"banana\",\n  \"rice\",\n  \"apple\",\n  \"pork\",\n  \"banana\",\n  \"pork\",\n  \"rice\",\n  \"pot\",\n  \"banana\",\n  \"apple\",\n  \"banana\",\n];\n\nconsole.log(\"result : \", solution(test1W, test1N, test1D));\n```","site/content/algorithms/hash/prg3-discount.mdx","fec40944e54eb9ed","hash/prg6-bestmusic",{"id":226,"data":228,"body":233,"filePath":234,"digest":235,"deferredRender":25},{"title":229,"description":230,"createdAt":45,"path":231,"tags":232},"Best Music","ë² ìŠ¤íŠ¸ ì•¨ë²” ë¬¸ì œ",[26,201],{"pattern":201,"category":201,"platform":71},"## ë¬¸ì œ\n\nìŠ¤íŠ¸ë¦¬ë° ì‚¬ì´íŠ¸ì—ì„œ ìž¥ë¥´ ë³„ë¡œ ê°€ìž¥ ë§Žì´ ìž¬ìƒëœ ë…¸ëž˜ë¥¼ ë‘ ê°œì”© ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë ¤ í•©ë‹ˆë‹¤.\në…¸ëž˜ëŠ” ê³ ìœ  ë²ˆí˜¸ë¡œ êµ¬ë¶„í•˜ë©°, ë…¸ëž˜ë¥¼ ìˆ˜ë¡í•˜ëŠ” ê¸°ì¤€ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nì†í•œ ë…¸ëž˜ê°€ ë§Žì´ ìž¬ìƒëœ ìž¥ë¥´ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nìž¥ë¥´ ë‚´ì—ì„œ ë§Žì´ ìž¬ìƒëœ ë…¸ëž˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nìž¥ë¥´ ë‚´ì—ì„œ ìž¬ìƒ íšŸìˆ˜ê°€ ê°™ì€ ë…¸ëž˜ ì¤‘ì—ì„œëŠ” ê³ ìœ  ë²ˆí˜¸ê°€ ë‚®ì€ ë…¸ëž˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\në…¸ëž˜ì˜ ìž¥ë¥´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ìžì—´ ë°°ì—´ genresì™€ ë…¸ëž˜ë³„ ìž¬ìƒ íšŸìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ë°°ì—´ playsê°€ ì£¼ì–´ì§ˆ ë•Œ,\në² ìŠ¤íŠ¸ ì•¨ë²”ì— ë“¤ì–´ê°ˆ ë…¸ëž˜ì˜ ê³ ìœ  ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.\n\n### ì œí•œì‚¬í•­\n\ngenres[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ëž˜ì˜ ìž¥ë¥´ìž…ë‹ˆë‹¤.\nplays[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ëž˜ê°€ ìž¬ìƒëœ íšŸìˆ˜ìž…ë‹ˆë‹¤.\ngenresì™€ playsì˜ ê¸¸ì´ëŠ” ê°™ìœ¼ë©°, ì´ëŠ” 1 ì´ìƒ 10,000 ì´í•˜ìž…ë‹ˆë‹¤.\nìž¥ë¥´ ì¢…ë¥˜ëŠ” 100ê°œ ë¯¸ë§Œìž…ë‹ˆë‹¤.\nìž¥ë¥´ì— ì†í•œ ê³¡ì´ í•˜ë‚˜ë¼ë©´, í•˜ë‚˜ì˜ ê³¡ë§Œ ì„ íƒí•©ë‹ˆë‹¤.\nëª¨ë“  ìž¥ë¥´ëŠ” ìž¬ìƒëœ íšŸìˆ˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤.\n\n> ðŸ“Œ **Source Code:** [hash/prg6-bestmusic.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg6-bestmusic.js)\n\n```js\n/*\në¬¸ì œ ì„¤ëª…\nìŠ¤íŠ¸ë¦¬ë° ì‚¬ì´íŠ¸ì—ì„œ ìž¥ë¥´ ë³„ë¡œ ê°€ìž¥ ë§Žì´ ìž¬ìƒëœ ë…¸ëž˜ë¥¼ ë‘ ê°œì”© ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë ¤ í•©ë‹ˆë‹¤.\në…¸ëž˜ëŠ” ê³ ìœ  ë²ˆí˜¸ë¡œ êµ¬ë¶„í•˜ë©°, ë…¸ëž˜ë¥¼ ìˆ˜ë¡í•˜ëŠ” ê¸°ì¤€ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nì†í•œ ë…¸ëž˜ê°€ ë§Žì´ ìž¬ìƒëœ ìž¥ë¥´ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nìž¥ë¥´ ë‚´ì—ì„œ ë§Žì´ ìž¬ìƒëœ ë…¸ëž˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nìž¥ë¥´ ë‚´ì—ì„œ ìž¬ìƒ íšŸìˆ˜ê°€ ê°™ì€ ë…¸ëž˜ ì¤‘ì—ì„œëŠ” ê³ ìœ  ë²ˆí˜¸ê°€ ë‚®ì€ ë…¸ëž˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\në…¸ëž˜ì˜ ìž¥ë¥´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ìžì—´ ë°°ì—´ genresì™€ ë…¸ëž˜ë³„ ìž¬ìƒ íšŸìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ë°°ì—´ playsê°€ ì£¼ì–´ì§ˆ ë•Œ,\në² ìŠ¤íŠ¸ ì•¨ë²”ì— ë“¤ì–´ê°ˆ ë…¸ëž˜ì˜ ê³ ìœ  ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.\n\nì œí•œì‚¬í•­\ngenres[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ëž˜ì˜ ìž¥ë¥´ìž…ë‹ˆë‹¤.\nplays[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ëž˜ê°€ ìž¬ìƒëœ íšŸìˆ˜ìž…ë‹ˆë‹¤.\ngenresì™€ playsì˜ ê¸¸ì´ëŠ” ê°™ìœ¼ë©°, ì´ëŠ” 1 ì´ìƒ 10,000 ì´í•˜ìž…ë‹ˆë‹¤.\nìž¥ë¥´ ì¢…ë¥˜ëŠ” 100ê°œ ë¯¸ë§Œìž…ë‹ˆë‹¤.\nìž¥ë¥´ì— ì†í•œ ê³¡ì´ í•˜ë‚˜ë¼ë©´, í•˜ë‚˜ì˜ ê³¡ë§Œ ì„ íƒí•©ë‹ˆë‹¤.\nëª¨ë“  ìž¥ë¥´ëŠ” ìž¬ìƒëœ íšŸìˆ˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤.\nìž…ì¶œë ¥ ì˜ˆ\ngenres\tplays\treturn\n[\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"]\t[500, 600, 150, 800, 2500]\t[4, 1, 3, 0]\nìž…ì¶œë ¥ ì˜ˆ ì„¤ëª…\nclassic ìž¥ë¥´ëŠ” 1,450íšŒ ìž¬ìƒë˜ì—ˆìœ¼ë©°, classic ë…¸ëž˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nê³ ìœ  ë²ˆí˜¸ 3: 800íšŒ ìž¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 0: 500íšŒ ìž¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 2: 150íšŒ ìž¬ìƒ\npop ìž¥ë¥´ëŠ” 3,100íšŒ ìž¬ìƒë˜ì—ˆìœ¼ë©°, pop ë…¸ëž˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nê³ ìœ  ë²ˆí˜¸ 4: 2,500íšŒ ìž¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 1: 600íšŒ ìž¬ìƒ\në”°ë¼ì„œ pop ìž¥ë¥´ì˜ [4, 1]ë²ˆ ë…¸ëž˜ë¥¼ ë¨¼ì €, classic ìž¥ë¥´ì˜ [3, 0]ë²ˆ ë…¸ëž˜ë¥¼ ê·¸ë‹¤ìŒì— ìˆ˜ë¡í•©ë‹ˆë‹¤.\n\nìž¥ë¥´ ë³„ë¡œ ê°€ìž¥ ë§Žì´ ìž¬ìƒëœ ë…¸ëž˜ë¥¼ ìµœëŒ€ ë‘ ê°œê¹Œì§€ ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë¯€ë¡œ 2ë²ˆ ë…¸ëž˜ëŠ” ìˆ˜ë¡ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n* */\n\nfunction solution(genres, plays) {\n  let totalObj = {};\n  let pObj = {};\n  let result = [];\n\n  for (let i = 0; i \u003C genres.length; i++) {\n    totalObj[genres[i]] = !!totalObj[genres[i]]\n      ? totalObj[genres[i]] + plays[i]\n      : plays[i];\n    pObj[genres[i]] = [...(pObj[genres[i]] ?? []), [i, plays[i]]];\n  }\n\n  let playEntries = Object.entries(pObj);\n  let totalEntries = Object.entries(totalObj).sort((a, b) => b[1] - a[1]);\n  let totalRank = totalEntries.map(([g]) => g);\n\n  for (let genre in pObj) {\n    pObj[genre] = pObj[genre]\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 2)\n      .map(([name]) => name);\n  }\n\n  console.log(`pObj: ${Object.entries(pObj)}`);\n\n  console.log(\"totalEntries\", totalEntries);\n  console.log(\"playEntries\", playEntries);\n\n  for (let i = 0; i \u003C totalRank.length; i++) {\n    let songsIndex = pObj[totalRank[i]];\n    console.log(\"songsIndex\", songsIndex);\n    result.push(songsIndex);\n  }\n  return result.flat();\n}\n\nlet test1G = [\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"];\nlet test1P = [500, 600, 150, 800, 2500];\n\nconsole.log(\"result : \", solution(test1G, test1P));\n```","site/content/algorithms/hash/prg6-bestmusic.mdx","76f1f1541aa06c0f","hash/prg7-report",{"id":236,"data":238,"body":243,"filePath":244,"digest":245,"deferredRender":25},{"title":239,"description":240,"createdAt":45,"path":241,"tags":242},"Report","Prg7 Report",[26,201],{"pattern":201,"category":201,"platform":71},"> ðŸ“Œ **Source Code:** [hash/prg7-report.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/prg7-report.js)\n\n```js\nfunction solution(id_list, report, k) {\n  let reported = {};\n  let reporter = {};\n  let count = {};\n\n  for (let id of id_list) {\n    reported[id] = 0;\n    reporter[id] = [];\n    count[id] = 0;\n  }\n\n  const reportArr = [...new Set(report)].map((item) => item.split(\" \"));\n  for (const [rp, user] of reportArr) {\n    reported[user] += 1;\n    reporter[rp] = [...reporter[rp], user];\n    console.log(`\n    ì‹ ê³ ìž : ${rp} \n    ìœ„ë°˜ìž : ${user} \n    ì‹ ê³ ë‹¹í•œ íšŸìˆ˜ : ${reported[user]}`);\n  }\n\n  const bannedArr = Object.entries(reported).filter(([, count]) => count >= k);\n\n  for (const [bannedUser] of bannedArr) {\n    for (const rUser in reporter) {\n      console.log(\"bannedUser in 2 for\", bannedUser);\n      console.log(\"reporter in 2 for\", rUser);\n\n      if (reporter[rUser].includes(bannedUser)) {\n        count[rUser] += 1;\n      }\n    }\n  }\n  console.log(\"reported\", reported);\n  console.log(\"reporter\", reporter);\n  console.log(\"bannedArr\", bannedArr);\n  console.log(\"count\", count);\n\n  let result = Object.values(count);\n  return result;\n}\n\nlet id_list1 = [\"muzi\", \"frodo\", \"apeach\", \"neo\"];\nlet report1 = [\n  \"muzi frodo\",\n  \"apeach frodo\",\n  \"frodo neo\",\n  \"muzi neo\",\n  \"apeach muzi\",\n];\nlet k1 = 2;\n\nconsole.log(\"result : \", solution(id_list1, report1, k1));\n```","site/content/algorithms/hash/prg7-report.mdx","c2fa03e49a1440ac","hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°",{"id":246,"data":248,"body":253,"filePath":254,"digest":255,"deferredRender":25},{"title":249,"description":250,"createdAt":45,"path":251,"tags":252},"ì—°ìŠµ1 ë‘ìˆ˜ë”í•˜ê¸°","* ë¬¸ì œ: arrì˜ ë‘ ìˆ˜ë¥¼ ë”í•˜ì—¬ targetì„ ë§Œë“¤ ìˆ˜ ìžˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë°˜í™˜ * arrì€ ìµœëŒ€ 10^4 O(n) * *",[26,201],{"pattern":201,"category":201},"> ðŸ“Œ **Source Code:** [hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.js)\n\n```js\n/*\n * ë¬¸ì œ: arrì˜ ë‘ ìˆ˜ë¥¼ ë”í•˜ì—¬ targetì„ ë§Œë“¤ ìˆ˜ ìžˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë°˜í™˜\n * arrì€ ìµœëŒ€ 10^4 O(n)\n *\n * */\n\nfunction solution(arr, target) {\n  let k = new Set();\n  for (let i = 0; i \u003C arr.length; i++) {\n    k.add(target - arr[i]);\n  }\n\n  for (let i = 0; i \u003C arr.length; i++) {\n    let comple = target - arr[i];\n    if (k.has(arr[i]) && comple > 0 && comple !== arr[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconsole.log(\"result\", solution([1, 2, 3, 4, 8], 6));\nconsole.log(\"result\", solution([2, 3, 5, 9], 10));\n```","site/content/algorithms/hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.mdx","b17236be9485cfec","set/prg3-phone_book",{"id":256,"data":258,"body":264,"filePath":265,"digest":266,"deferredRender":25},{"title":259,"description":260,"createdAt":45,"path":261,"tags":263},"Phone Book","Prg3 Phone Book",[26,262],"set",{"pattern":262,"category":262,"platform":71},"> ðŸ“Œ **Source Code:** [set/prg3-phone_book.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg3-phone_book.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg3-phone_book.mdx","6bdd069a76da8a34","hash/ì—°ìŠµ2-ë¬¸ìžì—´ë¹„êµ",{"id":267,"data":269,"body":274,"filePath":275,"digest":276,"deferredRender":25},{"title":270,"description":271,"createdAt":45,"path":272,"tags":273},"ì—°ìŠµ2 ë¬¸ìžì—´ë¹„êµ","* ë¬¸ì œ: queryListê°€ strListì— ìžˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜ * arrì€ ìµœëŒ€ 10^4 O(n) * *",[26,201],{"pattern":201,"category":201},"# ë¬¸ì œ: queryListê°€ strListì— ìžˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜\n\n- arrì€ ìµœëŒ€ 10^4 O(n)\n\n> ðŸ“Œ **Source Code:** [hash/ì—°ìŠµ2-ë¬¸ìžì—´ë¹„êµ.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/hash/ì—°ìŠµ2-ë¬¸ìžì—´ë¹„êµ.js)\n\n```js\n/*\n * ë¬¸ì œ: queryListê°€ strListì— ìžˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜\n * arrì€ ìµœëŒ€ 10^4 O(n)\n *\n * */\n\nfunction solution(strList, queryList) {\n  let result = [];\n  let strObj = new Set();\n\n  for (let i = 0; i \u003C strList.length; i++) {\n    strObj.add(strList[i]);\n  }\n\n  for (let i = 0; i \u003C queryList.length; i++) {\n    if (strObj.has(queryList[i])) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result;\n}\n\nlet test1SL = [\"apple\", \"banana\", \"cherry\"];\nlet test1QL = [\"banana\", \"kiwi\", \"melon\", \"apple\"];\nlet test2SL = [\"a\", \"b\", \"Q\"];\nlet test2QL = [\"c\", \"d\", \"e\", \"A\", \"a\", \"b\", \"Z\", \"Q\"];\n\nconsole.log(\"result\", solution(test1SL, test1QL));\nconsole.log(\"result\", solution(test2SL, test2QL));\n```","site/content/algorithms/hash/ì—°ìŠµ2-ë¬¸ìžì—´ë¹„êµ.mdx","b851ea55417dcd6b","set/prg1-pokemon",{"id":277,"data":279,"body":284,"filePath":285,"digest":286,"deferredRender":25},{"title":280,"description":281,"createdAt":45,"path":282,"tags":283},"Pokemon","Prg1 Pokemon",[26,262],{"pattern":262,"category":262,"platform":71},"> ðŸ“Œ **Source Code:** [set/prg1-pokemon.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg1-pokemon.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg1-pokemon.mdx","e759c6306529263e","set/prg4-students",{"id":287,"data":289,"body":294,"filePath":295,"digest":296,"deferredRender":25},{"title":290,"description":291,"createdAt":45,"path":292,"tags":293},"Students","ì—¬ë²Œ ë‚˜ëˆ” ê³„ì‚°",[26,262],{"pattern":262,"category":262,"platform":71},"> ðŸ“Œ **Source Code:** [set/prg4-students.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg4-students.js)\n\n```js\nfunction solution(n, lost, reserve) {\n  let students = {};\n  for (let i = 1; i \u003C= n; i++) {\n    students[i] = 1;\n  }\n\n  for (let r = 0; r \u003C reserve.length; r++) {\n    let num = reserve[r];\n    students[num] += 1;\n  }\n\n  for (let l = 0; l \u003C lost.length; l++) {\n    let num = lost[l];\n    students[num] -= 1;\n  }\n\n  // ì—¬ë²Œ ë‚˜ëˆ” ê³„ì‚°\n  // lost ë¹¼ê³  ë‚˜ì„œ ë‚˜ë¨¸ì§€ í•™ìƒë“¤ ì¤‘ 0ì¸ í•™ìƒë§Œ ì°¾ì•„ì„œ\n  // ì•ž ë’¤ë¡œ 1 ì´ìƒì¼ ì‹œ ê³µìœ í•¨\n  for (let sKey in students) {\n    if (students[sKey] === 0) {\n      let next = Number(sKey) + 1;\n      let prev = Number(sKey) - 1;\n\n      if (prev > 0 && students[prev] > 1) {\n        students[prev] = students[prev] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n\n      if (next \u003C= n && students[next] > 1) {\n        students[next] = students[next] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n    }\n  }\n\n  const result = Object.values(students).filter((item) => item > 0);\n  return result.length;\n}\n\nconsole.log(\"result : \", solution(5, [2, 4], [1, 3, 5]));\nconsole.log(\"result : \", solution(5, [2, 4], [3]));\nconsole.log(\"result : \", solution(3, [3], [1]));\n```","site/content/algorithms/set/prg4-students.mdx","efa675834d961c8a","set/prg2-words",{"id":297,"data":299,"body":304,"filePath":305,"digest":306,"deferredRender":25},{"title":300,"description":301,"createdAt":45,"path":302,"tags":303},"Words","Prg2 Words",[26,262],{"pattern":262,"category":262,"platform":71},"> ðŸ“Œ **Source Code:** [set/prg2-words.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg2-words.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg2-words.mdx","5b61aad4b9b63403","set/prg5-islands",{"id":307,"data":309,"body":314,"filePath":315,"digest":316,"deferredRender":25},{"title":310,"description":311,"createdAt":45,"path":312,"tags":313},"Islands","parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜",[26,262],{"pattern":262,"category":262,"platform":71},"> ðŸ“Œ **Source Code:** [set/prg5-islands.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg5-islands.js)\n\n```js\n// parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜\n// ë£¨íŠ¸ ë…¸ë“œëž€ ì§‘í•©ì˜ ëŒ€í‘œìž (ì¦‰, ìµœìƒìœ„ ë¶€ëª¨ ë…¸ë“œ)\n// ê²½ë¡œ ì••ì¶•ì„ í†µí•´ íƒìƒ‰ ê²½ë¡œë¥¼ ìµœì í™”\nfunction find(parents, x) {\n  // xê°€ ìžì‹ ì˜ ë¶€ëª¨ ë…¸ë“œë¼ë©´ (ì¦‰, ë£¨íŠ¸ ë…¸ë“œë¼ë©´)\n  if (parents[x] == x) {\n    return x; // ë£¨íŠ¸ ë…¸ë“œ ë°˜í™˜\n  }\n  // xê°€ ë£¨íŠ¸ê°€ ì•„ë‹ˆë©´, ìž¬ê·€ í˜¸ì¶œì„ í†µí•´ ë£¨íŠ¸ë¥¼ ì°¾ìŒ\n  // ì°¾ìœ¼ë©´ì„œ ë¶€ëª¨ë¥¼ ë£¨íŠ¸ë¡œ ê°±ì‹  (ê²½ë¡œ ì••ì¶•)\n  parents[x] = find(parents, parents[x]);\n  return parents[x]; // ìµœì¢… ë£¨íŠ¸ ë°˜í™˜\n}\n\n// ë‘ ë…¸ë“œì˜ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜ (Union by Rank)\n// RankëŠ” íŠ¸ë¦¬ì˜ ê¹Šì´ë¥¼ ì˜ë¯¸í•˜ë©°, ë” ë‚®ì€ íŠ¸ë¦¬ë¥¼ ë†’ì€ íŠ¸ë¦¬ì— ë¶™ìž„\nfunction union(parent, rank, x, y) {\n  const xroot = find(parent, x); // xì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n  const yroot = find(parent, y); // yì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n\n  // Rankë¥¼ ë¹„êµí•˜ì—¬ íŠ¸ë¦¬ì˜ ê· í˜• ìœ ì§€\n  if (rank[xroot] \u003C rank[yroot]) {\n    parent[xroot] = yroot; // xroot íŠ¸ë¦¬ë¥¼ yrootì— ì—°ê²°\n  } else if (rank[xroot] > rank[yroot]) {\n    parent[yroot] = xroot; // yroot íŠ¸ë¦¬ë¥¼ xrootì— ì—°ê²°\n  } else {\n    // ëž­í¬ê°€ ê°™ë‹¤ë©´ xrootë¥¼ ë¶€ëª¨ë¡œ ì„¤ì •í•˜ê³ , ëž­í¬ë¥¼ 1 ì¦ê°€\n    parent[yroot] = xroot;\n    rank[xroot] += 1;\n  }\n}\n\n// ìµœì†Œ ì‹ ìž¥ íŠ¸ë¦¬ (MST) ë¹„ìš© ê³„ì‚° í•¨ìˆ˜\nfunction solution(n, costs) {\n  // 1. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬\n  costs.sort((a, b) => a[2] - b[2]); // MSTë¥¼ ìœ„í•´ ê°€ìž¥ ë‚®ì€ ë¹„ìš©ì˜ ê°„ì„ ì„ ë¨¼ì € ì²˜ë¦¬\n\n  // 2. parent ë°°ì—´ê³¼ rank ë°°ì—´ ì´ˆê¸°í™”\n  // ê° ë…¸ë“œëŠ” ì²˜ìŒì—” ìžê¸° ìžì‹ ì´ ë£¨íŠ¸ì¸ ë…ë¦½ ì§‘í•©\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0); // ëª¨ë“  ë…¸ë“œì˜ ì´ˆê¸° RankëŠ” 0\n\n  let minCost = 0; // MSTì˜ ì´ ë¹„ìš©\n  let edges = 0; // í˜„ìž¬ê¹Œì§€ MSTì— í¬í•¨ëœ ê°„ì„ ì˜ ìˆ˜\n\n  // 3. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° MSTë¥¼ êµ¬ì„±\n  for (const edge of costs) {\n    if (edges == n - 1) {\n      // MSTì˜ ê°„ì„  ìˆ˜ê°€ n-1ì´ë©´ ì¤‘ë‹¨\n      break;\n    }\n    // edge = [ë…¸ë“œ1, ë…¸ë“œ2, ë¹„ìš©]\n    const x = find(parent, edge[0]); // ë…¸ë“œ1ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n    const y = find(parent, edge[1]); // ë…¸ë“œ2ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n\n    if (x !== y) {\n      // ë‘ ë…¸ë“œê°€ ê°™ì€ ì§‘í•©ì— ì†í•˜ì§€ ì•Šìœ¼ë©´ ì—°ê²°\n      union(parent, rank, x, y); // ë‘ ë…¸ë“œë¥¼ ê°™ì€ ì§‘í•©ìœ¼ë¡œ ë¬¶ìŒ\n      minCost += edge[2]; // ê°„ì„ ì˜ ë¹„ìš©ì„ ì´ ë¹„ìš©ì— ì¶”ê°€\n      edges += 1; // ê°„ì„  ìˆ˜ ì¦ê°€\n    }\n    // ë‘ ë…¸ë“œê°€ ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ì—°ê²°í•˜ì§€ ì•ŠìŒ (ì‚¬ì´í´ ë°©ì§€)\n  }\n\n  return minCost; // MSTì˜ ìµœì†Œ ë¹„ìš© ë°˜í™˜\n}\n\n// ì˜ˆì œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤\nconsole.log(\n  \"result : \",\n  solution(4, [\n    [0, 1, 1],\n    [0, 2, 2],\n    [1, 2, 5],\n    [1, 3, 1],\n    [2, 3, 8],\n  ]),\n);\n// ê²°ê³¼: 4 (MSTì˜ ìµœì†Œ ë¹„ìš©)\n```","site/content/algorithms/set/prg5-islands.mdx","4bad9e97131d03a5","simulation/pr1-rotateclock",{"id":317,"data":319,"body":325,"filePath":326,"digest":327,"deferredRender":25},{"title":320,"description":321,"createdAt":45,"path":322,"tags":324},"Pr1 Rotateclock","ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜",[26,323],"simulation",{"pattern":323,"category":323},"ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜\n\n> ðŸ“Œ **Source Code:** [simulation/pr1-rotateclock.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr1-rotateclock.js)\n\n```js\n// ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜\n\nfunction rotate(arr) {\n  let result = Array.from({ length: arr.length }, () =>\n    Array(arr.length).fill(0),\n  );\n  for (let i = 0; i \u003C arr.length; i++) {\n    for (let j = 0; j \u003C arr.length; j++) {\n      result[j][result.length - 1 - i] = arr[i][j];\n    }\n  }\n  return result;\n}\n\nfunction rotateClock(arr, n) {\n  let result;\n  for (let i = 0; i \u003C= n; i++) {\n    result = rotate(arr);\n  }\n  return result;\n}\n\nconsole.log(\n  `result : ${rotateClock(\n    [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n      [13, 14, 15, 16],\n    ],\n    1,\n  )}`,\n);\n```","site/content/algorithms/simulation/pr1-rotateclock.mdx","d88e85ea0b67814b","simulation/pr2-matrix-multiply",{"id":328,"data":330,"body":334,"filePath":335,"digest":336,"deferredRender":25},{"title":331,"description":331,"createdAt":45,"path":332,"tags":333},"Pr2 Matrix Multiply",[26,323],{"pattern":323,"category":323},"> ðŸ“Œ **Source Code:** [simulation/pr2-matrix-multiply.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr2-matrix-multiply.js)\n\n```js\nfunction multiplyMatrix(arr1, arr2) {\n  const size = arr1.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      for (let k = 0; k \u003C size; k++) {\n        result[i][j] += arr1[i][k] * arr2[k][j];\n      }\n    }\n  }\n  return result;\n}\n\nfunction transposeMatrix(arr) {\n  const size = arr.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      result[i][j] += arr[j][i];\n    }\n  }\n  return result;\n}\n\nfunction solution(arr1, arr2) {\n  const multiplied = multiplyMatrix(arr1, arr2);\n  const result = transposeMatrix(multiplied);\n\n  return result;\n}\n\nconsole.log(\n  `result : ${JSON.stringify(\n    solution(\n      [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n      ],\n      [\n        [9, 8, 7],\n        [6, 5, 4],\n        [3, 2, 1],\n      ],\n    ),\n  )}`,\n);\n```","site/content/algorithms/simulation/pr2-matrix-multiply.mdx","be7259c014938d19","simulation/pr3-snail",{"id":337,"data":339,"body":344,"filePath":345,"digest":346,"deferredRender":25},{"title":340,"description":341,"createdAt":45,"path":342,"tags":343},"Pr3 Snail","nì„ ìž…ë ¥ë°›ì•„ ë‹¬íŒ½ì´ì²˜ëŸ¼ 1~nê¹Œì§€ ìˆ«ìžê°€ ì±„ì›Œì§„",[26,323],{"pattern":323,"category":323},"> ðŸ“Œ **Source Code:** [simulation/pr3-snail.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/pr3-snail.js)\n\n```js\n// nì„ ìž…ë ¥ë°›ì•„ ë‹¬íŒ½ì´ì²˜ëŸ¼ 1~nê¹Œì§€ ìˆ«ìžê°€ ì±„ì›Œì§„\n// 2ì°¨ì› ë°°ì—´ì„ return\n// TODO ë‹¤ì‹œ í•´ë³´ê¸°\n/*\nreturn :\n[\n[1,2,3],\n[8,9,4],\n[7,6,5]\n]\n */\n\nfunction solution(n) {\n  let arr = Array.from({ length: n }, () => Array(n).fill(0));\n}\n```","site/content/algorithms/simulation/pr3-snail.mdx","fcf6f3cd4a626a11","stack/core",{"id":347,"data":349,"body":353,"filePath":354,"digest":355,"deferredRender":25},{"title":350,"description":350,"createdAt":45,"path":351,"tags":352},"Stack",[26,47],{"pattern":49,"category":47},"> ðŸ“Œ **Source Code:** [core/stack.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/stack/core.js)\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n    this.size = 0;\n  }\n  push(item) {\n    this.items.push(item);\n    this.size++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    this.size--;\n    return this.items.pop();\n  }\n  isEmpty() {\n    return this.size === 0;\n  }\n}\n```","site/content/algorithms/stack/core.mdx","66d02b168fec60d3","tree/prg2-pyramid-scheme",{"id":356,"data":358,"body":363,"filePath":364,"digest":365,"deferredRender":25},{"title":359,"description":360,"createdAt":45,"path":361,"tags":362},"Pyramid Scheme","í”„ë¡œê·¸ëž˜ë¨¸ìŠ¤ ë‹¤ë‹¨ê³„ íŒë§¤",[26,101],{"pattern":101,"category":101,"platform":71},"> ðŸ“Œ **Source Code:** [tree/prg2-pyramidscheme.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/prg2-pyramidscheme.js)\n\n```js\nfunction solution(enroll, referral, seller, amount) {\n  const sellerMap = new Map();\n  const price = 100;\n  let result = [];\n  for (let member of enroll) {\n    sellerMap.set(`${member}`, { income: 0, shared: \"\" });\n  }\n\n  for (let i = 0; i \u003C referral.length; i++) {\n    // ìžì‹ ì„ ë“±ë¡í•œ ì‚¬ëžŒë§Œ ê¸°ì–µí•˜ë©´ ë¨\n    if (referral[i] !== \"-\") {\n      const enrolledBy = sellerMap.get(`${enroll[i]}`);\n\n      sellerMap.set(enroll[i], { ...enrolledBy, shared: referral[i] });\n      // ìžì‹ ì„ ë“±ë¡í•œ ì‚¬ëžŒì—ê²Œ ì´ìµê¸ˆ ê³„ì‚°ì—ì„œ ìžì‹ ì˜ ì´ìµê¸ˆì„ ë¹¼ì„œ ë”í•´ì¤Œ.\n      console.log(\n        `${enroll[i]} \\n enrolledBy : ${referral[i]} / ${enroll[i]} data: ${JSON.stringify(sellerMap.get(`${enroll[i]}`))}`,\n      );\n    }\n    // ì¶”ê°€ë¡œ ì¶”ì²œì„ ë°›ì€ ì‚¬ëžŒ enroll[i]ëŠ”\n  }\n\n  // ì—¬ê¸°ì„œ ì´ìµ ê³„ì‚°í•¨\n  for (let i = 0; i \u003C seller.length; i++) {\n    const salesman = sellerMap.get(seller[i]);\n    if (!salesman) {\n      continue;\n    }\n    console.log(`${i} - salesman : ${seller[i]}`, salesman);\n    const refer = salesman.shared;\n    const salesCount = amount[i];\n    console.log(`${i} - salesCount`, salesCount);\n    let fee = 0;\n\n    const income = salesCount * price;\n    if (refer) {\n      fee = income / 10;\n    }\n    const netIncome = income - fee;\n    console.log(\n      `${i} income: ${income}\\n fee: ${fee} \\nnetIncome >> \\n`,\n      netIncome,\n    );\n    sellerMap.set(seller[i], {\n      ...salesman,\n      income: salesman.income + netIncome,\n    });\n\n    if (refer) {\n      const referrer = sellerMap.get(refer);\n      // fee ë”í•¨\n      sellerMap.set(refer, { ...referrer, income: referrer.income + fee });\n      console.log(`${i} refer ${refer} >> \\n`, sellerMap.get(refer));\n    }\n  }\n\n  // ì¶”ê°€ë¡œ ì²«ë²ˆì§¸, ë‘ë²ˆì§¸ ì‚¬ëžŒë“¤ ìˆ˜ìˆ˜ë£Œ ëº´ì¤˜ì•¼ë¨\n  // ìžê¸° ì´ìµ ì „ì²´ì—ì„œ -10% í•´ì¤˜ì•¼ë¨\n  // ê·¸ëƒ¥ objê°€ ì‰¬ìš¸ì§€ë„.\n\n  // ìˆ˜ìˆ˜ë£Œ ë¹¼ê³ , fee ê³„ì† ë”í•´ì„œ income ë‚¨ê²Œ ë¨.\n  console.log(\"before entries :\", sellerMap);\n  let sellerArr = [...sellerMap].map(([, obj]) => obj.income);\n\n  return sellerArr;\n}\n\nlet test1A = [\n  \"john\",\n  \"mary\",\n  \"edward\",\n  \"sam\",\n  \"emily\",\n  \"jaimie\",\n  \"tod\",\n  \"young\",\n];\nlet test1B = [\"-\", \"-\", \"mary\", \"edward\", \"mary\", \"mary\", \"jaimie\", \"edward\"];\nlet test1C = [\"young\", \"john\", \"tod\", \"emily\", \"mary\"];\nlet test1D = [12, 4, 2, 5, 10];\n\nconsole.log(`result : /n`, solution(test1A, test1B, test1C, test1D));\n```","site/content/algorithms/tree/prg2-pyramid-scheme.mdx","87a81166e86d56e2","simulation/prg1-binary",{"id":366,"data":368,"body":373,"filePath":374,"digest":375,"deferredRender":25},{"title":369,"description":370,"createdAt":45,"path":371,"tags":372},"Binary","Prg1 Binary",[26,323],{"pattern":323,"category":323,"platform":71},"> ðŸ“Œ **Source Code:** [simulation/prg1-binary.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/simulation/prg1-binary.js)\n\n```js\nfunction remove(n) {\n  let c = 0;\n  let r = \"\";\n  for (const dig of n) {\n    if (dig == 0) {\n      c++;\n    } else {\n      r += dig;\n    }\n  }\n  return [r, c];\n}\n\nfunction toBinary(n) {\n  let s = n;\n  let a = [];\n  let r = \"\";\n  while (s > 0) {\n    a.push(s % 2);\n    s = Math.floor(s / 2);\n  }\n  while (a.length > 0) {\n    r += a.pop();\n  }\n  return r;\n}\n\nfunction solution(s) {\n  let count = 0;\n  let removeCount = 0;\n\n  while (s.length > 1) {\n    let [removed, rc] = remove(s);\n    let bin = toBinary(removed.length);\n    console.log(\"inner while : \", bin, removed, rc);\n    removeCount += rc;\n    s = bin;\n    count++;\n  }\n\n  return [count, removeCount];\n}\n\nconsole.log(`result : ${JSON.stringify(solution(\"110010101001\"))}`);\n```","site/content/algorithms/simulation/prg1-binary.mdx","9cbe7f85aa5a6d0d","tree/core",{"id":376,"data":378,"body":383,"filePath":384,"digest":385,"deferredRender":25},{"title":379,"description":380,"createdAt":45,"path":381,"tags":382},"Tree","ì´ì§„ íŠ¸ë¦¬ ê¸°ë³¸ êµ¬í˜„ì²´",[26,47],{"pattern":49,"category":47},"> ðŸ“Œ **Source Code:** [tree/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/core.js)\n\n```js\n// ì´ì§„ íŠ¸ë¦¬ ê¸°ë³¸ êµ¬í˜„ì²´\n\n// ëª¨ë“  ë…¸ë“œì—ì„œ ê°€ìž¥ ì˜¤ë¥¸ìª½ì¸ ë…¸ë“œë§Œ ì„ íƒí•˜ëŠ” í•¨ìˆ˜\nconst rightSideView = (tree) => {\n  if (tree.length \u003C= 1) return []; // ë¹ˆ íŠ¸ë¦¬ê±°ë‚˜ ë£¨íŠ¸ ë…¸ë“œë§Œ ì—†ëŠ” ê²½ìš°\n\n  const result = [];\n  const queue = [1]; // ë£¨íŠ¸ ë…¸ë“œì˜ ì¸ë±ìŠ¤ (1ë¶€í„° ì‹œìž‘)\n\n  while (queue.length > 0) {\n    const levelSize = queue.length; // í˜„ìž¬ ë ˆë²¨ì˜ ë…¸ë“œ ìˆ˜\n    let lastNodeValue = null;\n\n    for (let i = 0; i \u003C levelSize; i++) {\n      const currentIndex = queue.shift();\n      if (tree[currentIndex] === null || tree[currentIndex] === undefined)\n        continue;\n\n      lastNodeValue = tree[currentIndex]; // í˜„ìž¬ ë ˆë²¨ì˜ ë§ˆì§€ë§‰ ê°’ì„ ì €ìž¥\n\n      // ì™¼ìª½ ìžì‹ ì¶”ê°€\n      const leftChildIndex = 2 * currentIndex;\n      if (leftChildIndex \u003C tree.length) queue.push(leftChildIndex);\n\n      // ì˜¤ë¥¸ìª½ ìžì‹ ì¶”ê°€\n      const rightChildIndex = 2 * currentIndex + 1;\n      if (rightChildIndex \u003C tree.length) queue.push(rightChildIndex);\n    }\n\n    if (lastNodeValue !== null) result.push(lastNodeValue);\n  }\n\n  return result;\n};\n\n// ì˜ˆì œ ì‹¤í–‰\nconsole.log(rightSideView([null, 1, 2, 3, null, 5, null, 4])); // ì¶œë ¥: [1, 3, 4]\nconsole.log(rightSideView([null, 1, 2, 3, 4, null, null, null, 5])); // ì¶œë ¥: [1, 3, 4, 5]\nconsole.log(rightSideView([null, 1, null, 3])); // ì¶œë ¥: [1, 3]\nconsole.log(rightSideView([null])); // ì¶œë ¥: []\n\n/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\n```","site/content/algorithms/tree/core.mdx","cf597794e1ab2dbc","tree/practice1-making-tree",{"id":386,"data":388,"body":393,"filePath":394,"digest":395,"deferredRender":25},{"title":389,"description":390,"createdAt":45,"path":391,"tags":392},"Practice1 Making Tree","ì´ì§„ íŠ¸ë¦¬ë¥¼ ì „/ì¤‘/í›„ìœ„ ìˆœíšŒí•˜ê¸°",[26,101],{"pattern":101,"category":101},"> ðŸ“Œ **Source Code:** [tree/practice1-making-tree.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/practice1-making-tree.js)\n\n```js\n/*\n *ì´ì§„ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•œ ë°°ì—´ nodesë¥¼ ì¸ìžë¡œ ë°›ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ nodesê°€ `[1,2,3,4,5,6,7]`ì´ë¼ë©´ ë‹¤ìŒê³¼ ê°™ì€ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•©ë‹ˆë‹¤.\n * í•´ë‹¹ ì´ì§„íŠ¸ë¦¬ì— ëŒ€í•˜ì—¬ ì „ìœ„ ìˆœíšŒ, ì¤‘ìœ„ìˆœíšŒ, í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” solution()í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.\n * ì¡°ê±´: ë…¸ë“œëŠ” 1 ì´ìƒ 1000ê°œ ì´í•˜. ë…¸ë“œëŠ” ì •ìˆ˜ê°’ì´ë©° ì¤‘ë³µë˜ì§€ ì•ŠëŠ”ë‹¤.\n * */\n\nfunction getPreOrder(nodes) {\n  let result = [empty, ...nodes];\n  for (let i = 1; i \u003C nodes.length; i++) {\n    if (i === 1) {\n      result.push(i);\n      continue;\n    }\n    // í˜„ìž¬ ë…¸ë“œê°€ ë¶€ëª¨ë³´ë‹¤ ìž‘ìœ¼ë©´?\n    if (nodes[i] \u003C result[i / 2]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n    if (nodes[i] > result[i / 2 + 1]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n  }\n  return result;\n}\n\nfunction solution(nodes) {\n  let result = [];\n  let preOrder = getPreOrder(nodes);\n\n  return result;\n}\n```","site/content/algorithms/tree/practice1-making-tree.mdx","8aad98b20cefbebc","tree/prg3-maze",{"id":396,"data":398,"body":403,"filePath":404,"digest":405,"deferredRender":25},{"title":399,"description":400,"createdAt":45,"path":401,"tags":402},"Maze","console.log(`result : /n`, solution(test1A));",[26,101],{"pattern":101,"category":101,"platform":71},"> ðŸ“Œ **Source Code:** [tree/prg3-maze.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/tree/prg3-maze.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction getCord(maps, target) {\n  let tRow = maps.findIndex((col) => col.includes(target));\n  let tCol = maps[tRow].split(\"\").findIndex((col) => col === target);\n  return [tRow, tCol];\n}\n\nfunction bfs(maps, start, target) {\n  let direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  let rows = maps.length;\n  let cols = maps[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [sRow, sCol] = getCord(maps, start);\n\n  let Q = new Queue();\n  console.log(`\n  sRow : ${sRow}\n  sCol : ${sCol}\n  `);\n\n  Q.push([sRow, sCol, 0]);\n\n  while (!Q.isEmpty()) {\n    const [r, c, dist] = Q.pop();\n\n    console.log(`\n    r : ${r}\n    c : ${c}\n    maps[r][c] : ${maps[r][c]}\n    `);\n\n    if (maps[r][c] === target) {\n      return dist;\n    }\n\n    for (const [dr, dc] of direction) {\n      let nr = r + dr;\n      let nc = c + dc;\n      let updateCondition =\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C rows &&\n        nc \u003C cols &&\n        maps[nr][nc] !== \"X\" &&\n        !visited[nr][nc];\n      if (updateCondition) {\n        visited[nr][nc] = true;\n        Q.push([nr, nc, dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let toLeverDist = bfs(maps, \"S\", \"L\");\n  let toEndDist = bfs(maps, \"L\", \"E\");\n  console.log(`----\n  toLeverDist ${toLeverDist}\n  toEndDist : ${toEndDist}\n  --------\n  `);\n  let answer = toLeverDist > 0 && toEndDist > 0 ? toLeverDist + toEndDist : -1;\n  return answer;\n}\nlet test1A = [\"SOOOL\", \"XXXXO\", \"OOOOO\", \"OXXXX\", \"OOOOE\"];\nlet test1B = [\"LOOXS\", \"OOOOX\", \"OOOOO\", \"OOOOO\", \"EOOOO\"];\n\n// console.log(`result : /n`, solution(test1A));\nconsole.log(`result : /n`, solution(test1B));\n```","site/content/algorithms/tree/prg3-maze.mdx","15d9bbc739712248"]