[["Map",1,2,9,10,426,427],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.4.3","content-config-digest","56efaea828b2378c","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"http://localhost:4321\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"class\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","algorithms",["Map",11,12,25,26,36,37,47,48,58,59,70,71,82,83,95,96,105,106,115,116,127,128,137,138,147,148,157,158,167,168,177,178,188,189,197,198,207,208,218,219,229,230,240,241,251,252,262,263,272,273,282,283,292,293,302,303,314,315,323,324,335,336,346,347,357,358,366,367,376,377,386,387,396,397,406,407,416,417],"backtracking/leetcode-79-word-search",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"deferredRender":24},{"title":14,"description":15,"createdAt":16,"path":17,"tags":20},"LeetCode 79. Word Search","LeetCode problem 79","2025-03-17",[9,18,19],"leetcode","backtracking",{"pattern":19,"category":18},"# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/word-search/)\n\n1. íƒìƒ‰ ê²°ê³¼ê°€ **ë°©ë¬¸ ìˆœì„œì— ì˜í–¥ì„ ë°›ìŒ**\n2. **ë°±íŠ¸ë˜í‚¹**ì´ í•„ìš”í•¨\n   - `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n[ì´ì „ ê¸€](https://blog.leetekwoo.com/blog/63#3-3-backtracking)ì—ì„œ ì‚´í•€ ë°±íŠ¸ë ˆí‚¹ì„ í™œìš©í•˜ëŠ” ë¬¸ì œì´ë‹¤. visitedë¥¼ ì¸ì ‘ í–‰ë ¬ë¡œ ê´€ë¦¬í•œë‹¤.\n\n## ì •ë‹µ\n\n```js\n/**\n * @description ë¬¸ì œ : ì¸ì ‘ í–‰ë ¬ì—ì„œ wordë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì—¬ë¶€ true/false\n *   ë°©í–¥ì€ ìƒê´€ì—†ë‹¤. (ì™¼\u003C->ì˜¤, ìœ„ \u003C->ì•„ë˜)\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function (board, word) {\n  const rSize = board.length;\n  const cSize = board[0].length;\n  const visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs(r, c, count = 0) {\n    if (word.length === count) return true; // ê¸°ì € ì¡°ê±´. ì¬ê·€ í•¨ìˆ˜ ì „ì²´ ì¤‘ë‹¨ ì¡°ê±´\n    /** @note ì—¬ê¸°ì„œ ë°©ë¬¸ ì²˜ë¦¬ X **/\n    // visited[r][c] = true; //\n    if (\n      // ì¡°ê±´ í•´ë‹¹ ì‹œ\n      r >= 0 &&\n      c >= 0 &&\n      r \u003C rSize &&\n      c \u003C cSize &&\n      !visited[r][c] &&\n      board[r][c] === word[count]\n    ) {\n      /** @note ë°©ë¬¸ ì²˜ë¦¬ë¥¼ ì—¬ê¸°ì„œ í•´ì•¼í•¨. **/\n      visited[r][c] = true; // ë°©ë¬¸ ì²˜ë¦¬ë¥¼ ì—¬ê¸°ì„œ í•´ì•¼í•¨\n      for (let [or, oc] of offset) {\n        if (dfs(r + or, c + oc, count + 1)) return true;\n      }\n      /** @note ë°±íŠ¸ë ˆí‚¹ : ê²½ë¡œë§ˆë‹¤ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆì–´ í•´ì£¼ì–´ì•¼í•¨. **/\n      visited[r][c] = false;\n    }\n\n    return false;\n  }\n\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n\n  return false;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n```js\nvar exist = function (board, word) {\n  const n = board.length;\n  const visited = Array.from({ length: n }, () => Array(n).fill(false));\n  const offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  function dfs([r, c], word, visited, count = 0) {\n    if (visited[r][c]) return count;\n    visited[r][c] = true;\n    if (word[count] === board[r][c]) {\n      // countë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•´ì•¼ ë  ì§€ ëª°ëë‹¤.\n      // ì¸ì ‘ë…¸ë“œ ë°©ë¬¸ í˜„ì¬ ê¸€ìê°€ word[count]ë‘ ê°™ì„ ë•Œë§Œ ì¬ê·€ í˜¸ì¶œ\n\n      for (let [or, oc] of offset) {\n        const [nr, nc] = [r + or, c + oc];\n        if (\n          nr \u003C n &&\n          nc \u003C n &&\n          nr >= 0 &&\n          nc >= 0 &&\n          !visited[nr][nc] &&\n          board[nr][nc] === word[count + 1]\n        ) {\n          count += dfs([nr, nc], word, visited, count + 1);\n        }\n      }\n    } else {\n      return count;\n    }\n  }\n  // ë¬¸ì œ ì¡°ê±´ì´ O(n^2)ìœ¼ë¡œ 2ì¤‘ í¬ë¬¸ìœ¼ë¡œ í‘¸ëŠ” ê²ƒì´ ë” ì ì ˆí–ˆìŒ\n  // countê°€ ì¡°ê±´ì— ë§ìœ¼ë©´ ë°”ë¡œ ë¦¬í„´ë§Œ í•˜ë©´ë¨. ëˆ„ì í•  í•„ìš”ëŠ” ì—†ì—ˆìŒ.\n  const result = dfs([0, 0], word, visited, 0);\n  return result === word.length;\n};\n```","site/content/algorithms/backtracking/leetcode-79-word-search.mdx","a808bde14e0d4aae",true,"backtracking/pr1-1n",{"id":25,"data":27,"body":33,"filePath":34,"digest":35,"deferredRender":24},{"title":28,"description":29,"createdAt":30,"path":31,"tags":32},"Pr1 1+N","ì¤‘ë‹¨ì : ì´í•©ì´ 10ì´ë©´ ê²°ê³¼ì— ì¶”ê°€","2025-03-19",[9,19],{"pattern":19,"category":19},"> ğŸ“Œ **Source Code:** [backtracking/pr1-1+N.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/backtracking/pr1-1+N.js)\n\n```js\nfunction backtrack(ì´í•©, ì„ íƒëœìˆ˜, ì‹œì‘ìˆ˜, ì „ì²´ìˆ˜, ê²°ê³¼) {\n  // ì¤‘ë‹¨ì : ì´í•©ì´ 10ì´ë©´ ê²°ê³¼ì— ì¶”ê°€\n  if (ì´í•© === 10) {\n    ê²°ê³¼.push(ì„ íƒëœìˆ˜);\n    return;\n  }\n\n  for (let i = ì‹œì‘ìˆ˜; i \u003C= ì „ì²´ìˆ˜; i++) {\n    if (ì´í•© + i \u003C= 10) {\n      // ì´í•©ì´ 10ì„ ë„˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™\n      backtrack(ì´í•© + i, ì„ íƒëœìˆ˜.concat(i), i + 1, ì „ì²´ìˆ˜, ê²°ê³¼);\n    }\n  }\n}\n\nfunction solution(n) {\n  let result = [];\n  backtrack(0, [], 1, n, result);\n  return result;\n}\n\n// í…ŒìŠ¤íŠ¸ ì‹¤í–‰\nconsole.log(\"result : \", solution(5));\n```","site/content/algorithms/backtracking/pr1-1+N.mdx","c2f0bb61818db25e","backtracking/prg3-arrow",{"id":36,"data":38,"body":44,"filePath":45,"digest":46,"deferredRender":24},{"title":39,"description":40,"createdAt":30,"path":41,"tags":42},"Arrow","ë¹„êµë¥¼ ìœ„í•´ ì•Œì•„ì•¼ í•˜ëŠ” ê±°",[9,19],{"pattern":19,"category":19,"platform":43},"programmers","> ğŸ“Œ **Source Code:** [backtracking/prg3-arrow.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/backtracking/prg3-arrow.js)\n\n```js\n// ë¹„êµë¥¼ ìœ„í•´ ì•Œì•„ì•¼ í•˜ëŠ” ê±°\n// 1. infoì˜ ì´í•©\n// 2. infoì—ì„œ ê° ì ìˆ˜ 10~0ì  ëª‡ê°œ ë§ì·„ëŠ”ì§€\n// në°œ ì´ë‚´ì—ì„œ 1ì„ ë„˜ì„ ìˆ˜ ìˆëŠ”ì§€ ì•Œì•„ì•¼í•¨\n// backtrackì„ í†µí•´ ë‚´ê°€ ì–»ì„ ìˆ˜ ìˆëŠ” ì ìˆ˜ë¥¼ ê³„ì‚°í•¨\n// 1ì´ˆê³¼ í•˜ê¸° ìœ„í•´ nì„ ì–´ë–»ê²Œ ë°°ë¶„í•´ì•¼í•˜ëŠ”ì§€ ì•Œì•„ì•¼í•¨\n// në°œ ì´ë‚´ì— 1ì„ ë„˜ì„ ìˆ˜ ìˆë‚˜\n// në°œ ì´ë‚´ì— 1dml\n\n// infoì—ì„œ ìµœê³  ì ìˆ˜ êµ¬í•˜ëŠ” í•¨ìˆ˜\nfunction getTotal(info) {\n  let result = 0;\n  for (let i = 0; i \u003C= info.length - 1; i++) {\n    result += (10 - i) * info[i];\n  }\n  return result;\n}\n\nfunction backtrack(n, info, total) {\n  let remain = n;\n  let myTotal = 0;\n  let result = [];\n  // remainì´ 1ì¼ë•Œê¹Œì§€ ë°˜ë³µ\n\n  for (let i = 0; i \u003C 10; i++) {\n    let myShot = info[i] + 1;\n    let myScore = 10 - i;\n    // ì–¸ì œ ì¶”ê°€í•˜ì§€?\n    // ì ë‹¹íˆ ë°°ë¶„ë˜ì–´ì•¼í•¨.\n    if (remain \u003C= 0 || total \u003C myTotal) {\n      return result;\n    }\n    console.log(\n      \"inner for remain : \",\n      remain,\n      \"\\n\",\n      \"myShot : \",\n      myShot,\n      \"\\n\",\n      \"myScore : \",\n      myScore,\n      \"\\n\",\n      \"myTotal : \",\n      myTotal,\n    );\n    if (myTotal + myScore \u003C total) {\n      result.push(myShot);\n      myTotal += myScore;\n      remain = remain - myShot;\n    }\n  }\n\n  return [-1];\n}\n\nfunction solution(n, info) {\n  let infoTotal = getTotal(info);\n  let result = backtrack(n, info, infoTotal);\n\n  return result;\n}\n\n// í…ŒìŠ¤íŠ¸ ì‹¤í–‰\nconsole.log(\"result : \", solution(5, [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]));\n```","site/content/algorithms/backtracking/prg3-arrow.mdx","d9c3d4c2fc96d314","bfs/prg1-gamemap",{"id":47,"data":49,"body":55,"filePath":56,"digest":57,"deferredRender":24},{"title":50,"description":51,"createdAt":30,"path":52,"tags":54},"Gamemap","Prg1 Gamemap",[9,53],"graph",{"pattern":53,"category":53,"platform":43},"> ğŸ“Œ **Source Code:** [graph/prg1-gamemap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/bfs/prg1-gamemap.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(map, start, target) {\n  let rows = map.length;\n  let cols = map[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [tR, tC] = target;\n  const Q = new Queue();\n  const direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  Q.push([start, 0]);\n\n  while (!Q.isEmpty()) {\n    const [[prevR, prevC], dist] = Q.pop();\n\n    if (prevR == tR && prevC == tC) {\n      return dist;\n    }\n\n    for (let [r, c] of direction) {\n      let nextR = prevR + r;\n      let nextC = prevC + c;\n      if (\n        nextR \u003C rows &&\n        nextC \u003C cols &&\n        nextR >= 0 &&\n        nextC >= 0 &&\n        map[nextR][nextC] != 0 &&\n        !visited[nextR][nextC]\n      ) {\n        visited[nextR][nextC] = true;\n        Q.push([[nextR, nextC], dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let start = [0, 0];\n  let target = [maps.length - 1, maps[0].length - 1];\n\n  let dist = bfs(maps, start, target);\n\n  return dist;\n}\n\nconsole.log(\n  \"result : \",\n  solution([\n    [1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 1],\n  ]),\n);\n```","site/content/algorithms/bfs/prg1-gamemap.mdx","19d3e4e04a213fb9","bfs/core",{"id":58,"data":60,"body":67,"filePath":68,"digest":69,"deferredRender":24},{"title":61,"description":62,"createdAt":30,"path":63,"tags":65},"Bfs","1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„",[9,64],"core",{"pattern":66,"category":64},"","> ğŸ“Œ **Source Code:** [bfs/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/bfs/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n  enqueue(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  dequeue() {\n    return this.items[this.front++];\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction bfs(start, graph, visited, answer) {\n  let Q = new Queue();\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  /* ìµœì†Œ, ìµœë‹¨ ê±°ë¦¬ ë“±ì„ ê³„ì‚°í•´ì•¼í•œë‹¤ë©´ paramìœ¼ë¡œ ë°›ê³ ,\n   ë°˜ë³µë¬¸ ì•ˆì—ì„œ ì¡°ê±´ì— ë§ì„ ì‹œ ì—…ë°ì´íŠ¸ í•œ ë’¤ returní•œë‹¤.\n   í˜¹ì€ í•´ë‹¹í•˜ëŠ” ì¢Œí‘œì˜ ë¬¶ìŒ ë“±ì„ í•„ìš”ë¡œ í•  ì‹œ\n    let result = [start];ë¥¼ ë°˜ë³µë¬¸ ì™¸ë¶€ì— ë§Œë“¤ê³ ,\n    result.push(newNode)ë¥¼ í•˜ë©´ ë°©ë¬¸í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ìŒ“ì´ê²Œ ëœë‹¤.\n    */\n\n  // í ì‹œì‘ì  ì¶”ê°€\n  Q.push(start); // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ start í˜•íƒœ ë‹¤ë¦„\n  while (!Q.isEmpty()) {\n    let start = Q.dequeue();\n    // ì¡°ê±´ë¬¸ ì¶”ê°€\n\n    for (let neighbor of graph[start]) {\n      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§ê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´\n      if (!visited[neighbor]) {\n        //  answer++;, í˜¹ì€ ë¬¸ì œ ì¡°ê±´ì— ë”°ë¼ bfs ë‚´ë¶€ì—ì„œ resultë¥¼ ëª¨ì•„ pushí•  ìˆ˜ ë„ ìˆìŒ.\n        visited[neighbor] = true; // ì´ ì¡°ê±´ ì–¸ì œ ì¶”ê°€í•´ì•¼í•˜ì§€?\n        Q.enqueue(neighbor);\n      }\n    }\n  }\n  return answer;\n}\n\n// offset ì‚¬ìš©í•˜ëŠ” bfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction bfsOffset(visited, graph, [startR, startC], answer) {\n  let Q = new Queue();\n  visited[startR][startC] = true;\n  Q.enqueue([startR, startC]);\n  while (!Q.isEmpty()) {\n    let [curR, curC] = Q.dequeue();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§ëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..\n      ) {\n        visited[nr][nc] = true;\n        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©\n        Q.enqueue([nr, nc]);\n      }\n    }\n  }\n  return answer;\n}\n```","site/content/algorithms/bfs/core.mdx","9b1f65681cfbc330","dfs/leetcode-130-surrounded-regions",{"id":70,"data":72,"body":79,"filePath":80,"digest":81,"deferredRender":24},{"title":73,"description":74,"createdAt":16,"path":75,"tags":77},"LeetCode 130. Surrounded Regions","LeetCode problem 130",[9,18,76],"leetcode-130-surrounded-regions",{"pattern":78,"category":18},"DFS","# Topics\n\n- Array\n- Depth-First Search\n- Breadth-First Search\n- Union Find\n- Matrix\n\n# ë¬¸ì œ\n\n[ë§í¬](https://leetcode.com/problems/surrounded-regions)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  if (!board.length || !board[0].length) return;\n\n  let rSize = board.length,\n    cSize = board[0].length;\n  let directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // ê°€ì¥ìë¦¬ì— ì—°ê²°ëœ 'O'ë¥¼ ì°¾ê³  'S'ë¡œ ë³€ê²½ (ë³´ì¡´ ì²˜ë¦¬)\n  function dfs(r, c) {\n    if (r \u003C 0 || c \u003C 0 || r >= rSize || c >= cSize || board[r][c] !== \"O\") {\n      return;\n    }\n    board[r][c] = \"S\"; // ê°€ì¥ìë¦¬ì— ì—°ê²°ëœ 'O'ëŠ” ë³´ì¡´\n    for (let [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  }\n\n  // 1. ê°€ì¥ìë¦¬ì—ì„œ DFS íƒìƒ‰í•˜ì—¬ 'O' â†’ 'S' ë³€ê²½ (ë³´ì¡´)\n  for (let r = 0; r \u003C rSize; r++) {\n    dfs(r, 0);\n    dfs(r, cSize - 1);\n  }\n\n  for (let c = 0; c \u003C cSize; c++) {\n    dfs(0, c);\n    dfs(rSize - 1, c);\n  }\n\n  // 2. ë³´ë“œë¥¼ ì—…ë°ì´íŠ¸\n  for (let r = 0; r \u003C rSize; r++) {\n    for (let c = 0; c \u003C cSize; c++) {\n      if (board[r][c] === \"O\") {\n        board[r][c] = \"X\"; // ê°ì‹¸ì§„ 'O' â†’ 'X'\n      } else if (board[r][c] === \"S\") {\n        board[r][c] = \"O\"; // ë³´ì¡´ëœ 'S' â†’ ì›ë˜ëŒ€ë¡œ 'O'\n      }\n    }\n  }\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. DFS ë°©ë¬¸ ë¡œì§ ì˜¤ë¥˜ (dfs ë‚´ë¶€ ì¡°ê±´ ì˜¤ë¥˜)\n\n- if (visited[r][c]) return false â†’ ì´ë¯¸ ë°©ë¬¸í•œ ê³³ì„ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì€ ë§ì§€ë§Œ, dfsê°€ ì°¸/ê±°ì§“ì„ ë°˜í™˜í•´ì•¼ í•˜ëŠ” ì´ìœ ê°€ ë¶ˆë¶„ëª…í•¨.\n- isChange = dfs([nr, nc]) ë¶€ë¶„ì—ì„œ trueë¥¼ ë°˜í™˜í•˜ë©´ board[r][c] = \"X\"ë¡œ ë³€ê²½í•˜ëŠ”ë°, ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•œ í›„ ë³€í™˜ ì—¬ë¶€ë¥¼ ê²°ì •í•´ì•¼ í•¨.\n- ì¦‰, ì¸ì ‘í•œ ëª¨ë“  'O'ë¥¼ ë°©ë¬¸í•œ í›„ ë³€ê²½ ì—¬ë¶€ë¥¼ íŒë‹¨í•´ì•¼ í•¨.\n\n2. ê²½ê³„ ì¡°ê±´ ì²˜ë¦¬ ì˜¤ë¥˜ (isCurrentEdge í™œìš© ë¬¸ì œ)\n\n- isCurrentEdgeê°€ trueë©´ ì¦‰ì‹œ falseë¥¼ ë°˜í™˜í•˜ëŠ” ê²ƒì€ í‹€ë¦¼.\n- ê°€ì¥ìë¦¬ì— ìˆëŠ” 'O'ë¥¼ ë°œê²¬í•˜ë©´ í•´ë‹¹ ì˜ì—­ ì „ì²´ë¥¼ ë³´ì¡´í•´ì•¼ í•¨.\n- falseë¥¼ ë°˜í™˜í•´ë„ ì¸ì ‘ ë…¸ë“œê°€ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ â†’ ê°€ì¥ìë¦¬ì— ì—°ê²°ëœ ëª¨ë“  'O'ë¥¼ ë³€ê²½í•˜ì§€ ì•Šë„ë¡ í‘œê¸°í•˜ëŠ” ê²ƒì´ í•µì‹¬.\n\n3. ë³´ë“œ ì—…ë°ì´íŠ¸ íƒ€ì´ë° ë¬¸ì œ (board[r][c] = \"X\")\n\n- DFS ë„ì¤‘ ë°”ë¡œ \"X\"ë¡œ ë³€í™˜í•˜ë©´ ì•ˆ ë¨.\n- íƒìƒ‰ ì¤‘ì¸ 'O'ê°€ ì‹¤ì œë¡œ ê°ì‹¸ì ¸ ìˆëŠ”ì§€ í™•ì •ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ë³€ê²½ë˜ë©´ ì˜¤ë‹µ ê°€ëŠ¥ì„± ì¦ê°€.\n- ëª¨ë“  DFSê°€ ì™„ë£Œëœ í›„, ê°ì‹¸ì§„ 'O'ë¥¼ 'X'ë¡œ ë³€í™˜í•´ì•¼ í•¨.\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  let rSize = board.length,\n    cSize = board[0].length;\n  let visited = Array.from({ length: rSize }, () => Array(cSize).fill(false));\n  let offset = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  // dfs t/f ë°˜í™˜. të©´ Xë¡œ ë°”ê¾¼ë‹¤, fë©´ ë°”ê¾¸ì§€ ì•ŠëŠ”ë‹¤.\n  function dfs([r, c]) {\n    if (visited[r][c]) return false;\n    visited[r][c] = true;\n\n    const isCurrentEdge =\n      r === 0 || c === 0 || r === rSize - 1 || c === cSize - 1;\n\n    // ì¸ì ‘ì´ Xì¸ ê²½ìš°, ì—°ê²°ëœ ëª¨ë“  Oê°€ Xë¼ë©´ ë°”ê¿”ì•¼í•¨\n    if (board[r][c] === \"X\") return true;\n    // ë˜ëŠ” Oê°€ ê°€ì¥ ìë¦¬ì— ìˆë‹¤ë©´ Xë¡œ ë°”ê¿€ ìˆ˜ ì—†ìŒ\n    if (board[r][c] === \"O\" && isCurrentEdge) return false;\n\n    // í˜„ì¬ ë…¸ë“œ = \"O\" ì¸ì ‘ ë…¸ë“œì— ë”°ë¼ ìê¸° ìì‹ ì´ ë°”ë€œ\n    // 1. ì¸ì ‘ ë…¸ë“œë¥¼ ëª¨ë‘ ë°©ë¬¸í•˜ê³ ,\n    // 2. ìê¸° ìì‹ ì˜ ë°”ê¾¸ëŠ” ì—¬ì§€ë¥¼ ì •í•¨.\n\n    // ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ ì „ì— í˜„ì¬ Oë¥¼ Xë¡œ ë°”ê¾¸ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë‹¤\n    // O\n\n    /**\n        ëª©ì : dfsê°€ tfë¥¼ ë°˜í™˜í•˜ì—¬ ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸í•œ ê²°ê³¼ê°’ì´ t/fë¥¼ ë°˜í™˜í•˜ê²Œ í•œë‹¤.\n        ì¡°ê±´:\n        - ëª¨ë“  ì¸ì ‘ì´ Xì´ë©´? í˜„ì¬ ë…¸ë“œë¥¼ Xë¡œ ë°”ê¾¼ë‹¤\n        - ëª¨ë“  ì¸ì ‘ì´ Xê°€ ì•„ë‹ˆë©´? Oì¸ ë…¸ë“œë¡œ ì´ë™í•œë‹¤\n        - í˜„ì¬ ë…¸ë“œì˜ r, cê°€ 0ì´ë‚˜ r,cSize-1ì´ë©´? ë³€í™˜í•˜ì§€ ì•ŠëŠ”ë‹¤ - ìœ„ì—ì„œ false ë³€í™˜\n         **/\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [r + or, c + oc];\n      let isChange = false;\n      if (nr >= 0 && nc >= 0 && nr \u003C rSize && c \u003C cSize && !visited[nr][nc]) {\n        isChange = dfs([nr, nc]);\n        if (isChange) {\n          board[r][c] = \"X\";\n        }\n      }\n    }\n    return isCurrentEdge;\n  }\n  // board ìì²´ë¥¼ dfs ë‚´ë¶€ì—ì„œ ë³€í™˜í•œ ë’¤ ë¦¬í„´.\n  return board;\n};\n```","site/content/algorithms/dfs/leetcode-130-surrounded-regions.mdx","ee88843912b36720","dfs/leetcode-94-binary-tree-inorder-traverse",{"id":82,"data":84,"body":92,"filePath":93,"digest":94,"deferredRender":24},{"title":85,"description":86,"createdAt":16,"path":87,"tags":90},"LeetCode 94. Binary Tree Inorder Traversal","LeetCode problem 94",[9,18,88,89],"tree","traversal",{"pattern":91,"category":18},"tree-traversal","# Topics\n\n- Stack\n- Tree\n- Depth-First Search\n- Binary Tree\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length \u003C 2) return s; // í•œ ê¸€ìë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜\n\n  let start = 0,\n    maxLength = 1;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right \u003C s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return [left + 1, right - 1]; // íŒ°ë¦°ë“œë¡¬ì˜ ì‹œì‘ê³¼ ë ì¸ë±ìŠ¤ ë°˜í™˜\n  }\n\n  for (let i = 0; i \u003C s.length; i++) {\n    // í™€ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬\n    let [l1, r1] = expandAroundCenter(i, i);\n    // ì§ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬\n    let [l2, r2] = expandAroundCenter(i, i + 1);\n\n    if (r1 - l1 + 1 > maxLength) {\n      start = l1;\n      maxLength = r1 - l1 + 1;\n    }\n    if (r2 - l2 + 1 > maxLength) {\n      start = l2;\n      maxLength = r2 - l2 + 1;\n    }\n  }\n\n  return s.slice(start, start + maxLength);\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. visitedê°€ ë¶ˆí•„ìš”í•œë° ì‚¬ìš©í–ˆìŒ\n2. paramìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” rootì˜ ê°’ì²˜ë¦¬ë¥¼ ì œëŒ€ë¡œ ëª»í•¨\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  let output = [];\n  let visited = new Set();\n  function dfs(root, cur) {\n    if (visited.has(cur) || !root?.val) return;\n    visited.add(cur);\n    output.push(root.val);\n\n    // ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ ì¤‘ìœ„ ìˆœíšŒëŠ” ì™¼ -> ë£¨íŠ¸ -> ì˜¤\n    dfs(root, root?.left);\n    dfs(root, root?.right);\n  }\n  dfs(root, root?.val);\n  return output;\n};\n```","site/content/algorithms/dfs/leetcode-94-binary-tree-inorder-traverse.mdx","b8d5e6280687add2","dfs/prg2-network-dfs",{"id":95,"data":97,"body":102,"filePath":103,"digest":104,"deferredRender":24},{"title":98,"description":99,"createdAt":30,"path":100,"tags":101},"Network Dfs","Prg2 Network Dfs",[9,53],{"pattern":53,"category":53,"platform":43},"> ğŸ“Œ **Source Code:** [graph/prg2-network-dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/dfs/prg2-network-dfs.js)\n\n```js\nfunction dfs(computers, visited, node) {\n  visited[node] = true;\n\n  for (let idx = 0; idx \u003C computers.length; idx++) {\n    if (computers[node][idx] && !visited[idx]) {\n      dfs(computers, visited, idx);\n    }\n  }\n}\n\nfunction solution(n, computers) {\n  let visited = Array(n).fill(false);\n  let answer = 0;\n\n  for (let i = 0; i \u003C n; i++) {\n    if (!visited[i]) {\n      dfs(computers, visited, i);\n      answer++;\n    }\n  }\n\n  return answer;\n}\n\nconsole.log(\"result : \", solution());\n```","site/content/algorithms/dfs/prg2-network-dfs.mdx","33f8b9efef22f201","dfs/core",{"id":105,"data":107,"body":112,"filePath":113,"digest":114,"deferredRender":24},{"title":108,"description":109,"createdAt":30,"path":110,"tags":111},"Dfs","ì¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs",[9,64],{"pattern":66,"category":64},"> ğŸ“Œ **Source Code:** [core/dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/dfs/core.js)\n\n```js\n// ì¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs\nfunction recursiveDfs(start, graph, visited, answer) {\n  // ì¬ê·€ í˜¸ì¶œ ì‹œ ë°©ë¬¸ ì—¬ë¶€ ì—…ë°ì´íŠ¸ ìœ„ì¹˜ ì£¼ì˜\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  // ë¬¸ì œê°€ ìš”êµ¬í•˜ëŠ” ë°˜í™˜ê°’ì´ ë¬´ì—‡ì¸ì§€ì— ë”°ë¼ ë°˜í™˜ê°’, í•¨ìˆ˜ ì¸ì, ì—…ë°ì´íŠ¸ ì¡°ê±´ ë“±ì´ ë‹¬ë¼ì§„ë‹¤.\n  // answerì´ ìˆ«ìë¼ë©´ íŠ¹ì • ìˆ«ì ì´í•˜ì¼ ë•Œ dfs ì¬ê·€ í˜¸ì¶œì„ ë°±íŠ¸ë˜í‚¹í•  ìˆ˜ ìˆë‹¤.\n\n  // ì¬ê·€ í•¨ìˆ˜ ìŠ¤íƒì— ë“¤ì–´ê°€ê¸° ì „ì— ì¡°ê±´ë¬¸ì„ ì¶”ê°€í•˜ì—¬ return í•  ìˆ˜ë„ ìˆë‹¤.\n  // ì´ ë•Œ ì¤‘ë‹¨ë˜ëŠ” ê²ƒì€ ë”ì´ìƒ ì•„ë˜ ë…¸ë“œë“¤ì´ ì¡°ê±´ì— ë¶€í•©í•˜ì§€ ì•ŠëŠ” ê²½ìš° ì´ë‹¤.\n  while (!visited[start] && !!graph[start] && graph[start].length > 0) {\n    // ì´ ì¡°ê±´ì—ì„œ !graph[start]ì™€ graph[start].length \u003C 0 ì€ ìµœí•˜ìœ„ ë…¸ë“œê°€ ëœë‹¤\n    // ê·¸ë˜í”„ê°€ startëŠ” ê°ì²´ í‚¤(ë¶€ëª¨ ë…¸ë“œ ì´ë¦„)ë‚˜ ë°°ì—´(ë¶€ëª¨ ë…¸ë“œì˜ ì¸ë±ìŠ¤)ê°€ ë  ìˆ˜ ìˆë‹¤.\n    for (let neighbor of graph[start]) {\n      dfs(neighbor, graph, visited, answer);\n    }\n  }\n  // ë°˜ë³µë¬¸ ì™¸ë¶€ì—ì„œ answer.push(neighbor)í•˜ì—¬ ë…¸ë“œë¥¼ ì €ì¥í•  ìˆ˜ ìˆë‹¤.\n  // ë§Œì•½ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤ë©´, stackì—ì„œ ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê¸° ë•Œë¬¸ì— .reverse()í•˜ì—¬ ë°˜í™˜í•´ì•¼\n  // ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.\n  return;\n}\n\n// í•¨ìˆ˜ ë‚´ë¶€ì— stackì„ ë§Œë“¤ì–´ ì‚¬ìš©í•˜ëŠ” dfs\nfunction stackDfs(start, graph, visited, answer) {\n  let stack = [start];\n  // ì´ˆê¸° ì‹œì‘ì  startë¥¼ ìŠ¤íƒì— ë¯¸ë¦¬ ì¶”ê°€í•˜ê³ , ë°©ë¬¸ ì—¬ë¶€ì— ì²´í¬í•œë‹¤\n  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„\n  //\n  let result = [];\n  while (stack.length > 0) {\n    let current = stack.pop();\n\n    for (let neighbor of graph[current]) {\n      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§ê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´\n      if (\n        !visited[neighbor]\n        // && ë¬¸ì œì— ë§ëŠ” ì¡°ê±´ ì¶”ê°€ ê°€ëŠ¥ graph[neighbor] ===, >, \u003C {X} ë“±.\n      ) {\n        //  answer++;\n        visited[neighbor] = true; // ì¡°ê±´ ì¶”ê°€ íƒ€ì´ë°ì„ ì •ë¦¬í•˜ê³  ì‹¶ë‹¤\n        stack.push(neighbor);\n      }\n    }\n    // result.push(current) -\n    // ì´ ìœ„ì¹˜ì—ì„œ pushí•˜ë©´ ìµœí•˜ìœ„ ë…¸ë“œë¶€í„° ìŒ“ì„\n    // = ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê²Œ ë˜ì„œ ë§ˆì§€ë§‰ì— reverse()í•´ì£¼ì–´ì•¼ í•œë‹¤.\n    // í•˜ì§€ë§Œ ê°€ì¥ ê¹”ë”í•œ ë°©ì‹ì¼ ìˆ˜ ìˆë‹¤.\n    // forë¬¸ ìœ„ì—ì„œ í•˜ë©´ ìì‹ë…¸ë“œë³´ë‹¤ ë¶€ëª¨ ë…¸ë“œì˜ ì •ë³´ê°€ ë¨¼ì € ìŒ“ì´ëŠ”ë°,\n    // ê²°ê³¼ê°€ ì •í™•í•´ì§€ì§€ ì•ŠëŠ”ë‹¤. ì™œì¸ì§€ëŠ” ì˜ ê¸°ì–µ ì•ˆë‚¨. -> ì´ì œ ì•ŒìŒ\n  }\n  return; // answer;\n}\n\n// offset ì‚¬ìš©í•˜ëŠ” dfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©\n\nconst offset = [\n  [0, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction dfsOffset(visited, graph, [startR, startC], answer) {\n  let stack = [[startR, startC]];\n  visited[startR][startC] = true;\n  let result = [];\n\n  while (stack.length > 0) {\n    let [curR, curC] = stack.pop();\n\n    for (let [or, oc] of offset) {\n      let [nr, nc] = [curR + or, curC + oc];\n      if (\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C graph.length &&\n        nc \u003C graph[0].length &&\n        !visited[nr][nc]\n        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§ëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..\n      ) {\n        visited[nr][nc] = true;\n        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©\n        stack.push([nr, nc]);\n      }\n    }\n    // curR, curCë¥¼ ëª¨ì•„ì•¼ í•œë‹¤ë©´, resultì— push í•´ì¤€ë‹¤.\n    result.push([curR, curC]);\n    // ì œì¼ ì²« startR,Cê°€ resultì— í‘¸ì‹œë˜ê³ \n    // ê·¸ ë‹¤ìŒ stackì˜ ê°€ì¥ ìœ„ì— ìˆëŠ” ìµœí•˜ìœ„ ë…¸ë“œê°€ ì‹¤í–‰ë¨\n  }\n\n  return answer;\n}\n```","site/content/algorithms/dfs/core.mdx","e20123afd8930b33","hash/prg1-race",{"id":115,"data":117,"body":124,"filePath":125,"digest":126,"deferredRender":24},{"title":118,"description":119,"createdAt":120,"path":121,"tags":123},"Race","programmers ë‹¬ë¦¬ê¸° ë¬¸ì œ","2025-01",[9,122],"hash",{"pattern":122,"category":122,"platform":43},"- ìˆ˜ë§ì€ ë§ˆë¼í†¤ ì„ ìˆ˜ë“¤ì´ ë§ˆë¼í†¤ì— ì°¸ì—¬í•˜ì˜€ìŠµë‹ˆë‹¤. ë‹¨ í•œ ëª…ì˜ ì„ ìˆ˜ë¥¼ ì œì™¸í•˜ê³ ëŠ” ëª¨ë“  ì„ ìˆ˜ê°€ ë§ˆë¼í†¤ì„ ì™„ì£¼í•˜ì˜€ìŠµë‹ˆë‹¤.\n- ë§ˆë¼í†¤ì— ì°¸ì—¬í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ participantì™€ ì™„ì£¼í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ completionì´ ì£¼ì–´ì§ˆ ë•Œ,\n- ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ì˜ ì´ë¦„ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.\n\n- ì œí•œì‚¬í•­\n- ë§ˆë¼í†¤ ê²½ê¸°ì— ì°¸ì—¬í•œ ì„ ìˆ˜ì˜ ìˆ˜ëŠ” 1ëª… ì´ìƒ 100,000ëª… ì´í•˜ì…ë‹ˆë‹¤.\n- completionì˜ ê¸¸ì´ëŠ” participantì˜ ê¸¸ì´ë³´ë‹¤ 1 ì‘ìŠµë‹ˆë‹¤.\n- ì°¸ê°€ìì˜ ì´ë¦„ì€ 1ê°œ ì´ìƒ 20ê°œ ì´í•˜ì˜ ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.\n- ì°¸ê°€ì ì¤‘ì—ëŠ” ë™ëª…ì´ì¸ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n- ì…ì¶œë ¥ ì˜ˆ\n\n|participant | completion | return |\n| [\"leo\", \"kiki\", \"eden\"] | [\"eden\", \"kiki\"]| \"leo\" |\n| [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"] | [\"josipa\", \"filipa\", \"marina\", \"nikola\"] | \"vinko\" |\n| [\"mislav\", \"stanko\", \"mislav\", \"ana\"] | [\"stanko\", \"ana\", \"mislav\"] | \"mislav\" |\n\n- ì…ì¶œë ¥ ì˜ˆ ì„¤ëª…\n  ì˜ˆì œ #1\n  \"leo\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #2\n\"vinko\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #3\n\"mislav\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ë‘ ëª…ì´ ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” í•œ ëª…ë°–ì— ì—†ê¸° ë•Œë¬¸ì— í•œëª…ì€ ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\n> ğŸ“Œ **Source Code:** [hash/prg1-race.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/prg1-race.js)\n\n```js\n/*\n*\n* ìˆ˜ë§ì€ ë§ˆë¼í†¤ ì„ ìˆ˜ë“¤ì´ ë§ˆë¼í†¤ì— ì°¸ì—¬í•˜ì˜€ìŠµë‹ˆë‹¤. ë‹¨ í•œ ëª…ì˜ ì„ ìˆ˜ë¥¼ ì œì™¸í•˜ê³ ëŠ” ëª¨ë“  ì„ ìˆ˜ê°€ ë§ˆë¼í†¤ì„ ì™„ì£¼í•˜ì˜€ìŠµë‹ˆë‹¤.\n* ë§ˆë¼í†¤ì— ì°¸ì—¬í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ participantì™€ ì™„ì£¼í•œ ì„ ìˆ˜ë“¤ì˜ ì´ë¦„ì´ ë‹´ê¸´ ë°°ì—´ completionì´ ì£¼ì–´ì§ˆ ë•Œ,\n* ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ì˜ ì´ë¦„ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.\n\n* ì œí•œì‚¬í•­\n* ë§ˆë¼í†¤ ê²½ê¸°ì— ì°¸ì—¬í•œ ì„ ìˆ˜ì˜ ìˆ˜ëŠ” 1ëª… ì´ìƒ 100,000ëª… ì´í•˜ì…ë‹ˆë‹¤.\n* completionì˜ ê¸¸ì´ëŠ” participantì˜ ê¸¸ì´ë³´ë‹¤ 1 ì‘ìŠµë‹ˆë‹¤.\n* ì°¸ê°€ìì˜ ì´ë¦„ì€ 1ê°œ ì´ìƒ 20ê°œ ì´í•˜ì˜ ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.\n* ì°¸ê°€ì ì¤‘ì—ëŠ” ë™ëª…ì´ì¸ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n* ì…ì¶œë ¥ ì˜ˆ\nparticipant\tcompletion\treturn\n[\"leo\", \"kiki\", \"eden\"]\t[\"eden\", \"kiki\"]\t\"leo\"\n[\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"]\t[\"josipa\", \"filipa\", \"marina\", \"nikola\"]\t\"vinko\"\n[\"mislav\", \"stanko\", \"mislav\", \"ana\"]\t[\"stanko\", \"ana\", \"mislav\"]\t\"mislav\"\n\n* ì…ì¶œë ¥ ì˜ˆ ì„¤ëª…\nì˜ˆì œ #1\n\"leo\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #2\n\"vinko\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” ì—†ê¸° ë•Œë¬¸ì— ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\nì˜ˆì œ #3\n\"mislav\"ëŠ” ì°¸ì—¬ì ëª…ë‹¨ì—ëŠ” ë‘ ëª…ì´ ìˆì§€ë§Œ, ì™„ì£¼ì ëª…ë‹¨ì—ëŠ” í•œ ëª…ë°–ì— ì—†ê¸° ë•Œë¬¸ì— í•œëª…ì€ ì™„ì£¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n*\n* */\n\nfunction solution(participant, completion) {\n  let obj = {};\n  for (let p of participant) {\n    obj[p] = !!obj[p] ? obj[p] + 1 : 1;\n  }\n\n  for (let i = 0; i \u003C completion.length; i++) {\n    if (obj[completion[i]] === undefined) {\n      continue;\n    }\n    obj[completion[i]] = obj[completion[i]] - 1;\n  }\n  console.log(\"obj\", obj);\n\n  const entries = Object.entries(obj);\n  console.log(\"entries\", entries);\n  for ([name, complete] of entries) {\n    if (complete > 0) {\n      return name;\n    }\n  }\n}\n\nlet test1P = [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"];\nlet test1C = [\"josipa\", \"filipa\", \"marina\", \"nikola\"];\nlet test2P = [\"mislav\", \"stanko\", \"mislav\", \"ana\"];\nlet test2C = [\"stanko\", \"ana\", \"mislav\"];\n\nconsole.log(\"result : \", solution(test1P, test1C));\nconsole.log(\"result : \", solution(test2P, test2C));\n```","site/content/algorithms/hash/prg1-race.mdx","b928f5ecc0b5d7ea","hash/prg3-discount",{"id":127,"data":129,"body":134,"filePath":135,"digest":136,"deferredRender":24},{"title":130,"description":131,"createdAt":30,"path":132,"tags":133},"Discount","Prg3 Discount",[9,122],{"pattern":122,"category":122,"platform":43},"> ğŸ“Œ **Source Code:** [hash/prg3-discount.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/prg3-discount.js)\n\n```js\nfunction solution(want, number, discount) {\n  const max = 10;\n  let result = 0;\n  let obj = {};\n\n  for (let i = 0; i \u003C want.length; i++) {\n    obj[want[i]] = !!obj[want[i]] ? obj[want[i]] + number[i] : number[i];\n  }\n\n  for (let i = 0; i \u003C discount.length; i++) {\n    let cart = { ...obj };\n    console.log(\"outer i\", i);\n    console.log(\"discount i\", discount[i]);\n    for (j = i; j \u003C max + i; j++) {\n      console.log(`\n      inner j : ${j}\n      ${discount[j]} :  ${cart[discount[j]]} left\n      `);\n\n      if (!cart[discount[j]]) {\n        continue;\n      }\n      cart[discount[j]] = cart[discount[j]] - 1;\n      console.log(`\n      inner j after\n      ${discount[j]} :  ${cart[discount[j]]}\n      cart: ${Object.entries(cart)}\n      `);\n    }\n    let cartResult = Object.values(cart);\n    let cartAllZero = cartResult.every((item) => item \u003C= 0);\n    console.log(`\n    ${i} index\n    ====================\n    cartResult : ${JSON.stringify(cartResult)} \n    cartAllZero : ${cartAllZero}\n    `);\n    if (cartAllZero) {\n      result++;\n    }\n  }\n\n  return result;\n}\n\nlet test1W = [\"banana\", \"apple\", \"rice\", \"pork\", \"pot\"];\nlet test1N = [3, 2, 2, 2, 1];\nlet test1D = [\n  \"chicken\",\n  \"apple\",\n  \"apple\",\n  \"banana\",\n  \"rice\",\n  \"apple\",\n  \"pork\",\n  \"banana\",\n  \"pork\",\n  \"rice\",\n  \"pot\",\n  \"banana\",\n  \"apple\",\n  \"banana\",\n];\n\nconsole.log(\"result : \", solution(test1W, test1N, test1D));\n```","site/content/algorithms/hash/prg3-discount.mdx","2c401a0fe420eac3","hash/prg6-bestmusic",{"id":137,"data":139,"body":144,"filePath":145,"digest":146,"deferredRender":24},{"title":140,"description":141,"createdAt":30,"path":142,"tags":143},"Best Music","ë² ìŠ¤íŠ¸ ì•¨ë²” ë¬¸ì œ",[9,122],{"pattern":122,"category":122,"platform":43},"## ë¬¸ì œ\n\nìŠ¤íŠ¸ë¦¬ë° ì‚¬ì´íŠ¸ì—ì„œ ì¥ë¥´ ë³„ë¡œ ê°€ì¥ ë§ì´ ì¬ìƒëœ ë…¸ë˜ë¥¼ ë‘ ê°œì”© ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë ¤ í•©ë‹ˆë‹¤.\në…¸ë˜ëŠ” ê³ ìœ  ë²ˆí˜¸ë¡œ êµ¬ë¶„í•˜ë©°, ë…¸ë˜ë¥¼ ìˆ˜ë¡í•˜ëŠ” ê¸°ì¤€ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nì†í•œ ë…¸ë˜ê°€ ë§ì´ ì¬ìƒëœ ì¥ë¥´ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nì¥ë¥´ ë‚´ì—ì„œ ë§ì´ ì¬ìƒëœ ë…¸ë˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nì¥ë¥´ ë‚´ì—ì„œ ì¬ìƒ íšŸìˆ˜ê°€ ê°™ì€ ë…¸ë˜ ì¤‘ì—ì„œëŠ” ê³ ìœ  ë²ˆí˜¸ê°€ ë‚®ì€ ë…¸ë˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\në…¸ë˜ì˜ ì¥ë¥´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ìì—´ ë°°ì—´ genresì™€ ë…¸ë˜ë³„ ì¬ìƒ íšŸìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ë°°ì—´ playsê°€ ì£¼ì–´ì§ˆ ë•Œ,\në² ìŠ¤íŠ¸ ì•¨ë²”ì— ë“¤ì–´ê°ˆ ë…¸ë˜ì˜ ê³ ìœ  ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.\n\n### ì œí•œì‚¬í•­\n\ngenres[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ë˜ì˜ ì¥ë¥´ì…ë‹ˆë‹¤.\nplays[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ë˜ê°€ ì¬ìƒëœ íšŸìˆ˜ì…ë‹ˆë‹¤.\ngenresì™€ playsì˜ ê¸¸ì´ëŠ” ê°™ìœ¼ë©°, ì´ëŠ” 1 ì´ìƒ 10,000 ì´í•˜ì…ë‹ˆë‹¤.\nì¥ë¥´ ì¢…ë¥˜ëŠ” 100ê°œ ë¯¸ë§Œì…ë‹ˆë‹¤.\nì¥ë¥´ì— ì†í•œ ê³¡ì´ í•˜ë‚˜ë¼ë©´, í•˜ë‚˜ì˜ ê³¡ë§Œ ì„ íƒí•©ë‹ˆë‹¤.\nëª¨ë“  ì¥ë¥´ëŠ” ì¬ìƒëœ íšŸìˆ˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤.\n\n> ğŸ“Œ **Source Code:** [hash/prg6-bestmusic.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/prg6-bestmusic.js)\n\n```js\n/*\në¬¸ì œ ì„¤ëª…\nìŠ¤íŠ¸ë¦¬ë° ì‚¬ì´íŠ¸ì—ì„œ ì¥ë¥´ ë³„ë¡œ ê°€ì¥ ë§ì´ ì¬ìƒëœ ë…¸ë˜ë¥¼ ë‘ ê°œì”© ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë ¤ í•©ë‹ˆë‹¤.\në…¸ë˜ëŠ” ê³ ìœ  ë²ˆí˜¸ë¡œ êµ¬ë¶„í•˜ë©°, ë…¸ë˜ë¥¼ ìˆ˜ë¡í•˜ëŠ” ê¸°ì¤€ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nì†í•œ ë…¸ë˜ê°€ ë§ì´ ì¬ìƒëœ ì¥ë¥´ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nì¥ë¥´ ë‚´ì—ì„œ ë§ì´ ì¬ìƒëœ ë…¸ë˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\nì¥ë¥´ ë‚´ì—ì„œ ì¬ìƒ íšŸìˆ˜ê°€ ê°™ì€ ë…¸ë˜ ì¤‘ì—ì„œëŠ” ê³ ìœ  ë²ˆí˜¸ê°€ ë‚®ì€ ë…¸ë˜ë¥¼ ë¨¼ì € ìˆ˜ë¡í•©ë‹ˆë‹¤.\në…¸ë˜ì˜ ì¥ë¥´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ìì—´ ë°°ì—´ genresì™€ ë…¸ë˜ë³„ ì¬ìƒ íšŸìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ë°°ì—´ playsê°€ ì£¼ì–´ì§ˆ ë•Œ,\në² ìŠ¤íŠ¸ ì•¨ë²”ì— ë“¤ì–´ê°ˆ ë…¸ë˜ì˜ ê³ ìœ  ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.\n\nì œí•œì‚¬í•­\ngenres[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ë˜ì˜ ì¥ë¥´ì…ë‹ˆë‹¤.\nplays[i]ëŠ” ê³ ìœ ë²ˆí˜¸ê°€ iì¸ ë…¸ë˜ê°€ ì¬ìƒëœ íšŸìˆ˜ì…ë‹ˆë‹¤.\ngenresì™€ playsì˜ ê¸¸ì´ëŠ” ê°™ìœ¼ë©°, ì´ëŠ” 1 ì´ìƒ 10,000 ì´í•˜ì…ë‹ˆë‹¤.\nì¥ë¥´ ì¢…ë¥˜ëŠ” 100ê°œ ë¯¸ë§Œì…ë‹ˆë‹¤.\nì¥ë¥´ì— ì†í•œ ê³¡ì´ í•˜ë‚˜ë¼ë©´, í•˜ë‚˜ì˜ ê³¡ë§Œ ì„ íƒí•©ë‹ˆë‹¤.\nëª¨ë“  ì¥ë¥´ëŠ” ì¬ìƒëœ íšŸìˆ˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤.\nì…ì¶œë ¥ ì˜ˆ\ngenres\tplays\treturn\n[\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"]\t[500, 600, 150, 800, 2500]\t[4, 1, 3, 0]\nì…ì¶œë ¥ ì˜ˆ ì„¤ëª…\nclassic ì¥ë¥´ëŠ” 1,450íšŒ ì¬ìƒë˜ì—ˆìœ¼ë©°, classic ë…¸ë˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nê³ ìœ  ë²ˆí˜¸ 3: 800íšŒ ì¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 0: 500íšŒ ì¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 2: 150íšŒ ì¬ìƒ\npop ì¥ë¥´ëŠ” 3,100íšŒ ì¬ìƒë˜ì—ˆìœ¼ë©°, pop ë…¸ë˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\nê³ ìœ  ë²ˆí˜¸ 4: 2,500íšŒ ì¬ìƒ\nê³ ìœ  ë²ˆí˜¸ 1: 600íšŒ ì¬ìƒ\në”°ë¼ì„œ pop ì¥ë¥´ì˜ [4, 1]ë²ˆ ë…¸ë˜ë¥¼ ë¨¼ì €, classic ì¥ë¥´ì˜ [3, 0]ë²ˆ ë…¸ë˜ë¥¼ ê·¸ë‹¤ìŒì— ìˆ˜ë¡í•©ë‹ˆë‹¤.\n\nì¥ë¥´ ë³„ë¡œ ê°€ì¥ ë§ì´ ì¬ìƒëœ ë…¸ë˜ë¥¼ ìµœëŒ€ ë‘ ê°œê¹Œì§€ ëª¨ì•„ ë² ìŠ¤íŠ¸ ì•¨ë²”ì„ ì¶œì‹œí•˜ë¯€ë¡œ 2ë²ˆ ë…¸ë˜ëŠ” ìˆ˜ë¡ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n* */\n\nfunction solution(genres, plays) {\n  let totalObj = {};\n  let pObj = {};\n  let result = [];\n\n  for (let i = 0; i \u003C genres.length; i++) {\n    totalObj[genres[i]] = !!totalObj[genres[i]]\n      ? totalObj[genres[i]] + plays[i]\n      : plays[i];\n    pObj[genres[i]] = [...(pObj[genres[i]] ?? []), [i, plays[i]]];\n  }\n\n  let playEntries = Object.entries(pObj);\n  let totalEntries = Object.entries(totalObj).sort((a, b) => b[1] - a[1]);\n  let totalRank = totalEntries.map(([g]) => g);\n\n  for (let genre in pObj) {\n    pObj[genre] = pObj[genre]\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 2)\n      .map(([name]) => name);\n  }\n\n  console.log(`pObj: ${Object.entries(pObj)}`);\n\n  console.log(\"totalEntries\", totalEntries);\n  console.log(\"playEntries\", playEntries);\n\n  for (let i = 0; i \u003C totalRank.length; i++) {\n    let songsIndex = pObj[totalRank[i]];\n    console.log(\"songsIndex\", songsIndex);\n    result.push(songsIndex);\n  }\n  return result.flat();\n}\n\nlet test1G = [\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"];\nlet test1P = [500, 600, 150, 800, 2500];\n\nconsole.log(\"result : \", solution(test1G, test1P));\n```","site/content/algorithms/hash/prg6-bestmusic.mdx","bf75fb1950881570","hash/prg7-report",{"id":147,"data":149,"body":154,"filePath":155,"digest":156,"deferredRender":24},{"title":150,"description":151,"createdAt":30,"path":152,"tags":153},"Report","Prg7 Report",[9,122],{"pattern":122,"category":122,"platform":43},"> ğŸ“Œ **Source Code:** [hash/prg7-report.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/prg7-report.js)\n\n```js\nfunction solution(id_list, report, k) {\n  let reported = {};\n  let reporter = {};\n  let count = {};\n\n  for (let id of id_list) {\n    reported[id] = 0;\n    reporter[id] = [];\n    count[id] = 0;\n  }\n\n  const reportArr = [...new Set(report)].map((item) => item.split(\" \"));\n  for (const [rp, user] of reportArr) {\n    reported[user] += 1;\n    reporter[rp] = [...reporter[rp], user];\n    console.log(`\n    ì‹ ê³ ì : ${rp} \n    ìœ„ë°˜ì : ${user} \n    ì‹ ê³ ë‹¹í•œ íšŸìˆ˜ : ${reported[user]}`);\n  }\n\n  const bannedArr = Object.entries(reported).filter(([, count]) => count >= k);\n\n  for (const [bannedUser] of bannedArr) {\n    for (const rUser in reporter) {\n      console.log(\"bannedUser in 2 for\", bannedUser);\n      console.log(\"reporter in 2 for\", rUser);\n\n      if (reporter[rUser].includes(bannedUser)) {\n        count[rUser] += 1;\n      }\n    }\n  }\n  console.log(\"reported\", reported);\n  console.log(\"reporter\", reporter);\n  console.log(\"bannedArr\", bannedArr);\n  console.log(\"count\", count);\n\n  let result = Object.values(count);\n  return result;\n}\n\nlet id_list1 = [\"muzi\", \"frodo\", \"apeach\", \"neo\"];\nlet report1 = [\n  \"muzi frodo\",\n  \"apeach frodo\",\n  \"frodo neo\",\n  \"muzi neo\",\n  \"apeach muzi\",\n];\nlet k1 = 2;\n\nconsole.log(\"result : \", solution(id_list1, report1, k1));\n```","site/content/algorithms/hash/prg7-report.mdx","0f4cd803e281d620","hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°",{"id":157,"data":159,"body":164,"filePath":165,"digest":166,"deferredRender":24},{"title":160,"description":161,"createdAt":30,"path":162,"tags":163},"ì—°ìŠµ1 ë‘ìˆ˜ë”í•˜ê¸°","* ë¬¸ì œ: arrì˜ ë‘ ìˆ˜ë¥¼ ë”í•˜ì—¬ targetì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë°˜í™˜ * arrì€ ìµœëŒ€ 10^4 O(n) * *",[9,122],{"pattern":122,"category":122},"> ğŸ“Œ **Source Code:** [hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.js)\n\n```js\n/*\n * ë¬¸ì œ: arrì˜ ë‘ ìˆ˜ë¥¼ ë”í•˜ì—¬ targetì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë°˜í™˜\n * arrì€ ìµœëŒ€ 10^4 O(n)\n *\n * */\n\nfunction solution(arr, target) {\n  let k = new Set();\n  for (let i = 0; i \u003C arr.length; i++) {\n    k.add(target - arr[i]);\n  }\n\n  for (let i = 0; i \u003C arr.length; i++) {\n    let comple = target - arr[i];\n    if (k.has(arr[i]) && comple > 0 && comple !== arr[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconsole.log(\"result\", solution([1, 2, 3, 4, 8], 6));\nconsole.log(\"result\", solution([2, 3, 5, 9], 10));\n```","site/content/algorithms/hash/ì—°ìŠµ1-ë‘ìˆ˜ë”í•˜ê¸°.mdx","2c7c0489e73c4d05","hash/ì—°ìŠµ2-ë¬¸ìì—´ë¹„êµ",{"id":167,"data":169,"body":174,"filePath":175,"digest":176,"deferredRender":24},{"title":170,"description":171,"createdAt":30,"path":172,"tags":173},"ì—°ìŠµ2 ë¬¸ìì—´ë¹„êµ","* ë¬¸ì œ: queryListê°€ strListì— ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜ * arrì€ ìµœëŒ€ 10^4 O(n) * *",[9,122],{"pattern":122,"category":122},"# ë¬¸ì œ: queryListê°€ strListì— ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜\n\n- arrì€ ìµœëŒ€ 10^4 O(n)\n\n> ğŸ“Œ **Source Code:** [hash/ì—°ìŠµ2-ë¬¸ìì—´ë¹„êµ.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/hash/ì—°ìŠµ2-ë¬¸ìì—´ë¹„êµ.js)\n\n```js\n/*\n * ë¬¸ì œ: queryListê°€ strListì— ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜, ì•„ë‹ˆë©´ falseë¥¼ ë‹´ì•„ ë°°ì—´ë¡œ ë°˜í™˜\n * arrì€ ìµœëŒ€ 10^4 O(n)\n *\n * */\n\nfunction solution(strList, queryList) {\n  let result = [];\n  let strObj = new Set();\n\n  for (let i = 0; i \u003C strList.length; i++) {\n    strObj.add(strList[i]);\n  }\n\n  for (let i = 0; i \u003C queryList.length; i++) {\n    if (strObj.has(queryList[i])) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result;\n}\n\nlet test1SL = [\"apple\", \"banana\", \"cherry\"];\nlet test1QL = [\"banana\", \"kiwi\", \"melon\", \"apple\"];\nlet test2SL = [\"a\", \"b\", \"Q\"];\nlet test2QL = [\"c\", \"d\", \"e\", \"A\", \"a\", \"b\", \"Z\", \"Q\"];\n\nconsole.log(\"result\", solution(test1SL, test1QL));\nconsole.log(\"result\", solution(test2SL, test2QL));\n```","site/content/algorithms/hash/ì—°ìŠµ2-ë¬¸ìì—´ë¹„êµ.mdx","566dbdef82056e3e","dynamic-programming/leetcode-5-longest-palindromic-substring",{"id":177,"data":179,"body":185,"filePath":186,"digest":187,"deferredRender":24},{"title":180,"description":181,"createdAt":16,"path":182,"tags":184},"LeetCode 5. Longest Palindromic Substring","LeetCode problem 5",[9,18,183],"dynamic-programming",{"pattern":183,"category":18},"# Topics\n\n- String\n- Two Pointers\n- Dynamic Programming\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/longest-palindromic-substring/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // ì¤‘ë³µ ë¬¸ìê°€ ì¡´ì¬í•˜ë©´ ì•ì—ì„œ ì œê±°í•˜ë©´ì„œ ìœˆë„ìš° ì´ë™\n    /**@note ì´ ë¶€ë¶„ì—ì„œ s[start]ë¡œ startë¥¼ ì›€ì§ì´ê³ , setì—ì„œ ì œê±°í•¨\n     * @note Sliding Windowì˜ ê°€ë³€ í¬ê¸°ê°€ êµ¬í˜„ë¨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // ìƒˆë¡œìš´ ë¬¸ì ì¶”ê°€\n    /** @note ì—…ë°ì´íŠ¸ ì‹œì ì€ setì˜ ë³€ê²½ ì´í›„ì— ì‹¤í–‰í•¨ **/\n    longest = Math.max(longest, end - start + 1); // ê¸¸ì´ ê°±ì‹ \n  }\n\n  return longest;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ì„±ëŠ¥ ìµœì í™”. reverseë¡œ ë¹„êµí•˜ëŠ” ë¹„ìš©ì´ ë„ˆë¬´ í¬ë‹¤\n2. ì˜ˆì™¸ì²˜ë¦¬: í•œê¸€ì, ê°™ì€ ë‘ê¸€ìì¼ë•Œ ë“±. ì¢€ ë” ì¶”ìƒì ì¸ ë¡œì§ìœ¼ë¡œ ê°œë³„ ì˜ˆì™¸ì²˜ë¦¬ ì•ˆí•  ìˆ˜ë„ ìˆì„í…ë°.\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length === 1) return s;\n  let longest = 0,\n    start = 0,\n    n = s.length,\n    result = \"\";\n  while (start \u003C n - 1) {\n    for (let end = start + 1; end \u003C n; end++) {\n      let slice = s.slice(start, end + 1); // + 1 ?\n      let reverse = slice.split(\"\").reverse().join(\"\");\n      if (slice === reverse && slice.length >= longest) {\n        result = slice;\n        longest = slice.length;\n      }\n    }\n    start++;\n  }\n\n  return result || s[0];\n};\n```","site/content/algorithms/dynamic-programming/leetcode-5-longest-palindromic-substring.mdx","f39ade1f2a0da135","queue/core",{"id":188,"data":190,"body":194,"filePath":195,"digest":196,"deferredRender":24},{"title":191,"description":191,"createdAt":30,"path":192,"tags":193},"Queue",[9,64],{"pattern":66,"category":64},"> ğŸ“Œ **Source Code:** [queue/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/queue/core.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const head = this.items[this.front];\n    delete this.items[this.front];\n    this.front++;\n    return head;\n  }\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n```","site/content/algorithms/queue/core.mdx","fefb1195511f7006","link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ",{"id":197,"data":199,"body":204,"filePath":205,"digest":206,"deferredRender":24},{"title":200,"description":200,"createdAt":30,"path":201,"tags":203},"ì–‘ë°©í–¥ ê³µë¬¸ì œ",[9,202],"link-list",{"pattern":202,"category":202},"> ğŸ“Œ **Source Code:** [link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.js)\n\n```js\nconst solution = (balls, orders) => {\n  let head = 0;\n  let tail = balls.length - 1;\n  let result = [];\n  let wait = new Set();\n  const next = 1;\n  const prev = -1;\n\n  for (let i = 0; i \u003C orders.length; i++) {\n    if (orders[i] === balls[head]) {\n      console.log(`head : ${balls[head]}`);\n      result.push(orders[i]);\n      head++;\n      while (wait.has(orders[i] + next)) {\n        result.push(orders[i] + next);\n        wait.delete(orders[i] + next);\n        head++;\n      }\n    } else if (orders[i] === balls[tail]) {\n      result.push(orders[i]);\n      if (wait.has(orders[i] + prev)) {\n        while (wait.has(orders[i] + prev)) {\n          result.push(orders[i] + prev);\n          wait.delete(orders[i] + prev);\n          tail--;\n        }\n      }\n      tail--;\n    } else {\n      wait.add(orders[i]);\n    }\n  }\n  return result;\n};\n\nconsole.log(\n  \"result : \",\n  solution([1, 2, 3, 4, 5, 6, 7], [7, 5, 6, 4, 2, 1, 3]),\n);\n```","site/content/algorithms/link-list/ì–‘ë°©í–¥-ê³µë¬¸ì œ.mdx","856a16d0a116ad0d","search/leetcode-3-longest-substring",{"id":207,"data":209,"body":215,"filePath":216,"digest":217,"deferredRender":24},{"title":210,"description":211,"createdAt":16,"path":212,"tags":214},"LeetCode 3. Longest Substring Without Repeating Characters","LeetCode problem",[9,18,213],"sliding-window",{"pattern":213,"category":18},"# Topics\n\n- Hash Table\n- String\n- Sliding Window\n\n## ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/surrounded-regions)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = 0;\n\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n\n    // ì¤‘ë³µ ë¬¸ìê°€ ì¡´ì¬í•˜ë©´ ì•ì—ì„œ ì œê±°í•˜ë©´ì„œ ìœˆë„ìš° ì´ë™\n    /**@note ì´ ë¶€ë¶„ì—ì„œ s[start]ë¡œ startë¥¼ ì›€ì§ì´ê³ , setì—ì„œ ì œê±°í•¨\n     * @note Sliding Windowì˜ ê°€ë³€ í¬ê¸°ê°€ êµ¬í˜„ë¨\n     * **/\n    while (set.has(char)) {\n      set.delete(s[start]);\n      start++;\n    }\n\n    set.add(char); // ìƒˆë¡œìš´ ë¬¸ì ì¶”ê°€\n    /** @note ì—…ë°ì´íŠ¸ ì‹œì ì€ setì˜ ë³€ê²½ ì´í›„ì— ì‹¤í–‰í•¨ **/\n    longest = Math.max(longest, end - start + 1); // ê¸¸ì´ ê°±ì‹ \n  }\n\n  return longest;\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ìƒˆë¡œìš´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜\n\nreturnListë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ë ¤ í–ˆìœ¼ë‚˜ next ì¶”ê°€ ë°©ì‹ì´ í‹€ë¦¼.\nì˜¬ë°”ë¥¸ ë°©ì‹ì€ ìƒˆë¡œìš´ ListNodeë¥¼ ìƒì„±í•˜ê³  current.nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\në°˜ë³µë¬¸ì—ì„œ next ì¶”ê°€ ë°©ë²• ë¬¸ì œ\n\nreturnList(start, next)ëŠ” ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ.\ndummyHead ë…¸ë“œë¥¼ ë‘ê³  current í¬ì¸í„°ë¥¼ í™œìš©í•˜ì—¬ nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\n\n2. ë¦¬ìŠ¤íŠ¸ ìˆ«ì ë³€í™˜ ì˜¤ë¥˜ (getAllNum í•¨ìˆ˜)\n\n```\nwhile (li?.val) â†’ while (li !== null)\nnums.unshift(li.val) ëŒ€ì‹  nums.push(li.val)\njoin(\"\") * 1 ëŒ€ì‹  Number(join(\"\")) ë˜ëŠ” BigInt(join(\"\")) ì‚¬ìš©í•´ì•¼ í° ìˆ«ì ì²˜ë¦¬ ê°€ëŠ¥.\n\n```\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  let set = new Set();\n  let start = 0;\n  let longest = -1;\n  for (let end = 0; end \u003C s.length; end++) {\n    let char = s[end];\n    if (!set.has(char)) {\n      set.add(char);\n    } else {\n      longest = Math.max(longest, end - start + 1);\n      start++;\n      // set ì´ˆê¸°í™”? ì—…ë°ì´íŠ¸? ì–´ë–»ê²Œ í•´ì•¼í•˜ì§€.\n    }\n  }\n\n  return longest;\n};\n```","site/content/algorithms/search/leetcode-3-longest-substring.mdx","3698cc47d28aa050","search/leetcode-4-median-of-two-sorted-array",{"id":218,"data":220,"body":226,"filePath":227,"digest":228,"deferredRender":24},{"title":221,"description":222,"createdAt":16,"path":223,"tags":225},"LeetCode 4. Median of Two Sorted Arrays","LeetCode problem 4",[9,18,224],"binary-search",{"pattern":224,"category":18},"# Topics\n\n- Array\n- Binary Search\n- Divide and Conquer\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\nì‚¬ì‹¤ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ í’€ì–´ì•¼í•˜ëŠ” ë¬¸ì œì¸ë°,\n\n## ì •ë‹µ\n\n```js\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  let merged = [...nums1, ...nums2].sort((a, b) => a - b);\n  let size = merged.length,\n    isEven = size % 2 === 0;\n  let pointer = isEven ? Math.floor(size / 2) - 1 : Math.floor(size / 2);\n\n  if (isEven) {\n    return (merged[pointer] + merged[pointer + 1]) / 2;\n  } else {\n    return merged[pointer];\n  }\n};\n```\n\n## ì‚¬ê³  ê³¼ì •\n\nì²˜ìŒì— setìœ¼ë¡œ ì‹œë„í•˜ë ¤ í–ˆìœ¼ë‚˜, í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 44ë²ˆì— ì¤‘ë³µ ìˆ«ì í—ˆìš©ì´ ê»´ìˆì–´ì„œ ìˆ˜ì •í•¨.\n\n1. Median ì •ì˜\n   - ìˆ«ì ì´í•©ì˜ ì¤‘ê°„ ê°’ì¸ì§€, ë§ ê·¸ëŒ€ë¡œ ë°°ì—´ì˜ ê°€ì¥ ì¤‘ì•™ì„ ëœ»í•˜ëŠ” ì§€ í™•ì¸. í›„ì.\n   - ë³‘í•©ëœ ë‘ ë°°ì—´ì˜ ê¸¸ì´ê°€ í™€ìˆ˜ ì¼ ë•ŒëŠ” Math.floor(length / 2)ì˜ ì¸ë±ìŠ¤ ê°’\n   - ì§ìˆ˜ì¼ ë•ŒëŠ” Math.floor(length / 2)ì™€ +1ì˜ ìš”ì†Œë¥¼ ë”í•œ ë’¤ / 2\n2. ë‘ ë°°ì—´ì„ í•©í•œ ë’¤ sort = merged - ì¤‘ê°„ ê°’ì˜ íƒìƒ‰ ëŒ€ìƒ\n3. 1ë²ˆì—ì„œ ì¤‘ê°„ ê°’ì´ ë°°ì—´ ê¸¸ì´ì— ë”°ë¼ ë‹¬ë¼ì§ì„ í™•ì¸í•¨. ê·¸ëŒ€ë¡œ ë°˜í™˜ê°’ ê³„ì‚°í•¨\n\n- ì¤‘ë³µ ìš”ì†Œ í—ˆìš©, ë¹„í—ˆìš©ì— ëŒ€í•œ íŒíŠ¸ê°€ ì—†ì–´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì—ì„œ ì°¾ì•„ëƒ„.","site/content/algorithms/search/leetcode-4-median-of-two-sorted-array.mdx","11bb72a9a98eb9b3","heap/min-heap",{"id":229,"data":231,"body":237,"filePath":238,"digest":239,"deferredRender":24},{"title":232,"description":233,"createdAt":30,"path":234,"tags":236},"Min Heap","size 0 ì‹œ null ë°˜í™˜",[9,235],"heap",{"pattern":235,"category":235},"> ğŸ“Œ **Source Code:** [heap/min-heap.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/heap/min-heap.js)\n\n```js\nclass MinHeap {\n  constructor() {\n    this.items = [];\n  }\n\n  size() {\n    return this.items.length;\n  }\n  swap(a, b) {\n    [this.items[a], this.items[b]] = [this.items[b], this.items[a]];\n  }\n  pop() {\n    // size 0 ì‹œ null ë°˜í™˜\n    if (this.size() \u003C= 0) {\n      return null;\n    }\n\n    // minì´ì—ˆë˜ headì˜ ê°’ë§Œ ì €ì¥í•¨\n    const min = this.items[0];\n    // ìƒˆë¡œìš´ í—¤ë“œë¡œ ê¼¬ë¦¬ì— ìˆë˜ ê°’ì„ ë„£ìŒ\n    this.items[0] = this.items[this.size() - 1];\n    // ê·¸ë‹¤ìŒ 0 ì¸ë±ìŠ¤ ìœ„ì—ì„œë¶€í„° ë‚´ë ¤ê°€ë©´ì„œ ì •ë ¬í•¨.\n    this.bubbleDown();\n\n    // ì €ì¥í•´ë‘” í í—¤ë“œë¥¼ ë°˜í™˜\n    return min;\n  }\n  bubbleDown() {\n    // ìœ„ì—ì„œë¶€í„° ë‚´ë ¤ê°\n    let index = 0;\n\n    // index * 2 + 1 í˜„ì¬ ì¸ë±ìŠ¤ * 2ì— ì™œ + 1ì¼ê¹Œ?\n    // ë¶€ëª¨ ë…¸ë“œì—ì„œ ì˜¤ë¥¸ìª½ ë…¸ë“œê°€ ê°€ì¥ í° ìˆ«ìë¥¼ ë”í•´ì§ \u003C ë§ˆì§€ë§‰ ë…¸ë“œ ì¸ë±ìŠ¤ë‘ ë¹„êµí•´ì„œ ë” ì‘ì„ ë•Œê¹Œì§€\n    while (index * 2 + 1 \u003C this.size() - 1) {\n      let leftIndex = index * 2 + 1;\n      let rightIndex = index * 2 + 2;\n      let smallerIndex =\n        // right indexê°€ leftë³´ë‹¤ í•­ìƒ í¬ë‹ˆê¹Œ (+2), ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë³´ë‹¤ ì‘ì•„ì•¼í•¨\n        rightIndex \u003C this.size() - 1 &&\n        // ì—¬ê¸°ì„œ ë” ì‘ì€ ìª½ì˜ ë¹„êµ ëŒ€ìƒ ì ìš©ë¨\n        // ì–‘ ì˜† ìì‹ ì¤‘ì— ë” ì‘ì€ ìª½ì´ë‘ ë¶€ëª¨ë¥¼ ë¹„êµí•´ì•¼í•¨.\n        // ì–¸ì œë‚˜ ê°™ê±°ë‚˜ ì‘ì•„ë„ ë˜ë‚˜?\n        this.items[rightIndex] \u003C= this.items[leftIndex]\n          ? rightIndex\n          : leftIndex;\n      // ì•„ë˜ê°€ ì¤‘ë‹¨ì \n      if (this.items[index] \u003C= this.tems[smallerIndex]) {\n        break;\n      }\n\n      // í˜„ì¬ ì¸ë±ìŠ¤ì˜ ê°’ì´ ìì‹ì˜ ë” ì‘ì€ìª½ë³´ë‹¤ ë” í° ê²½ìš°\n      // ìŠ¤ì™‘ + ë¡œì»¬ indexë¥¼ ìì‹ìœ¼ë¡œ ë³€ê²½\n      this.swap(index, smallerIndex);\n      index = smallerIndex;\n    }\n  }\n  push(data) {\n    this.items.push(data);\n    // ë°°ì—´(ìŠ¤íƒ)ì— ë°ì´í„° ë„£ê³ \n    this.bubbleUp();\n    // ë°”ë‹¥ë¶€í„° ì •ë ¬ ì‹œì‘\n  }\n  bubbleUp() {\n    let index = this.size() - 1;\n    // ë¡œì»¬ ì¸ë±ìŠ¤. ì‘ì—…ì˜ ì‹œì‘ì . ì´ê²Œ ë°”ë€Œì–´ì•¼ ë°˜ë³µë¬¸ì´ ë©ˆì¶¤\n    // ë°”ë‹¥ë¶€í„° ì‹œì‘í•´ì„œ index 0 ì´ìƒì¼ ë•Œê¹Œì§€\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n\n      // Minì˜ bubbleUp ì¡°ê±´ ì¤‘ë‹¨ì .\n      // ë¶€ëª¨ ë…¸ë“œê°€ ê°™ê±°ë‚˜ ë” ì‘ì„ ë•Œ ë©ˆì¶¤\n      if (this.items[parentIndex] \u003C= this.items[index]) {\n        break;\n      }\n      // ë¶€ëª¨ ë…¸ë“œê°€ ë” í° ê²½ìš° ë°”ê¿”ì•¼í•¨, itemsì˜ ì¸ë±ìŠ¤, ë¶€ëª¨ ì¸ë±ìŠ¤ì˜ ê°’ì„ ë°”ê¿ˆ\n      this.swap(index, parentIndex);\n      // ë¡œì»¬ ì¸ë±ìŠ¤ë¥¼ ë¶€ëª¨ë¡œ ë°”ê¿ˆ (tail - 1 / 2)\n      index = parentIndex;\n    }\n  }\n}\n```","site/content/algorithms/heap/min-heap.mdx","f80fbef9c05e99d4","search/leetcode-add-two-numbers",{"id":240,"data":242,"body":248,"filePath":249,"digest":250,"deferredRender":24},{"title":243,"description":211,"createdAt":16,"path":244,"tags":247},"Linked List - LeetCode 2. Add Two Numbers",[9,18,245,246],"linked-list","two-pointer",{"pattern":246,"category":18},"[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/add-two-numbers/)\n\n# Topics\n\n- Linked List\n- Math\n- Recursion\n\n# ë¬¸ì œ í¬ì¸íŠ¸\n\n1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬, ë‹¤ìŒ í¬ì¸í„° ì—°ê²°\n2. **ë°˜ë³µë¬¸**ì—ì„œ ë‹¤ìŒ í¬ì¸í„° ì—°ê²° ë¡œì§\n\n- `count[i]`ë‘ í˜„ì¬ íƒìƒ‰ ë…¸ë“œ(`board[r][c]`)ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ë•Œ íƒìƒ‰ ì¤‘ë‹¨\n\n3. ë°©ë¬¸ ì—…ë°ì´íŠ¸ ì‹œì ì˜ ì¤‘ìš”ì„± (ê²½ë¡œ íƒìƒ‰ì˜ ê²½ìš°, ì¸ì ‘ ë…¸ë“œ ëª¨ë‘ ë°©ë¬¸í•œ ì´í›„)\n\n## ì •ë‹µ\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n  let carry = 0;\n\n  while (l1 !== null || l2 !== null || carry > 0) {\n    let sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10); // 10ì„ ë„˜ìœ¼ë©´ ì˜¬ë¦¼ê°’ ì €ì¥\n\n    current.next = new ListNode(sum % 10); // í˜„ì¬ ë…¸ë“œ ì¶”ê°€\n    current = current.next; // í¬ì¸í„° ì´ë™\n\n    l1 = l1?.next || null;\n    l2 = l2?.next || null;\n  }\n\n  return dummyHead.next; // ì‹¤ì œ ë¦¬ìŠ¤íŠ¸ ì‹œì‘ì  ë°˜í™˜\n};\n```\n\n## ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n### ì ‘ê·¼ ë¬¸ì œì \n\n1. ìƒˆë¡œìš´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜\n\nreturnListë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ë ¤ í–ˆìœ¼ë‚˜ next ì¶”ê°€ ë°©ì‹ì´ í‹€ë¦¼.\nì˜¬ë°”ë¥¸ ë°©ì‹ì€ ìƒˆë¡œìš´ ListNodeë¥¼ ìƒì„±í•˜ê³  current.nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\në°˜ë³µë¬¸ì—ì„œ next ì¶”ê°€ ë°©ë²• ë¬¸ì œ\n\nreturnList(start, next)ëŠ” ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ.\ndummyHead ë…¸ë“œë¥¼ ë‘ê³  current í¬ì¸í„°ë¥¼ í™œìš©í•˜ì—¬ nextë¡œ ì—°ê²°í•´ì•¼ í•¨.\n\n2. ë¦¬ìŠ¤íŠ¸ ìˆ«ì ë³€í™˜ ì˜¤ë¥˜ (getAllNum í•¨ìˆ˜)\n\n```\nwhile (li?.val) â†’ while (li !== null)\nnums.unshift(li.val) ëŒ€ì‹  nums.push(li.val)\njoin(\"\") * 1 ëŒ€ì‹  Number(join(\"\")) ë˜ëŠ” BigInt(join(\"\")) ì‚¬ìš©í•´ì•¼ í° ìˆ«ì ì²˜ë¦¬ ê°€ëŠ¥.\n\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  // ë‘ ë¦¬ìŠ¤íŠ¸ì—ì„œ í•©ì„ êµ¬í•¨\n  function getAllNum(list) {\n    let nums = [];\n    let li = list;\n    while (li?.val) {\n      nums.unshift(li.val);\n      li = li.next;\n    }\n    return nums.join(\"\") * 1;\n  }\n\n  let sum = getAllNum(l1) + getAllNum(l2);\n  let result = String(sum)\n    .split(\"\")\n    .map((char) => char * 1);\n\n  console.log(result);\n  const returnList = new ListNode();\n\n  // ë°˜ë³µë¬¸ì—ì„œ ì§€ê¸ˆ ë§í¬ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€, nextë¥¼ ì–´ë–»ê²Œ ì¶”ê°€í•´ì•¼ í•  ì§€ ëª¨ë¥´ê² ìŒ\n  while (result.length > 0) {\n    const start = result.pop();\n    returnList(start, next);\n  }\n};\n```","site/content/algorithms/search/leetcode-add-two-numbers.mdx","0692aaeb8def1589","set/prg1-pokemon",{"id":251,"data":253,"body":259,"filePath":260,"digest":261,"deferredRender":24},{"title":254,"description":255,"createdAt":30,"path":256,"tags":258},"Pokemon","Prg1 Pokemon",[9,257],"set",{"pattern":257,"category":257,"platform":43},"> ğŸ“Œ **Source Code:** [set/prg1-pokemon.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/set/prg1-pokemon.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg1-pokemon.mdx","f6befe0ae83b87d3","set/prg2-words",{"id":262,"data":264,"body":269,"filePath":270,"digest":271,"deferredRender":24},{"title":265,"description":266,"createdAt":30,"path":267,"tags":268},"Words","Prg2 Words",[9,257],{"pattern":257,"category":257,"platform":43},"> ğŸ“Œ **Source Code:** [set/prg2-words.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/set/prg2-words.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg2-words.mdx","9519feda277824d9","set/prg4-students",{"id":272,"data":274,"body":279,"filePath":280,"digest":281,"deferredRender":24},{"title":275,"description":276,"createdAt":30,"path":277,"tags":278},"Students","ì—¬ë²Œ ë‚˜ëˆ” ê³„ì‚°",[9,257],{"pattern":257,"category":257,"platform":43},"> ğŸ“Œ **Source Code:** [set/prg4-students.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/set/prg4-students.js)\n\n```js\nfunction solution(n, lost, reserve) {\n  let students = {};\n  for (let i = 1; i \u003C= n; i++) {\n    students[i] = 1;\n  }\n\n  for (let r = 0; r \u003C reserve.length; r++) {\n    let num = reserve[r];\n    students[num] += 1;\n  }\n\n  for (let l = 0; l \u003C lost.length; l++) {\n    let num = lost[l];\n    students[num] -= 1;\n  }\n\n  // ì—¬ë²Œ ë‚˜ëˆ” ê³„ì‚°\n  // lost ë¹¼ê³  ë‚˜ì„œ ë‚˜ë¨¸ì§€ í•™ìƒë“¤ ì¤‘ 0ì¸ í•™ìƒë§Œ ì°¾ì•„ì„œ\n  // ì• ë’¤ë¡œ 1 ì´ìƒì¼ ì‹œ ê³µìœ í•¨\n  for (let sKey in students) {\n    if (students[sKey] === 0) {\n      let next = Number(sKey) + 1;\n      let prev = Number(sKey) - 1;\n\n      if (prev > 0 && students[prev] > 1) {\n        students[prev] = students[prev] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n\n      if (next \u003C= n && students[next] > 1) {\n        students[next] = students[next] - 1;\n        students[sKey] = 1;\n        continue;\n      }\n    }\n  }\n\n  const result = Object.values(students).filter((item) => item > 0);\n  return result.length;\n}\n\nconsole.log(\"result : \", solution(5, [2, 4], [1, 3, 5]));\nconsole.log(\"result : \", solution(5, [2, 4], [3]));\nconsole.log(\"result : \", solution(3, [3], [1]));\n```","site/content/algorithms/set/prg4-students.mdx","4fc6e309de8c98ff","set/prg5-islands",{"id":282,"data":284,"body":289,"filePath":290,"digest":291,"deferredRender":24},{"title":285,"description":286,"createdAt":30,"path":287,"tags":288},"Islands","parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜",[9,257],{"pattern":257,"category":257,"platform":43},"> ğŸ“Œ **Source Code:** [set/prg5-islands.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/set/prg5-islands.js)\n\n```js\n// parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜\n// ë£¨íŠ¸ ë…¸ë“œë€ ì§‘í•©ì˜ ëŒ€í‘œì (ì¦‰, ìµœìƒìœ„ ë¶€ëª¨ ë…¸ë“œ)\n// ê²½ë¡œ ì••ì¶•ì„ í†µí•´ íƒìƒ‰ ê²½ë¡œë¥¼ ìµœì í™”\nfunction find(parents, x) {\n  // xê°€ ìì‹ ì˜ ë¶€ëª¨ ë…¸ë“œë¼ë©´ (ì¦‰, ë£¨íŠ¸ ë…¸ë“œë¼ë©´)\n  if (parents[x] == x) {\n    return x; // ë£¨íŠ¸ ë…¸ë“œ ë°˜í™˜\n  }\n  // xê°€ ë£¨íŠ¸ê°€ ì•„ë‹ˆë©´, ì¬ê·€ í˜¸ì¶œì„ í†µí•´ ë£¨íŠ¸ë¥¼ ì°¾ìŒ\n  // ì°¾ìœ¼ë©´ì„œ ë¶€ëª¨ë¥¼ ë£¨íŠ¸ë¡œ ê°±ì‹  (ê²½ë¡œ ì••ì¶•)\n  parents[x] = find(parents, parents[x]);\n  return parents[x]; // ìµœì¢… ë£¨íŠ¸ ë°˜í™˜\n}\n\n// ë‘ ë…¸ë“œì˜ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜ (Union by Rank)\n// RankëŠ” íŠ¸ë¦¬ì˜ ê¹Šì´ë¥¼ ì˜ë¯¸í•˜ë©°, ë” ë‚®ì€ íŠ¸ë¦¬ë¥¼ ë†’ì€ íŠ¸ë¦¬ì— ë¶™ì„\nfunction union(parent, rank, x, y) {\n  const xroot = find(parent, x); // xì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n  const yroot = find(parent, y); // yì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n\n  // Rankë¥¼ ë¹„êµí•˜ì—¬ íŠ¸ë¦¬ì˜ ê· í˜• ìœ ì§€\n  if (rank[xroot] \u003C rank[yroot]) {\n    parent[xroot] = yroot; // xroot íŠ¸ë¦¬ë¥¼ yrootì— ì—°ê²°\n  } else if (rank[xroot] > rank[yroot]) {\n    parent[yroot] = xroot; // yroot íŠ¸ë¦¬ë¥¼ xrootì— ì—°ê²°\n  } else {\n    // ë­í¬ê°€ ê°™ë‹¤ë©´ xrootë¥¼ ë¶€ëª¨ë¡œ ì„¤ì •í•˜ê³ , ë­í¬ë¥¼ 1 ì¦ê°€\n    parent[yroot] = xroot;\n    rank[xroot] += 1;\n  }\n}\n\n// ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST) ë¹„ìš© ê³„ì‚° í•¨ìˆ˜\nfunction solution(n, costs) {\n  // 1. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬\n  costs.sort((a, b) => a[2] - b[2]); // MSTë¥¼ ìœ„í•´ ê°€ì¥ ë‚®ì€ ë¹„ìš©ì˜ ê°„ì„ ì„ ë¨¼ì € ì²˜ë¦¬\n\n  // 2. parent ë°°ì—´ê³¼ rank ë°°ì—´ ì´ˆê¸°í™”\n  // ê° ë…¸ë“œëŠ” ì²˜ìŒì—” ìê¸° ìì‹ ì´ ë£¨íŠ¸ì¸ ë…ë¦½ ì§‘í•©\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0); // ëª¨ë“  ë…¸ë“œì˜ ì´ˆê¸° RankëŠ” 0\n\n  let minCost = 0; // MSTì˜ ì´ ë¹„ìš©\n  let edges = 0; // í˜„ì¬ê¹Œì§€ MSTì— í¬í•¨ëœ ê°„ì„ ì˜ ìˆ˜\n\n  // 3. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° MSTë¥¼ êµ¬ì„±\n  for (const edge of costs) {\n    if (edges == n - 1) {\n      // MSTì˜ ê°„ì„  ìˆ˜ê°€ n-1ì´ë©´ ì¤‘ë‹¨\n      break;\n    }\n    // edge = [ë…¸ë“œ1, ë…¸ë“œ2, ë¹„ìš©]\n    const x = find(parent, edge[0]); // ë…¸ë“œ1ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n    const y = find(parent, edge[1]); // ë…¸ë“œ2ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°\n\n    if (x !== y) {\n      // ë‘ ë…¸ë“œê°€ ê°™ì€ ì§‘í•©ì— ì†í•˜ì§€ ì•Šìœ¼ë©´ ì—°ê²°\n      union(parent, rank, x, y); // ë‘ ë…¸ë“œë¥¼ ê°™ì€ ì§‘í•©ìœ¼ë¡œ ë¬¶ìŒ\n      minCost += edge[2]; // ê°„ì„ ì˜ ë¹„ìš©ì„ ì´ ë¹„ìš©ì— ì¶”ê°€\n      edges += 1; // ê°„ì„  ìˆ˜ ì¦ê°€\n    }\n    // ë‘ ë…¸ë“œê°€ ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ì—°ê²°í•˜ì§€ ì•ŠìŒ (ì‚¬ì´í´ ë°©ì§€)\n  }\n\n  return minCost; // MSTì˜ ìµœì†Œ ë¹„ìš© ë°˜í™˜\n}\n\n// ì˜ˆì œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤\nconsole.log(\n  \"result : \",\n  solution(4, [\n    [0, 1, 1],\n    [0, 2, 2],\n    [1, 2, 5],\n    [1, 3, 1],\n    [2, 3, 8],\n  ]),\n);\n// ê²°ê³¼: 4 (MSTì˜ ìµœì†Œ ë¹„ìš©)\n```","site/content/algorithms/set/prg5-islands.mdx","d2ed6b754d1ce8ef","set/prg3-phone_book",{"id":292,"data":294,"body":299,"filePath":300,"digest":301,"deferredRender":24},{"title":295,"description":296,"createdAt":30,"path":297,"tags":298},"Phone Book","Prg3 Phone Book",[9,257],{"pattern":257,"category":257,"platform":43},"> ğŸ“Œ **Source Code:** [set/prg3-phone_book.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/set/prg3-phone_book.js)\n\n```js\nfunction solution(nums) {\n  let poke = new Set(nums);\n  return poke.size > nums.length / 2 ? nums.length / 2 : poke.size;\n}\n\nlet test1 = [3, 1, 2, 3];\nlet test2 = [3, 3, 3, 2, 2, 4];\nlet test3 = [3, 3, 3, 2, 2, 2];\n\nconsole.log(\"result : \", solution(test1));\nconsole.log(\"result : \", solution(test2));\nconsole.log(\"result : \", solution(test3));\n```","site/content/algorithms/set/prg3-phone_book.mdx","c95598bbb5f89627","stack/132-pattern",{"id":302,"data":304,"body":311,"filePath":312,"digest":313,"deferredRender":24},{"title":305,"description":306,"createdAt":307,"path":308,"tags":310},"[LeetCode] 456. 132 Pattern (132 íŒ¨í„´)","ë°°ì—´ì—ì„œ íŠ¹ì • íŒ¨í„´ì„ ì°¾ëŠ” ìŠ¤íƒ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ","2024-05-29",[9,309],"stack",{"pattern":309,"category":309,"platform":18},"## LeetCode 456. 132 Pattern (132 íŒ¨í„´)\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/132-pattern/)\n\n**ì œí•œì‹œê°„: 15ë¶„**\n\n### ë¬¸ì œ ì„¤ëª…\n\nì •ìˆ˜ ë°°ì—´ `nums`ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, 132 íŒ¨í„´ì„ ì°¾ì•„ ë°˜í™˜í•œë‹¤.\n\n> 132 íŒ¨í„´ì´ë€?\n\n132 íŒ¨í„´ì´ë€ ì„¸ ê°œì˜ ì •ìˆ˜ `nums[i]`, `nums[j]`, `nums[k]`ë¡œ ì´ë£¨ì–´ì§„ ë¶€ë¶„ ìˆ˜ì—´ë¡œ, ë‹¤ìŒ ë‘ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•œë‹¤.\n\n- `i \u003C j \u003C k`\n- `nums[i] \u003C nums[k] \u003C nums[j]`\n\nì´ëŸ¬í•œ íŒ¨í„´ì´ ì¡´ì¬í•˜ë©´ trueë¥¼, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ falseë¥¼ ë°˜í™˜í•˜ëŠ” ë¬¸ì œë‹¤.\n\n**ì œì•½ ì¡°ê±´:**\n\nì‹œê°„ ë³µì¡ë„: **O(n)**\n\n- `1 \u003C= n \u003C= 2 \\* 10^5`\n- `-10^9 \u003C= nums[i] \u003C= 10^9`\n\n### í’€ì´\n\nì´ ë¬¸ì œì˜ í•´ì„¤ê³¼ ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •ì„ ë³´ë©´ì„œ, ë°°ì—´ ìˆœíšŒ ë°©í–¥ì„ ìµìˆ™í•œ ë„êµ¬ë¡œ ì‚¼ì•„ì•¼ì§€ ì‹¶ì—ˆë‹¤. ì™ ì§€ ìˆœíšŒë¥¼ 0ë¶€í„° ì‹œì‘í•˜ë ¤ëŠ” ìŠµê´€ì´ ìˆëŠ” ê²ƒ ê°™ë‹¤. \u003Cbr/>\ní’€ì´ëŠ” ë‹¤ìŒ ë§í¬ë¥¼ ì°¸ê³ í–ˆë‹¤. ([ë§í¬](https://leetcode.com/problems/132-pattern/solutions/6604083/using-stack-easy-solution))\n\n- ìŠ¤íƒì„ ë’¤ë¶€í„° ìˆœíšŒí•˜ë©´ì„œ í˜„ì¬ ê°’(`nums[i]`)ì´ ìŠ¤íƒ ë§¨ ìœ„ ê°’ë³´ë‹¤ í´ ë•Œ, ìŠ¤íƒì—ì„œ ê°’ì„ êº¼ë‚´ `thirdNum`ì— ì €ì¥í•œë‹¤.\n    - ì´ë ‡ê²Œ í•˜ë©´ ìŠ¤íƒì— ë‚¨ì•„ìˆëŠ” ê°’ì€ í•­ìƒ `thirdNum`ë³´ë‹¤ ì‘ì€ ê°’ì´ ëœë‹¤.\n- ë°˜ë³µë¬¸ ë‚´ë¶€ì—ì„œ `true`ë¥¼, ì™¸ë¶€ì—ì„œ ë¬´ì¡°ê±´ `false`ë¥¼ ë°˜í™˜í•œë‹¤.\n- `i`ê°€ 0ì´ ë˜ê¸° ì „ì— ë¯¸ë¦¬ `true`ë¥¼ ë°˜í™˜í•˜ì—¬ ë°˜ë³µì„ ì¤„ì¼ ìˆ˜ ìˆê³ , ë§ˆì§€ë§‰ì— ì¡°ê±´ì„ í™•ì¸í•˜ëŠ” ê²ƒë³´ë‹¤ ë¹ ë¥´ë‹¤.\n- ë°˜ë³µë¬¸ ì²« ì‚¬ì´í´ì—ì„œë§Œ `nums[i] \u003C thirdNum === false`ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ `-Infinity`ë¥¼ í™œìš©í•˜ëŠ” ê²Œ ê½¤ ì¸ìƒì ì´ë‹¤.\n\n```js\nvar find132pattern = function (nums) {\n  const N = nums.length;\n  // ìŠ¤íƒì„ ì‚¬ìš©í•˜ì—¬ nums[j] í›„ë³´ë“¤ì„ ì €ì¥\n  const stack = [];\n  // nums[k]ê°€ ë  í›„ë³´ ê°’ (nums[j]ë³´ë‹¤ ì‘ì€ ê°’)\n  let thirdNum = -Infinity; // ë’¤ì— ìˆëŠ” ìˆ«ìê°€ í•­ìƒ í¬ë‹¤. ì•„ë˜ ë…¸íŠ¸ ì°¸ì¡°\n\n  // ë°°ì—´ì„ ë’¤ì—ì„œë¶€í„° ìˆœíšŒ\n  for (let i = N - 1; i >= 0; i--) {\n    // í˜„ì¬ ê°’ì´ thirdNum(nums[k])ë³´ë‹¤ ì‘ìœ¼ë©´ 132 íŒ¨í„´ ë°œê²¬\n    if (nums[i] \u003C thirdNum) {\n      return true;\n    }\n\n    // ìŠ¤íƒì´ ë¹„ì–´ìˆì§€ ì•Šê³ , í˜„ì¬ ê°’ì´ ìŠ¤íƒì˜ ë§¨ ìœ„ ê°’ë³´ë‹¤ í¬ë©´\n    // ìŠ¤íƒì—ì„œ ê°’ì„ êº¼ë‚´ thirdNum ì—…ë°ì´íŠ¸\n    while (stack.length  && nums[i] > stack[stack.length - 1]) {\n      thirdNum = stack.pop();\n    }\n\n    // í˜„ì¬ ê°’ì„ ìŠ¤íƒì— ì¶”ê°€\n    stack.push(nums[i]);\n  }\n\n  return false;\n};\n```\n\nJavaScriptì—ì„œ `Infinity`ì™€ `-Infinity`ì˜ ì°¨ì´\n\n- `Infinity`: ì–‘ì˜ ë¬´í•œëŒ€. ëª¨ë“  ìˆ«ìë³´ë‹¤ í° ê°’\n- `-Infinity`: ìŒì˜ ë¬´í•œëŒ€. ëª¨ë“  ìˆ«ìë³´ë‹¤ ì‘ì€ ê°’\n\nì´ ë¬¸ì œì—ì„œëŠ” ë’¤ì— ìˆëŠ” ìˆ«ìê°€ í•­ìƒ ì»¤ì•¼í•œë‹¤. ë”°ë¼ì„œ ì´ˆê¸°ê°’ì„ -Infinityë¡œ ì„¤ì •í•œë‹¤.\n\n# ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\n- 3ê°œì˜ í¬ì¸í„°ë¥¼ ì›€ì§ì´ë©° ì¡°ê±´ì„ í™•ì¸í•œë‹¤\n- í¬ì¸í„°ë¥¼ ìµœëŒ€í•œ ì›€ì§ì¸ í›„, ì¸ë±ìŠ¤ì™€ ê°’ì´ ëª¨ë‘ ì¡°ê±´ì— ë§ëŠ” ì§€ í™•ì¸í•œë‹¤.\n\nì œí•œ ì‹œê°„ì´ ëë‚  ë•Œ ì¯¤, ë‚´ê°€ ë– ì˜¬ë¦° ë°©ë²•ì€ í¬ì¸í„°ì˜ ìµœì†Œ/ìµœì¥ ê¸¸ì´ë¥¼ ì°¾ì„ ë•Œ ì“°ëŠ” ê²Œ ì•„ë‹ê¹Œ ì‹¶ì—ˆë‹¤. \u003Cbr/>\nê·¸ì œì„œì•¼ ë¬¸ì œ ì ‘ê·¼ì„ ì˜ëª»í–ˆë‹¤ëŠ” ì‚¬ì‹¤ì„ ê¹¨ë‹¬ì•˜ë‹¤. ì¡°ê±´ì— ë§ì§€ ì•Šì•„ í¬ì¸í„°ê°€ ì „í˜€ ì›€ì§ì´ì§€ ì•Šì•„ë„ trueê°€ ë°˜í™˜ë  ìˆ˜ ìˆë‹¤.\n\n```js\nvar find132pattern = function (nums) {\n  if (nums.length \u003C 1) return false;\n  const N = nums.length;\n  let start = 0,\n    mid = Math.floor(N / 2),\n    end = N - 1;\n\n  function getCorrect(cur, target) {\n    return cur \u003C target && nums[cur] \u003C nums[target];\n  }\n\n  while (getCorrect(start, mid)) {\n    start++; // ì´ ì•ˆì— í¬ì¸í„° ì´ë™ ë°©ë²•ì„ ì˜ ëª°ëë‹¤.\n  }\n\n  while (getCorrect(start, mid)) {\n    mid--; // ë§ˆì°¬ê°€ì§€ë¡œ ì´ ì•ˆì— í¬ì¸í„° ì´ë™ì„ ì˜ ëª°ëë‹¤.\n  }\n\n  while (getCorrect(mid, end)) {\n    end--;\n  }\n  // í¬ì¸í„° ì´ë™ì´ ì „í˜€ ì—†ì´ ì¡°ê±´ì— ë§ê±°ë‚˜ í‹€ë¦´ ìˆ˜ ìˆë‹¤.\n  return (\n    start \u003C mid && mid \u003C end && nums[start] \u003C nums[mid] && nums[mid] \u003C nums[end]\n  );\n};\n```","site/content/algorithms/stack/132-pattern.mdx","11a45281d9ea83e1","stack/core",{"id":314,"data":316,"body":320,"filePath":321,"digest":322,"deferredRender":24},{"title":317,"description":317,"createdAt":30,"path":318,"tags":319},"Stack",[9,64],{"pattern":66,"category":64},"> ğŸ“Œ **Source Code:** [core/stack.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/stack/core.js)\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n    this.size = 0;\n  }\n  push(item) {\n    this.items.push(item);\n    this.size++;\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    this.size--;\n    return this.items.pop();\n  }\n  isEmpty() {\n    return this.size === 0;\n  }\n}\n```","site/content/algorithms/stack/core.mdx","c05beea9e8210849","stack/min-stack",{"id":323,"data":325,"body":332,"filePath":333,"digest":334,"deferredRender":24},{"title":326,"description":327,"createdAt":328,"path":329,"tags":330},"ìµœì†Œê°’ ìŠ¤íƒ êµ¬í˜„í•˜ê¸°","O(1) ì‹œê°„ ë³µì¡ë„ë¡œ ìµœì†Œê°’ì„ ì¡°íšŒí•  ìˆ˜ ìˆëŠ” ìŠ¤íƒ êµ¬í˜„","2023-11-24",[9,309],{"category":309,"platform":18,"pattern":331},"data-design","## LeetCode 155. Min Stack (ìµœì†Œê°’ ìŠ¤íƒ)\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/min-stack/)\n\n**ì œí•œì‹œê°„: 15ë¶„**\n\n# ë¬¸ì œ ì„¤ëª…\n\nìŠ¤íƒì„ ì„¤ê³„í•˜ë˜, ì¼ë°˜ì ì¸ ìŠ¤íƒ ì—°ì‚°(push, pop, top)ê³¼ í•¨ê»˜ ìµœì†Œê°’ì„ `O(1)` ì‹œê°„ ë³µì¡ë„ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆëŠ” `getMin` ë©”ì„œë“œë¥¼ ì§€ì›í•œë‹¤.\n\në‹¤ìŒ ê¸°ëŠ¥ì„ ê°€ì§„ `MinStack` í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤:\n\n- `MinStack()`: ìŠ¤íƒ ê°ì²´ë¥¼ ì´ˆê¸°í™”í•œë‹¤.\n- `void push(int val)`: ìš”ì†Œ valì„ ìŠ¤íƒì— ì¶”ê°€í•œë‹¤.\n- `void pop()`: ìŠ¤íƒ ë§¨ ìœ„ì˜ ìš”ì†Œë¥¼ ì œê±°í•œë‹¤.\n- `int top()`: ìŠ¤íƒ ë§¨ ìœ„ì˜ ìš”ì†Œë¥¼ ê°€ì ¸ì˜¨ë‹¤.\n- `int getMin()`: ìŠ¤íƒì—ì„œ ìµœì†Œ ìš”ì†Œë¥¼ ê²€ìƒ‰í•œë‹¤.\n\nëª¨ë“  í•¨ìˆ˜ì— ëŒ€í•´ O(1) ì‹œê°„ ë³µì¡ë„ì˜ ì†”ë£¨ì…˜ì„ êµ¬í˜„í•´ì•¼ í•œë‹¤.\n\n# ì •ë‹µ\n\n```js\nvar MinStack = function () {\n  this.stack = [];\n  this.min = null;\n};\n\nMinStack.prototype.push = function (val) {\n  this.stack.push(val);\n  this.min = Math.min(...this.stack); // push í›„ ìµœì†Œê°’ ì—…ë°ì´íŠ¸\n};\n\nMinStack.prototype.pop = function () {\n  this.stack.pop();\n  this.min = Math.min(...this.stack); // pop í›„ ìµœì†Œê°’ ì—…ë°ì´íŠ¸\n};\n\nMinStack.prototype.top = function () {\n  return this.stack[this.stack.length - 1];\n};\n\nMinStack.prototype.getMin = function () {\n  return this.min;\n};\n```\n\n# ì˜¤ë‹µ ì‚¬ê³  ê³¼ì •\n\nìµœì†Œ `Heap`ì„ ìƒê°í•˜ë©° í’€ì—ˆì§€ë§Œ 15ë¶„ ë‚´ë¡œ í’€ì§€ ëª»í–ˆë‹¤. \u003Cpr/>\në„ˆë¬´ ì–´ë µê²Œ ìƒê°í–ˆë‹¤! ê·¸ëƒ¥ this.minê³¼ ìŠ¤íƒë§Œ ìˆìœ¼ë©´ ëœë‹¤. \u003Cbr/>\n\n> ê¸°ë³¸ ì»¨ì…‰:\n\n- í´ë¡œì €ë¥¼ ì‚¬ìš©í•´ ì¸ìŠ¤í„´ìŠ¤ ë‚´ë¶€ì˜ ì €ì¥ì†Œë¥¼ ë§Œë“ ë‹¤.\n  - this.stack, this.sorted, this.size\n- `this`ë¥¼ í†µí•´ ë©”ì„œë“œ ë‚´ë¶€ì—ì„œ ì €ì¥ì†Œì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.\n- ë©”ì„œë“œ ë‚´ë¶€ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.\n  - this.sort() // `sorted`ë‘ ë³€ìˆ˜ëª…ì´ í—·ê°ˆë ¸ë‹¤ ì„¼ìŠ¤ ë¶€ì¡±\n  - this.top() // ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ë°˜í™˜\n  - this.getMin() // ì •ë ¬ëœ ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ë°˜í™˜\n  - this.pop() // ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ì œê±°\n  - this.push() // ìŠ¤íƒì˜ ë§ˆì§€ë§‰ì— ìš”ì†Œë¥¼ ì¶”ê°€\n\n```js\nvar MinStack = function () {\n  function getTop() {\n    return this.stack[this.size - 1];\n  }\n  function getSort() {\n    this.sorted.sort((a, b) => a - b);\n  }\n  this.stack = [];\n  this.sorted = [...this.stack];\n  this.size = this.stack.length;\n  this.top = getTop;\n  this.sort = getSort;\n};\n\nMinStack.prototype.push = function (val) {\n  console.log(\"this\");\n  this.stack.push(val);\n  this.sorted.push(val);\n  this.size++;\n  if (!this.sort.length > 0) {\n    this.sort();\n    this.min = this.sort[0];\n  }\n};\n\nMinStack.prototype.pop = function () {\n  this.size--;\n  if (!this.sort.length > 0) {\n    this.sorted = this.sorted.filter((item) => this.top());\n    this.min = this.sorted[0];\n  } else {\n    this.min = null;\n  }\n  return this.stack.pop();\n};\n\nMinStack.prototype.top = function () {\n  return this.stack[stack.length - 1];\n};\n\nMinStack.prototype.getMin = function () {\n  return this.sorted[0];\n};\n```","site/content/algorithms/stack/min-stack.mdx","bfaddb7dbf663305","stack/remove-duplicate-lexicographical",{"id":335,"data":337,"body":343,"filePath":344,"digest":345,"deferredRender":24},{"title":338,"createdAt":339,"path":340,"tags":342},"[LeetCode] 316. Remove Duplicate Letters (ì¤‘ë³µ ë¬¸ì ì œê±°)","2025-04-01",[9,309,341],"greedy",{"pattern":341,"category":309,"platform":18},"## LeetCode 316. Remove Duplicate Letters (ì¤‘ë³µ ë¬¸ì ì œê±°)\n\n[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/remove-duplicate-letters/)\n\n**ì œí•œì‹œê°„: 15ë¶„**\n\n### ë¬¸ì œ ì„¤ëª…\n\në¬¸ìì—´ `s`ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,\n\n- ì¤‘ë³µëœ ë¬¸ìë¥¼ ì œê±°í•˜ì—¬ ê° ë¬¸ìê°€ í•œ ë²ˆë§Œ ë‚˜íƒ€ë‚˜ë„ë¡ í•˜ê³ \n- ë¬¸ìì˜ ê°€ëŠ¥í•œ ëª¨ë“  ê²°ê³¼ ì¤‘ì—ì„œ ì‚¬ì „ìˆœìœ¼ë¡œ ê°€ì¥ ì‘ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•œë‹¤\n\n**ì œì•½ ì¡°ê±´:**\n\n- `1 \u003C= s.length \u003C= 10^4`\n\n**ì¤‘ìš” ë‹¨ì„œ (ì˜ˆì‹œ)**\n\n```\nì…ë ¥: s = \"cbacdcbc\"\nì¶œë ¥: \"acdb\"\n```\n\në¬¸ì œëŠ” ì¤‘ë³µì—†ëŠ” ë¬¸ìë¥¼ \"**Lexicographical**\"ë¡œ ì •ë ¬í•˜ë¼ê³  í•œë‹¤. \u003Cbr/>\nì‚¬ì „ ì•ŒíŒŒë²³ ìˆœì„œë¡œ ì •ë ¬í•˜ë¼ëŠ” ëœ»ìœ¼ë¡œ ì´í•´í–ˆì§€ë§Œ í•¨ì •ì´ ìˆì—ˆë‹¤. \u003Cbr/>\nì‚¬ì „ ìˆœ ì •ë ¬ì´ë©´ ì™œ \"abcd\"ê°€ ì•„ë‹Œ \"acdb\"ì¸ê°€? \u003Cbr/>\nì´ëŠ” `s`ë¥¼ ì¤‘ë³µ ì—†ëŠ” ë¶€ë¶„ì„ ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆ„ê³ , ì‚¬ì „ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° ë•Œë¬¸ì´ë‹¤. \u003Cbr/>\n\n### í’€ì´\n\n```js\nvar removeDuplicateLetters = function (s) {\n  const lastIndex = {}; // ê° ë¬¸ìì˜ ë§ˆì§€ë§‰ ë“±ì¥ ì¸ë±ìŠ¤ ì €ì¥\n  const visited = new Set(); // ì´ë¯¸ ìŠ¤íƒì— ì¶”ê°€ëœ ë¬¸ì ì¶”ì \n  const stack = []; // ê²°ê³¼ ë¬¸ìì—´ êµ¬ì„±ì„ ìœ„í•œ ìŠ¤íƒ\n\n  // ê° ë¬¸ìì˜ ë§ˆì§€ë§‰ ë“±ì¥ ì¸ë±ìŠ¤ ê³„ì‚°\n  for (let i = 0; i \u003C s.length; i++) {\n    lastIndex[s[i]] = i;\n  }\n\n  for (let i = 0; i \u003C s.length; i++) {\n    const char = s[i];\n\n    // ì´ë¯¸ ë°©ë¬¸í•œ ë¬¸ìëŠ” ê±´ë„ˆëœ€\n    if (visited.has(char)) continue;\n\n    // ìŠ¤íƒì˜ top ë¬¸ìê°€ í˜„ì¬ ë¬¸ìë³´ë‹¤ ì‚¬ì „ìˆœìœ¼ë¡œ í¬ê³ ,\n    // í•´ë‹¹ ë¬¸ìê°€ ë‚˜ì¤‘ì— ë‹¤ì‹œ ë“±ì¥í•  ê²½ìš° ìŠ¤íƒì—ì„œ ì œê±°\n    while (\n      stack.length > 0 &&\n      stack[stack.length - 1] > char &&\n      lastIndex[stack[stack.length - 1]] > i\n    ) {\n      const removedChar = stack.pop();\n      visited.delete(removedChar); // ì œê±°ëœ ë¬¸ìëŠ” ë°©ë¬¸ í‘œì‹œ í•´ì œ\n    }\n\n    // í˜„ì¬ ë¬¸ìë¥¼ ìŠ¤íƒì— ì¶”ê°€í•˜ê³  ë°©ë¬¸ í‘œì‹œ\n    stack.push(char);\n    visited.add(char);\n  }\n\n  return stack.join(\"\");\n};\n```\n\n### ì˜¤ë‹µ í’€ì´\n\n[ë¬¸ì ì••ì¶• ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/60057)ì˜ í’€ì´ë¥¼ ë– ì˜¬ë¦¬ë©° í’€ì—ˆë‹¤.\ní•˜ì§€ë§Œ ë¬¸ìë¥¼ ë°˜ë³µ ì—†ëŠ” ìˆœì„œë¡œ ì¡°ê°ë‚´ëŠ” ê²ƒì´ ë¬¸ì œì˜€ë‹¤.\n\n1. ë¬¸ìì—´ ì‹œì‘ ì¸ë±ìŠ¤ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤.\n2. ì‹œì‘ ì¸ë±ìŠ¤ì—ì„œ ì¤‘ë³µ ê¸€ìê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë¬¸ìë¥¼ Setì— ì €ì¥í•œë‹¤.\n3. ì¤‘ë³µ ê¸€ìê°€ ë‚˜ì˜¤ë©´ ì €ì¥ëœ Setì„ ë°°ì—´ì— ì €ì¥í•œë‹¤.\n4. ì‹œì‘ ì¸ë±ìŠ¤ë¥¼ ì¤‘ë³µ ê¸€ìì˜ ì¸ë±ìŠ¤ë¡œ ì—…ë°ì´íŠ¸í•˜ê³  ë°˜ë³µí•œë‹¤.\n5. ë°˜ë³µì´ ëë‚˜ë©´ ë°°ì—´ì— ì €ì¥ëœ Setì„ ì •ë ¬í•œë‹¤.\n6. ì •ë ¬ëœ Setì„ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì¹œë‹¤.\n7. ê²°ê³¼ ë¬¸ìì—´ì„ ë°˜í™˜í•œë‹¤.\n\ní•˜ì§€ë§Œ ì´ ë°©ë²•ì€ \"ë¬¸ìë¥¼ ì¡°ê°ë‚´ì–´ ì €ì¥\"í•˜ëŠ” ë°©ì‹ì—ì„œ 2ì¤‘ í¬ë¬¸ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤.\nì•ì„  \"ë¬¸ì ì••ì¶•\" ë¬¸ì œì™€ ìœ ì‚¬í•˜ê²Œ ëŠê¼ˆì§€ë§Œ, ì‚¬ì‹¤ ì´ ë¬¸ì œëŠ” ìŠ¤íƒì„ ì‚¬ìš©í•´ì•¼ í–ˆë‹¤.\n\n```js\nvar removeDuplicateLetters = function (s) {\n  const N = s.length;\n  let start = 0,\n    setArr = [];\n\n  // 2ì¤‘ í¬ë¬¸ ì—†ì´ íƒìƒ‰í•˜ëŠ” ë°©ë²•ì„ ëª»ë– ì˜¬ë¦¼\n  while (start \u003C N - 1) {\n    let set = new Set(),\n      next = start + 1;\n    set.add(s[start]);\n\n    while (!set.has(s[next])) {\n      // nextê°€ ì•„ë‹ˆë¼ s[next]ë¡œ ì ‘ê·¼í•´ì•¼ í•¨\n      set.add(s[next]);\n      next++;\n    }\n    // setì„ ë°°ì—´ì— ì €ì¥ í›„ í¬ì¸í„° ì—…ë°ì´íŠ¸\n    setArr.push(set);\n    start++;\n  }\n};\n```","site/content/algorithms/stack/remove-duplicate-lexicographical.mdx","7ed7702240f32c56","simulation/pr1-rotateclock",{"id":346,"data":348,"body":354,"filePath":355,"digest":356,"deferredRender":24},{"title":349,"description":350,"createdAt":30,"path":351,"tags":353},"Pr1 Rotateclock","ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜",[9,352],"simulation",{"pattern":352,"category":352},"ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜\n\n> ğŸ“Œ **Source Code:** [simulation/pr1-rotateclock.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/simulation/pr1-rotateclock.js)\n\n```js\n// ë°°ì—´ arrì´ ì£¼ì–´ì§ˆ ì‹œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ në²ˆ íšŒì „í•˜ëŠ” í•¨ìˆ˜\n\nfunction rotate(arr) {\n  let result = Array.from({ length: arr.length }, () =>\n    Array(arr.length).fill(0),\n  );\n  for (let i = 0; i \u003C arr.length; i++) {\n    for (let j = 0; j \u003C arr.length; j++) {\n      result[j][result.length - 1 - i] = arr[i][j];\n    }\n  }\n  return result;\n}\n\nfunction rotateClock(arr, n) {\n  let result;\n  for (let i = 0; i \u003C= n; i++) {\n    result = rotate(arr);\n  }\n  return result;\n}\n\nconsole.log(\n  `result : ${rotateClock(\n    [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n      [13, 14, 15, 16],\n    ],\n    1,\n  )}`,\n);\n```","site/content/algorithms/simulation/pr1-rotateclock.mdx","617120dfbb035225","simulation/pr2-matrix-multiply",{"id":357,"data":359,"body":363,"filePath":364,"digest":365,"deferredRender":24},{"title":360,"description":360,"createdAt":30,"path":361,"tags":362},"Pr2 Matrix Multiply",[9,352],{"pattern":352,"category":352},"> ğŸ“Œ **Source Code:** [simulation/pr2-matrix-multiply.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/simulation/pr2-matrix-multiply.js)\n\n```js\nfunction multiplyMatrix(arr1, arr2) {\n  const size = arr1.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      for (let k = 0; k \u003C size; k++) {\n        result[i][j] += arr1[i][k] * arr2[k][j];\n      }\n    }\n  }\n  return result;\n}\n\nfunction transposeMatrix(arr) {\n  const size = arr.length;\n  const result = Array.from({ length: size }, () => Array(size).fill(0));\n\n  for (let i = 0; i \u003C size; i++) {\n    for (let j = 0; j \u003C size; j++) {\n      result[i][j] += arr[j][i];\n    }\n  }\n  return result;\n}\n\nfunction solution(arr1, arr2) {\n  const multiplied = multiplyMatrix(arr1, arr2);\n  const result = transposeMatrix(multiplied);\n\n  return result;\n}\n\nconsole.log(\n  `result : ${JSON.stringify(\n    solution(\n      [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n      ],\n      [\n        [9, 8, 7],\n        [6, 5, 4],\n        [3, 2, 1],\n      ],\n    ),\n  )}`,\n);\n```","site/content/algorithms/simulation/pr2-matrix-multiply.mdx","f919a714f6474be8","simulation/pr3-snail",{"id":366,"data":368,"body":373,"filePath":374,"digest":375,"deferredRender":24},{"title":369,"description":370,"createdAt":30,"path":371,"tags":372},"Pr3 Snail","nì„ ì…ë ¥ë°›ì•„ ë‹¬íŒ½ì´ì²˜ëŸ¼ 1~nê¹Œì§€ ìˆ«ìê°€ ì±„ì›Œì§„",[9,352],{"pattern":352,"category":352},"> ğŸ“Œ **Source Code:** [simulation/pr3-snail.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/simulation/pr3-snail.js)\n\n```js\n// nì„ ì…ë ¥ë°›ì•„ ë‹¬íŒ½ì´ì²˜ëŸ¼ 1~nê¹Œì§€ ìˆ«ìê°€ ì±„ì›Œì§„\n// 2ì°¨ì› ë°°ì—´ì„ return\n// TODO ë‹¤ì‹œ í•´ë³´ê¸°\n/*\nreturn :\n[\n[1,2,3],\n[8,9,4],\n[7,6,5]\n]\n */\n\nfunction solution(n) {\n  let arr = Array.from({ length: n }, () => Array(n).fill(0));\n}\n```","site/content/algorithms/simulation/pr3-snail.mdx","6c425d65f01d2cb5","simulation/prg1-binary",{"id":376,"data":378,"body":383,"filePath":384,"digest":385,"deferredRender":24},{"title":379,"description":380,"createdAt":30,"path":381,"tags":382},"Binary","Prg1 Binary",[9,352],{"pattern":352,"category":352,"platform":43},"> ğŸ“Œ **Source Code:** [simulation/prg1-binary.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/simulation/prg1-binary.js)\n\n```js\nfunction remove(n) {\n  let c = 0;\n  let r = \"\";\n  for (const dig of n) {\n    if (dig == 0) {\n      c++;\n    } else {\n      r += dig;\n    }\n  }\n  return [r, c];\n}\n\nfunction toBinary(n) {\n  let s = n;\n  let a = [];\n  let r = \"\";\n  while (s > 0) {\n    a.push(s % 2);\n    s = Math.floor(s / 2);\n  }\n  while (a.length > 0) {\n    r += a.pop();\n  }\n  return r;\n}\n\nfunction solution(s) {\n  let count = 0;\n  let removeCount = 0;\n\n  while (s.length > 1) {\n    let [removed, rc] = remove(s);\n    let bin = toBinary(removed.length);\n    console.log(\"inner while : \", bin, removed, rc);\n    removeCount += rc;\n    s = bin;\n    count++;\n  }\n\n  return [count, removeCount];\n}\n\nconsole.log(`result : ${JSON.stringify(solution(\"110010101001\"))}`);\n```","site/content/algorithms/simulation/prg1-binary.mdx","e823dea82e7a4dd5","tree/core",{"id":386,"data":388,"body":393,"filePath":394,"digest":395,"deferredRender":24},{"title":389,"description":390,"createdAt":30,"path":391,"tags":392},"Tree","ì´ì§„ íŠ¸ë¦¬ ê¸°ë³¸ êµ¬í˜„ì²´",[9,64],{"pattern":66,"category":64},"> ğŸ“Œ **Source Code:** [tree/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/tree/core.js)\n\n```js\n// ì´ì§„ íŠ¸ë¦¬ ê¸°ë³¸ êµ¬í˜„ì²´\n\n// ëª¨ë“  ë…¸ë“œì—ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ì¸ ë…¸ë“œë§Œ ì„ íƒí•˜ëŠ” í•¨ìˆ˜\nconst rightSideView = (tree) => {\n  if (tree.length \u003C= 1) return []; // ë¹ˆ íŠ¸ë¦¬ê±°ë‚˜ ë£¨íŠ¸ ë…¸ë“œë§Œ ì—†ëŠ” ê²½ìš°\n\n  const result = [];\n  const queue = [1]; // ë£¨íŠ¸ ë…¸ë“œì˜ ì¸ë±ìŠ¤ (1ë¶€í„° ì‹œì‘)\n\n  while (queue.length > 0) {\n    const levelSize = queue.length; // í˜„ì¬ ë ˆë²¨ì˜ ë…¸ë“œ ìˆ˜\n    let lastNodeValue = null;\n\n    for (let i = 0; i \u003C levelSize; i++) {\n      const currentIndex = queue.shift();\n      if (tree[currentIndex] === null || tree[currentIndex] === undefined)\n        continue;\n\n      lastNodeValue = tree[currentIndex]; // í˜„ì¬ ë ˆë²¨ì˜ ë§ˆì§€ë§‰ ê°’ì„ ì €ì¥\n\n      // ì™¼ìª½ ìì‹ ì¶”ê°€\n      const leftChildIndex = 2 * currentIndex;\n      if (leftChildIndex \u003C tree.length) queue.push(leftChildIndex);\n\n      // ì˜¤ë¥¸ìª½ ìì‹ ì¶”ê°€\n      const rightChildIndex = 2 * currentIndex + 1;\n      if (rightChildIndex \u003C tree.length) queue.push(rightChildIndex);\n    }\n\n    if (lastNodeValue !== null) result.push(lastNodeValue);\n  }\n\n  return result;\n};\n\n// ì˜ˆì œ ì‹¤í–‰\nconsole.log(rightSideView([null, 1, 2, 3, null, 5, null, 4])); // ì¶œë ¥: [1, 3, 4]\nconsole.log(rightSideView([null, 1, 2, 3, 4, null, null, null, 5])); // ì¶œë ¥: [1, 3, 4, 5]\nconsole.log(rightSideView([null, 1, null, 3])); // ì¶œë ¥: [1, 3]\nconsole.log(rightSideView([null])); // ì¶œë ¥: []\n\n/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\n```","site/content/algorithms/tree/core.mdx","d0b8403b1d52a1a5","tree/practice1-making-tree",{"id":396,"data":398,"body":403,"filePath":404,"digest":405,"deferredRender":24},{"title":399,"description":400,"createdAt":30,"path":401,"tags":402},"Practice1 Making Tree","ì´ì§„ íŠ¸ë¦¬ë¥¼ ì „/ì¤‘/í›„ìœ„ ìˆœíšŒí•˜ê¸°",[9,88],{"pattern":88,"category":88},"> ğŸ“Œ **Source Code:** [tree/practice1-making-tree.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/tree/practice1-making-tree.js)\n\n```js\n/*\n *ì´ì§„ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•œ ë°°ì—´ nodesë¥¼ ì¸ìë¡œ ë°›ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ nodesê°€ `[1,2,3,4,5,6,7]`ì´ë¼ë©´ ë‹¤ìŒê³¼ ê°™ì€ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•©ë‹ˆë‹¤.\n * í•´ë‹¹ ì´ì§„íŠ¸ë¦¬ì— ëŒ€í•˜ì—¬ ì „ìœ„ ìˆœíšŒ, ì¤‘ìœ„ìˆœíšŒ, í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” solution()í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.\n * ì¡°ê±´: ë…¸ë“œëŠ” 1 ì´ìƒ 1000ê°œ ì´í•˜. ë…¸ë“œëŠ” ì •ìˆ˜ê°’ì´ë©° ì¤‘ë³µë˜ì§€ ì•ŠëŠ”ë‹¤.\n * */\n\nfunction getPreOrder(nodes) {\n  let result = [empty, ...nodes];\n  for (let i = 1; i \u003C nodes.length; i++) {\n    if (i === 1) {\n      result.push(i);\n      continue;\n    }\n    // í˜„ì¬ ë…¸ë“œê°€ ë¶€ëª¨ë³´ë‹¤ ì‘ìœ¼ë©´?\n    if (nodes[i] \u003C result[i / 2]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n    if (nodes[i] > result[i / 2 + 1]) {\n      let leftGap = Array(i * 2).fill();\n      leftGap[i * 2] = nodes[i];\n      result.push(...leftGap);\n      continue;\n    }\n  }\n  return result;\n}\n\nfunction solution(nodes) {\n  let result = [];\n  let preOrder = getPreOrder(nodes);\n\n  return result;\n}\n```","site/content/algorithms/tree/practice1-making-tree.mdx","4560ff213456e459","tree/prg2-pyramid-scheme",{"id":406,"data":408,"body":413,"filePath":414,"digest":415,"deferredRender":24},{"title":409,"description":410,"createdAt":30,"path":411,"tags":412},"Pyramid Scheme","í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ë‹¤ë‹¨ê³„ íŒë§¤",[9,88],{"pattern":88,"category":88,"platform":43},"> ğŸ“Œ **Source Code:** [tree/prg2-pyramidscheme.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/tree/prg2-pyramidscheme.js)\n\n```js\nfunction solution(enroll, referral, seller, amount) {\n  const sellerMap = new Map();\n  const price = 100;\n  let result = [];\n  for (let member of enroll) {\n    sellerMap.set(`${member}`, { income: 0, shared: \"\" });\n  }\n\n  for (let i = 0; i \u003C referral.length; i++) {\n    // ìì‹ ì„ ë“±ë¡í•œ ì‚¬ëŒë§Œ ê¸°ì–µí•˜ë©´ ë¨\n    if (referral[i] !== \"-\") {\n      const enrolledBy = sellerMap.get(`${enroll[i]}`);\n\n      sellerMap.set(enroll[i], { ...enrolledBy, shared: referral[i] });\n      // ìì‹ ì„ ë“±ë¡í•œ ì‚¬ëŒì—ê²Œ ì´ìµê¸ˆ ê³„ì‚°ì—ì„œ ìì‹ ì˜ ì´ìµê¸ˆì„ ë¹¼ì„œ ë”í•´ì¤Œ.\n      console.log(\n        `${enroll[i]} \\n enrolledBy : ${referral[i]} / ${enroll[i]} data: ${JSON.stringify(sellerMap.get(`${enroll[i]}`))}`,\n      );\n    }\n    // ì¶”ê°€ë¡œ ì¶”ì²œì„ ë°›ì€ ì‚¬ëŒ enroll[i]ëŠ”\n  }\n\n  // ì—¬ê¸°ì„œ ì´ìµ ê³„ì‚°í•¨\n  for (let i = 0; i \u003C seller.length; i++) {\n    const salesman = sellerMap.get(seller[i]);\n    if (!salesman) {\n      continue;\n    }\n    console.log(`${i} - salesman : ${seller[i]}`, salesman);\n    const refer = salesman.shared;\n    const salesCount = amount[i];\n    console.log(`${i} - salesCount`, salesCount);\n    let fee = 0;\n\n    const income = salesCount * price;\n    if (refer) {\n      fee = income / 10;\n    }\n    const netIncome = income - fee;\n    console.log(\n      `${i} income: ${income}\\n fee: ${fee} \\nnetIncome >> \\n`,\n      netIncome,\n    );\n    sellerMap.set(seller[i], {\n      ...salesman,\n      income: salesman.income + netIncome,\n    });\n\n    if (refer) {\n      const referrer = sellerMap.get(refer);\n      // fee ë”í•¨\n      sellerMap.set(refer, { ...referrer, income: referrer.income + fee });\n      console.log(`${i} refer ${refer} >> \\n`, sellerMap.get(refer));\n    }\n  }\n\n  // ì¶”ê°€ë¡œ ì²«ë²ˆì§¸, ë‘ë²ˆì§¸ ì‚¬ëŒë“¤ ìˆ˜ìˆ˜ë£Œ ëº´ì¤˜ì•¼ë¨\n  // ìê¸° ì´ìµ ì „ì²´ì—ì„œ -10% í•´ì¤˜ì•¼ë¨\n  // ê·¸ëƒ¥ objê°€ ì‰¬ìš¸ì§€ë„.\n\n  // ìˆ˜ìˆ˜ë£Œ ë¹¼ê³ , fee ê³„ì† ë”í•´ì„œ income ë‚¨ê²Œ ë¨.\n  console.log(\"before entries :\", sellerMap);\n  let sellerArr = [...sellerMap].map(([, obj]) => obj.income);\n\n  return sellerArr;\n}\n\nlet test1A = [\n  \"john\",\n  \"mary\",\n  \"edward\",\n  \"sam\",\n  \"emily\",\n  \"jaimie\",\n  \"tod\",\n  \"young\",\n];\nlet test1B = [\"-\", \"-\", \"mary\", \"edward\", \"mary\", \"mary\", \"jaimie\", \"edward\"];\nlet test1C = [\"young\", \"john\", \"tod\", \"emily\", \"mary\"];\nlet test1D = [12, 4, 2, 5, 10];\n\nconsole.log(`result : /n`, solution(test1A, test1B, test1C, test1D));\n```","site/content/algorithms/tree/prg2-pyramid-scheme.mdx","9d25d8064ec2f783","tree/prg3-maze",{"id":416,"data":418,"body":423,"filePath":424,"digest":425,"deferredRender":24},{"title":419,"description":420,"createdAt":30,"path":421,"tags":422},"Maze","console.log(`result : /n`, solution(test1A));",[9,88],{"pattern":88,"category":88,"platform":43},"> ğŸ“Œ **Source Code:** [tree/prg3-maze.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/tree/prg3-maze.js)\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  push(data) {\n    this.items.push(data);\n    this.rear++;\n  }\n  pop() {\n    return this.items[this.front++];\n  }\n\n  isEmpty() {\n    return this.front === this.rear;\n  }\n}\n\nfunction getCord(maps, target) {\n  let tRow = maps.findIndex((col) => col.includes(target));\n  let tCol = maps[tRow].split(\"\").findIndex((col) => col === target);\n  return [tRow, tCol];\n}\n\nfunction bfs(maps, start, target) {\n  let direction = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n  let rows = maps.length;\n  let cols = maps[0].length;\n  let visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  let [sRow, sCol] = getCord(maps, start);\n\n  let Q = new Queue();\n  console.log(`\n  sRow : ${sRow}\n  sCol : ${sCol}\n  `);\n\n  Q.push([sRow, sCol, 0]);\n\n  while (!Q.isEmpty()) {\n    const [r, c, dist] = Q.pop();\n\n    console.log(`\n    r : ${r}\n    c : ${c}\n    maps[r][c] : ${maps[r][c]}\n    `);\n\n    if (maps[r][c] === target) {\n      return dist;\n    }\n\n    for (const [dr, dc] of direction) {\n      let nr = r + dr;\n      let nc = c + dc;\n      let updateCondition =\n        nr >= 0 &&\n        nc >= 0 &&\n        nr \u003C rows &&\n        nc \u003C cols &&\n        maps[nr][nc] !== \"X\" &&\n        !visited[nr][nc];\n      if (updateCondition) {\n        visited[nr][nc] = true;\n        Q.push([nr, nc, dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction solution(maps) {\n  let toLeverDist = bfs(maps, \"S\", \"L\");\n  let toEndDist = bfs(maps, \"L\", \"E\");\n  console.log(`----\n  toLeverDist ${toLeverDist}\n  toEndDist : ${toEndDist}\n  --------\n  `);\n  let answer = toLeverDist > 0 && toEndDist > 0 ? toLeverDist + toEndDist : -1;\n  return answer;\n}\nlet test1A = [\"SOOOL\", \"XXXXO\", \"OOOOO\", \"OXXXX\", \"OOOOE\"];\nlet test1B = [\"LOOXS\", \"OOOOX\", \"OOOOO\", \"OOOOO\", \"EOOOO\"];\n\n// console.log(`result : /n`, solution(test1A));\nconsole.log(`result : /n`, solution(test1B));\n```","site/content/algorithms/tree/prg3-maze.mdx","509658f96d6686d5","uiux",["Map",428,429],"button/react-button",{"id":428,"data":430,"body":438,"filePath":439,"digest":440,"deferredRender":24},{"title":431,"description":432,"createdAt":16,"path":433,"tags":436},"React Button (basic)","UIUX Patterns",[426,434,435],"button","react",{"category":437,"component":434,"framework":435},"UI","import CodeDisplay from \"site/components/code-display.astro\";\nimport TabPanel from \"site/components/tab-panel.astro\";\nimport Tabs from \"site/components/tabs.astro\";\nimport Button from \"./button\";\n\n## React Buttons\n\n\u003CTabs tabs={[\"Button Component\", \"button.tsx\"]}>\n  \u003CTabPanel isDefault={true} tabIndex={0} tabName={\"Button Component\"}>\n    \u003CButton client:load text={\"Click me\"} />\n  \u003C/TabPanel>\n  \u003CTabPanel tabName=\"button.tsx\" tabIndex={1}>\n    \u003CCodeDisplay file=\"uiux/button/button.tsx\" highlightLines=\"{5-7}\" />\n  \u003C/TabPanel>\n\u003C/Tabs>","site/content/uiux/button/react-button.mdx","4079ab745d0342db"]