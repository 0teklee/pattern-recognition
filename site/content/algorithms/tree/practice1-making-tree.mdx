---
title: "Practice1 Making Tree"
description: "ì´ì§„ íŠ¸ë¦¬ë¥¼ ì „/ì¤‘/í›„ìœ„ ìˆœíšŒí•˜ê¸°"
createdAt: "2025-03-19"
path: ["algorithms", "tree"]
tags:
  pattern: "tree"
  category: "tree"
---

> ğŸ“Œ **Source Code:** [tree/practice1-making-tree.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/tree/practice1-making-tree.js)

```js
/*
 *ì´ì§„ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•œ ë°°ì—´ nodesë¥¼ ì¸ìë¡œ ë°›ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ nodesê°€ `[1,2,3,4,5,6,7]`ì´ë¼ë©´ ë‹¤ìŒê³¼ ê°™ì€ íŠ¸ë¦¬ë¥¼ í‘œí˜„í•©ë‹ˆë‹¤.
 * í•´ë‹¹ ì´ì§„íŠ¸ë¦¬ì— ëŒ€í•˜ì—¬ ì „ìœ„ ìˆœíšŒ, ì¤‘ìœ„ìˆœíšŒ, í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” solution()í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
 * ì¡°ê±´: ë…¸ë“œëŠ” 1 ì´ìƒ 1000ê°œ ì´í•˜. ë…¸ë“œëŠ” ì •ìˆ˜ê°’ì´ë©° ì¤‘ë³µë˜ì§€ ì•ŠëŠ”ë‹¤.
 * */

function getPreOrder(nodes) {
  let result = [empty, ...nodes];
  for (let i = 1; i < nodes.length; i++) {
    if (i === 1) {
      result.push(i);
      continue;
    }
    // í˜„ì¬ ë…¸ë“œê°€ ë¶€ëª¨ë³´ë‹¤ ì‘ìœ¼ë©´?
    if (nodes[i] < result[i / 2]) {
      let leftGap = Array(i * 2).fill();
      leftGap[i * 2] = nodes[i];
      result.push(...leftGap);
      continue;
    }
    if (nodes[i] > result[i / 2 + 1]) {
      let leftGap = Array(i * 2).fill();
      leftGap[i * 2] = nodes[i];
      result.push(...leftGap);
      continue;
    }
  }
  return result;
}

function solution(nodes) {
  let result = [];
  let preOrder = getPreOrder(nodes);

  return result;
}
```
