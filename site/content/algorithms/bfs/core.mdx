---
title: "Bfs"
description: "1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„"
createdAt: "2025-03-19"
path: ["algorithms", "core"]
tags:
  pattern: ""
  category: "core"
---

> ðŸ“Œ **Source Code:** [bfs/core.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/bfs/core.js)

```js
class Queue {
  constructor() {
    this.items = [];
    this.front = 0;
    this.rear = 0;
  }
  enqueue(data) {
    this.items.push(data);
    this.rear++;
  }
  dequeue() {
    return this.items[this.front++];
  }
  isEmpty() {
    return this.front === this.rear;
  }
}

function bfs(start, graph, visited, answer) {
  let Q = new Queue();
  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„
  /* ìµœì†Œ, ìµœë‹¨ ê±°ë¦¬ ë“±ì„ ê³„ì‚°í•´ì•¼í•œë‹¤ë©´ paramìœ¼ë¡œ ë°›ê³ ,
   ë°˜ë³µë¬¸ ì•ˆì—ì„œ ì¡°ê±´ì— ë§žì„ ì‹œ ì—…ë°ì´íŠ¸ í•œ ë’¤ returní•œë‹¤.
   í˜¹ì€ í•´ë‹¹í•˜ëŠ” ì¢Œí‘œì˜ ë¬¶ìŒ ë“±ì„ í•„ìš”ë¡œ í•  ì‹œ
    let result = [start];ë¥¼ ë°˜ë³µë¬¸ ì™¸ë¶€ì— ë§Œë“¤ê³ ,
    result.push(newNode)ë¥¼ í•˜ë©´ ë°©ë¬¸í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ìŒ“ì´ê²Œ ëœë‹¤.
    */

  // í ì‹œìž‘ì  ì¶”ê°€
  Q.push(start); // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ start í˜•íƒœ ë‹¤ë¦„
  while (!Q.isEmpty()) {
    let start = Q.dequeue();
    // ì¡°ê±´ë¬¸ ì¶”ê°€

    for (let neighbor of graph[start]) {
      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§žê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´
      if (!visited[neighbor]) {
        //  answer++;, í˜¹ì€ ë¬¸ì œ ì¡°ê±´ì— ë”°ë¼ bfs ë‚´ë¶€ì—ì„œ resultë¥¼ ëª¨ì•„ pushí•  ìˆ˜ ë„ ìžˆìŒ.
        visited[neighbor] = true; // ì´ ì¡°ê±´ ì–¸ì œ ì¶”ê°€í•´ì•¼í•˜ì§€?
        Q.enqueue(neighbor);
      }
    }
  }
  return answer;
}

// offset ì‚¬ìš©í•˜ëŠ” bfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©

const offset = [
  [0, -1],
  [0, 1],
  [1, 0],
  [-1, 0],
];

function bfsOffset(visited, graph, [startR, startC], answer) {
  let Q = new Queue();
  visited[startR][startC] = true;
  Q.enqueue([startR, startC]);
  while (!Q.isEmpty()) {
    let [curR, curC] = Q.dequeue();

    for (let [or, oc] of offset) {
      let [nr, nc] = [curR + or, curC + oc];
      if (
        nr >= 0 &&
        nc >= 0 &&
        nr < graph.length &&
        nc < graph[0].length &&
        !visited[nr][nc]
        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§žëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..
      ) {
        visited[nr][nc] = true;
        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©
        Q.enqueue([nr, nc]);
      }
    }
  }
  return answer;
}
```
