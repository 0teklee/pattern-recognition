---
title: "Dfs"
description: "ì¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs"
createdAt: "2025-03-19"
path: ["algorithms", "core"]
tags:
  pattern: ""
  category: "core"
---

> ğŸ“Œ **Source Code:** [core/dfs.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/algorithms/dfs/core.js)

```js
// ì¬ê·€ í•¨ìˆ˜ ì‚¬ìš©í•˜ëŠ” dfs
function recursiveDfs(start, graph, visited, answer) {
  // ì¬ê·€ í˜¸ì¶œ ì‹œ ë°©ë¬¸ ì—¬ë¶€ ì—…ë°ì´íŠ¸ ìœ„ì¹˜ ì£¼ì˜
  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„
  // ë¬¸ì œê°€ ìš”êµ¬í•˜ëŠ” ë°˜í™˜ê°’ì´ ë¬´ì—‡ì¸ì§€ì— ë”°ë¼ ë°˜í™˜ê°’, í•¨ìˆ˜ ì¸ì, ì—…ë°ì´íŠ¸ ì¡°ê±´ ë“±ì´ ë‹¬ë¼ì§„ë‹¤.
  // answerì´ ìˆ«ìë¼ë©´ íŠ¹ì • ìˆ«ì ì´í•˜ì¼ ë•Œ dfs ì¬ê·€ í˜¸ì¶œì„ ë°±íŠ¸ë˜í‚¹í•  ìˆ˜ ìˆë‹¤.

  // ì¬ê·€ í•¨ìˆ˜ ìŠ¤íƒì— ë“¤ì–´ê°€ê¸° ì „ì— ì¡°ê±´ë¬¸ì„ ì¶”ê°€í•˜ì—¬ return í•  ìˆ˜ë„ ìˆë‹¤.
  // ì´ ë•Œ ì¤‘ë‹¨ë˜ëŠ” ê²ƒì€ ë”ì´ìƒ ì•„ë˜ ë…¸ë“œë“¤ì´ ì¡°ê±´ì— ë¶€í•©í•˜ì§€ ì•ŠëŠ” ê²½ìš° ì´ë‹¤.
  while (!visited[start] && !!graph[start] && graph[start].length > 0) {
    // ì´ ì¡°ê±´ì—ì„œ !graph[start]ì™€ graph[start].length < 0 ì€ ìµœí•˜ìœ„ ë…¸ë“œê°€ ëœë‹¤
    // ê·¸ë˜í”„ê°€ startëŠ” ê°ì²´ í‚¤(ë¶€ëª¨ ë…¸ë“œ ì´ë¦„)ë‚˜ ë°°ì—´(ë¶€ëª¨ ë…¸ë“œì˜ ì¸ë±ìŠ¤)ê°€ ë  ìˆ˜ ìˆë‹¤.
    for (let neighbor of graph[start]) {
      dfs(neighbor, graph, visited, answer);
    }
  }
  // ë°˜ë³µë¬¸ ì™¸ë¶€ì—ì„œ answer.push(neighbor)í•˜ì—¬ ë…¸ë“œë¥¼ ì €ì¥í•  ìˆ˜ ìˆë‹¤.
  // ë§Œì•½ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤ë©´, stackì—ì„œ ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê¸° ë•Œë¬¸ì— .reverse()í•˜ì—¬ ë°˜í™˜í•´ì•¼
  // ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.
  return;
}

// í•¨ìˆ˜ ë‚´ë¶€ì— stackì„ ë§Œë“¤ì–´ ì‚¬ìš©í•˜ëŠ” dfs
function stackDfs(start, graph, visited, answer) {
  let stack = [start];
  // ì´ˆê¸° ì‹œì‘ì  startë¥¼ ìŠ¤íƒì— ë¯¸ë¦¬ ì¶”ê°€í•˜ê³ , ë°©ë¬¸ ì—¬ë¶€ì— ì²´í¬í•œë‹¤
  visited[start] = true; // 1,2ì°¨ì› ë°°ì—´ì— ë”°ë¼ ë‹¤ë¦„
  //
  let result = [];
  while (stack.length > 0) {
    let current = stack.pop();

    for (let neighbor of graph[current]) {
      // ë°©ë¬¸ ì—¬ë¶€ + graph[neighbor]ê°€ ë¬¸ì œ ì¡°ê±´ì— ë§ê±°ë‚˜ í‹€ë¦´ ì‹œ ì¶”ê°€ ì¡°ê±´
      if (
        !visited[neighbor]
        // && ë¬¸ì œì— ë§ëŠ” ì¡°ê±´ ì¶”ê°€ ê°€ëŠ¥ graph[neighbor] ===, >, < {X} ë“±.
      ) {
        //  answer++;
        visited[neighbor] = true; // ì¡°ê±´ ì¶”ê°€ íƒ€ì´ë°ì„ ì •ë¦¬í•˜ê³  ì‹¶ë‹¤
        stack.push(neighbor);
      }
    }
    // result.push(current) -
    // ì´ ìœ„ì¹˜ì—ì„œ pushí•˜ë©´ ìµœí•˜ìœ„ ë…¸ë“œë¶€í„° ìŒ“ì„
    // = ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ê²Œ ë˜ì„œ ë§ˆì§€ë§‰ì— reverse()í•´ì£¼ì–´ì•¼ í•œë‹¤.
    // í•˜ì§€ë§Œ ê°€ì¥ ê¹”ë”í•œ ë°©ì‹ì¼ ìˆ˜ ìˆë‹¤.
    // forë¬¸ ìœ„ì—ì„œ í•˜ë©´ ìì‹ë…¸ë“œë³´ë‹¤ ë¶€ëª¨ ë…¸ë“œì˜ ì •ë³´ê°€ ë¨¼ì € ìŒ“ì´ëŠ”ë°,
    // ê²°ê³¼ê°€ ì •í™•í•´ì§€ì§€ ì•ŠëŠ”ë‹¤. ì™œì¸ì§€ëŠ” ì˜ ê¸°ì–µ ì•ˆë‚¨. -> ì´ì œ ì•ŒìŒ
  }
  return; // answer;
}

// offset ì‚¬ìš©í•˜ëŠ” dfs. ì£¼ë¡œ 2ì°¨ì› ë°°ì—´ ê·¸ë¦¬ë“œ ë¬¸ì œì—ì„œ ì‚¬ìš©

const offset = [
  [0, -1],
  [0, 1],
  [1, 0],
  [-1, 0],
];

function dfsOffset(visited, graph, [startR, startC], answer) {
  let stack = [[startR, startC]];
  visited[startR][startC] = true;
  let result = [];

  while (stack.length > 0) {
    let [curR, curC] = stack.pop();

    for (let [or, oc] of offset) {
      let [nr, nc] = [curR + or, curC + oc];
      if (
        nr >= 0 &&
        nc >= 0 &&
        nr < graph.length &&
        nc < graph[0].length &&
        !visited[nr][nc]
        //  &&   ë¬¸ì œ ì¡°ê±´ì— ë§ëŠ” ì¡°ê±´ ì¶”ê°€. graph[nr][nc] === 1, ê¸°íƒ€ ë“±ë“±..
      ) {
        visited[nr][nc] = true;
        // answerì— ê°’ì„ ì—…ë°ì´íŠ¸ í•´ì•¼í•œë‹¤ë©´ answer++, ==, += ê¸°íƒ€ ë“±ë“± í™œìš©
        stack.push([nr, nc]);
      }
    }
    // curR, curCë¥¼ ëª¨ì•„ì•¼ í•œë‹¤ë©´, resultì— push í•´ì¤€ë‹¤.
    result.push([curR, curC]);
    // ì œì¼ ì²« startR,Cê°€ resultì— í‘¸ì‹œë˜ê³ 
    // ê·¸ ë‹¤ìŒ stackì˜ ê°€ì¥ ìœ„ì— ìˆëŠ” ìµœí•˜ìœ„ ë…¸ë“œê°€ ì‹¤í–‰ë¨
  }

  return answer;
}
```
