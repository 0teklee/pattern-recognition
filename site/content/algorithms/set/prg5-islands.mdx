---
title: "Islands"
description: "parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜"
createdAt: "2025-03-19"
path: ["algorithms", "set"]
tags:
  pattern: "set"
  category: "set"
  platform: "programmers"
---

> ğŸ“Œ **Source Code:** [set/prg5-islands.js](https://github.com/0teklee/pattern-recognition/tree/main/site/content/set/prg5-islands.js)

```js
// parent ë°°ì—´ì—ì„œ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜
// ë£¨íŠ¸ ë…¸ë“œë€ ì§‘í•©ì˜ ëŒ€í‘œì (ì¦‰, ìµœìƒìœ„ ë¶€ëª¨ ë…¸ë“œ)
// ê²½ë¡œ ì••ì¶•ì„ í†µí•´ íƒìƒ‰ ê²½ë¡œë¥¼ ìµœì í™”
function find(parents, x) {
  // xê°€ ìì‹ ì˜ ë¶€ëª¨ ë…¸ë“œë¼ë©´ (ì¦‰, ë£¨íŠ¸ ë…¸ë“œë¼ë©´)
  if (parents[x] == x) {
    return x; // ë£¨íŠ¸ ë…¸ë“œ ë°˜í™˜
  }
  // xê°€ ë£¨íŠ¸ê°€ ì•„ë‹ˆë©´, ì¬ê·€ í˜¸ì¶œì„ í†µí•´ ë£¨íŠ¸ë¥¼ ì°¾ìŒ
  // ì°¾ìœ¼ë©´ì„œ ë¶€ëª¨ë¥¼ ë£¨íŠ¸ë¡œ ê°±ì‹  (ê²½ë¡œ ì••ì¶•)
  parents[x] = find(parents, parents[x]);
  return parents[x]; // ìµœì¢… ë£¨íŠ¸ ë°˜í™˜
}

// ë‘ ë…¸ë“œì˜ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜ (Union by Rank)
// RankëŠ” íŠ¸ë¦¬ì˜ ê¹Šì´ë¥¼ ì˜ë¯¸í•˜ë©°, ë” ë‚®ì€ íŠ¸ë¦¬ë¥¼ ë†’ì€ íŠ¸ë¦¬ì— ë¶™ì„
function union(parent, rank, x, y) {
  const xroot = find(parent, x); // xì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°
  const yroot = find(parent, y); // yì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°

  // Rankë¥¼ ë¹„êµí•˜ì—¬ íŠ¸ë¦¬ì˜ ê· í˜• ìœ ì§€
  if (rank[xroot] < rank[yroot]) {
    parent[xroot] = yroot; // xroot íŠ¸ë¦¬ë¥¼ yrootì— ì—°ê²°
  } else if (rank[xroot] > rank[yroot]) {
    parent[yroot] = xroot; // yroot íŠ¸ë¦¬ë¥¼ xrootì— ì—°ê²°
  } else {
    // ë­í¬ê°€ ê°™ë‹¤ë©´ xrootë¥¼ ë¶€ëª¨ë¡œ ì„¤ì •í•˜ê³ , ë­í¬ë¥¼ 1 ì¦ê°€
    parent[yroot] = xroot;
    rank[xroot] += 1;
  }
}

// ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST) ë¹„ìš© ê³„ì‚° í•¨ìˆ˜
function solution(n, costs) {
  // 1. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
  costs.sort((a, b) => a[2] - b[2]); // MSTë¥¼ ìœ„í•´ ê°€ì¥ ë‚®ì€ ë¹„ìš©ì˜ ê°„ì„ ì„ ë¨¼ì € ì²˜ë¦¬

  // 2. parent ë°°ì—´ê³¼ rank ë°°ì—´ ì´ˆê¸°í™”
  // ê° ë…¸ë“œëŠ” ì²˜ìŒì—” ìê¸° ìì‹ ì´ ë£¨íŠ¸ì¸ ë…ë¦½ ì§‘í•©
  const parent = Array.from({ length: n }, (_, i) => i);
  const rank = Array(n).fill(0); // ëª¨ë“  ë…¸ë“œì˜ ì´ˆê¸° RankëŠ” 0

  let minCost = 0; // MSTì˜ ì´ ë¹„ìš©
  let edges = 0; // í˜„ì¬ê¹Œì§€ MSTì— í¬í•¨ëœ ê°„ì„ ì˜ ìˆ˜

  // 3. ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° MSTë¥¼ êµ¬ì„±
  for (const edge of costs) {
    if (edges == n - 1) {
      // MSTì˜ ê°„ì„  ìˆ˜ê°€ n-1ì´ë©´ ì¤‘ë‹¨
      break;
    }
    // edge = [ë…¸ë“œ1, ë…¸ë“œ2, ë¹„ìš©]
    const x = find(parent, edge[0]); // ë…¸ë“œ1ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°
    const y = find(parent, edge[1]); // ë…¸ë“œ2ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°

    if (x !== y) {
      // ë‘ ë…¸ë“œê°€ ê°™ì€ ì§‘í•©ì— ì†í•˜ì§€ ì•Šìœ¼ë©´ ì—°ê²°
      union(parent, rank, x, y); // ë‘ ë…¸ë“œë¥¼ ê°™ì€ ì§‘í•©ìœ¼ë¡œ ë¬¶ìŒ
      minCost += edge[2]; // ê°„ì„ ì˜ ë¹„ìš©ì„ ì´ ë¹„ìš©ì— ì¶”ê°€
      edges += 1; // ê°„ì„  ìˆ˜ ì¦ê°€
    }
    // ë‘ ë…¸ë“œê°€ ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ì—°ê²°í•˜ì§€ ì•ŠìŒ (ì‚¬ì´í´ ë°©ì§€)
  }

  return minCost; // MSTì˜ ìµœì†Œ ë¹„ìš© ë°˜í™˜
}

// ì˜ˆì œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
console.log(
  "result : ",
  solution(4, [
    [0, 1, 1],
    [0, 2, 2],
    [1, 2, 5],
    [1, 3, 1],
    [2, 3, 8],
  ]),
);
// ê²°ê³¼: 4 (MSTì˜ ìµœì†Œ ë¹„ìš©)
```
